{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GridFSBucketWriteStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst write_concern_1 = require(\"./../write_concern\");\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n * @public\n */\n\n\nclass GridFSBucketWriteStream extends stream_1.Writable {\n  /** @internal\n   * @param bucket - Handle for this stream's corresponding bucket\n   * @param filename - The value of the 'filename' key in the files doc\n   * @param options - Optional settings.\n   */\n  constructor(bucket, filename, options) {\n    super();\n    options = options !== null && options !== void 0 ? options : {};\n    this.bucket = bucket;\n    this.chunks = bucket.s._chunksCollection;\n    this.filename = filename;\n    this.files = bucket.s._filesCollection;\n    this.options = options;\n    this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern; // Signals the write is all done\n\n    this.done = false;\n    this.id = options.id ? options.id : new bson_1.ObjectId(); // properly inherit the default chunksize from parent\n\n    this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;\n    this.bufToStore = Buffer.alloc(this.chunkSizeBytes);\n    this.length = 0;\n    this.n = 0;\n    this.pos = 0;\n    this.state = {\n      streamEnd: false,\n      outstandingRequests: 0,\n      errored: false,\n      aborted: false\n    };\n\n    if (!this.bucket.s.calledOpenUploadStream) {\n      this.bucket.s.calledOpenUploadStream = true;\n      checkIndexes(this, () => {\n        this.bucket.s.checkedIndexes = true;\n        this.bucket.emit('index');\n      });\n    }\n  }\n\n  write(chunk, encodingOrCallback, callback) {\n    const encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;\n    callback = typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;\n    return waitForIndexes(this, () => doWrite(this, chunk, encoding, callback));\n  }\n\n  abort(callback) {\n    return utils_1.maybePromise(callback, callback => {\n      if (this.state.streamEnd) {\n        // TODO(NODE-3485): Replace with MongoGridFSStreamClosed\n        return callback(new error_1.MongoAPIError('Cannot abort a stream that has already completed'));\n      }\n\n      if (this.state.aborted) {\n        // TODO(NODE-3485): Replace with MongoGridFSStreamClosed\n        return callback(new error_1.MongoAPIError('Cannot call abort() on a stream twice'));\n      }\n\n      this.state.aborted = true;\n      this.chunks.deleteMany({\n        files_id: this.id\n      }, error => callback(error));\n    });\n  }\n\n  end(chunkOrCallback, encodingOrCallback, callback) {\n    const chunk = typeof chunkOrCallback === 'function' ? undefined : chunkOrCallback;\n    const encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;\n    callback = typeof chunkOrCallback === 'function' ? chunkOrCallback : typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;\n    if (checkAborted(this, callback)) return;\n    this.state.streamEnd = true;\n\n    if (callback) {\n      this.once(GridFSBucketWriteStream.FINISH, result => {\n        if (callback) callback(undefined, result);\n      });\n    }\n\n    if (!chunk) {\n      waitForIndexes(this, () => !!writeRemnant(this));\n      return;\n    }\n\n    this.write(chunk, encoding, () => {\n      writeRemnant(this);\n    });\n  }\n\n}\n\nexports.GridFSBucketWriteStream = GridFSBucketWriteStream;\n/** @event */\n\nGridFSBucketWriteStream.CLOSE = 'close';\n/** @event */\n\nGridFSBucketWriteStream.ERROR = 'error';\n/**\n * `end()` was called and the write stream successfully wrote the file metadata and all the chunks to MongoDB.\n * @event\n */\n\nGridFSBucketWriteStream.FINISH = 'finish';\n\nfunction __handleError(stream, error, callback) {\n  if (stream.state.errored) {\n    return;\n  }\n\n  stream.state.errored = true;\n\n  if (callback) {\n    return callback(error);\n  }\n\n  stream.emit(GridFSBucketWriteStream.ERROR, error);\n}\n\nfunction createChunkDoc(filesId, n, data) {\n  return {\n    _id: new bson_1.ObjectId(),\n    files_id: filesId,\n    n,\n    data\n  };\n}\n\nfunction checkChunksIndex(stream, callback) {\n  stream.chunks.listIndexes().toArray((error, indexes) => {\n    let index;\n\n    if (error) {\n      // Collection doesn't exist so create index\n      if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n        index = {\n          files_id: 1,\n          n: 1\n        };\n        stream.chunks.createIndex(index, {\n          background: false,\n          unique: true\n        }, error => {\n          if (error) {\n            return callback(error);\n          }\n\n          callback();\n        });\n        return;\n      }\n\n      return callback(error);\n    }\n\n    let hasChunksIndex = false;\n\n    if (indexes) {\n      indexes.forEach(index => {\n        if (index.key) {\n          const keys = Object.keys(index.key);\n\n          if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {\n            hasChunksIndex = true;\n          }\n        }\n      });\n    }\n\n    if (hasChunksIndex) {\n      callback();\n    } else {\n      index = {\n        files_id: 1,\n        n: 1\n      };\n      const writeConcernOptions = getWriteOptions(stream);\n      stream.chunks.createIndex(index, { ...writeConcernOptions,\n        background: true,\n        unique: true\n      }, callback);\n    }\n  });\n}\n\nfunction checkDone(stream, callback) {\n  if (stream.done) return true;\n\n  if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {\n    // Set done so we do not trigger duplicate createFilesDoc\n    stream.done = true; // Create a new files doc\n\n    const filesDoc = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);\n\n    if (checkAborted(stream, callback)) {\n      return false;\n    }\n\n    stream.files.insertOne(filesDoc, getWriteOptions(stream), error => {\n      if (error) {\n        return __handleError(stream, error, callback);\n      }\n\n      stream.emit(GridFSBucketWriteStream.FINISH, filesDoc);\n      stream.emit(GridFSBucketWriteStream.CLOSE);\n    });\n    return true;\n  }\n\n  return false;\n}\n\nfunction checkIndexes(stream, callback) {\n  stream.files.findOne({}, {\n    projection: {\n      _id: 1\n    }\n  }, (error, doc) => {\n    if (error) {\n      return callback(error);\n    }\n\n    if (doc) {\n      return callback();\n    }\n\n    stream.files.listIndexes().toArray((error, indexes) => {\n      let index;\n\n      if (error) {\n        // Collection doesn't exist so create index\n        if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n          index = {\n            filename: 1,\n            uploadDate: 1\n          };\n          stream.files.createIndex(index, {\n            background: false\n          }, error => {\n            if (error) {\n              return callback(error);\n            }\n\n            checkChunksIndex(stream, callback);\n          });\n          return;\n        }\n\n        return callback(error);\n      }\n\n      let hasFileIndex = false;\n\n      if (indexes) {\n        indexes.forEach(index => {\n          const keys = Object.keys(index.key);\n\n          if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {\n            hasFileIndex = true;\n          }\n        });\n      }\n\n      if (hasFileIndex) {\n        checkChunksIndex(stream, callback);\n      } else {\n        index = {\n          filename: 1,\n          uploadDate: 1\n        };\n        const writeConcernOptions = getWriteOptions(stream);\n        stream.files.createIndex(index, { ...writeConcernOptions,\n          background: false\n        }, error => {\n          if (error) {\n            return callback(error);\n          }\n\n          checkChunksIndex(stream, callback);\n        });\n      }\n    });\n  });\n}\n\nfunction createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {\n  const ret = {\n    _id,\n    length,\n    chunkSize,\n    uploadDate: new Date(),\n    filename\n  };\n\n  if (contentType) {\n    ret.contentType = contentType;\n  }\n\n  if (aliases) {\n    ret.aliases = aliases;\n  }\n\n  if (metadata) {\n    ret.metadata = metadata;\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, chunk, encoding, callback) {\n  if (checkAborted(stream, callback)) {\n    return false;\n  }\n\n  const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n  stream.length += inputBuf.length; // Input is small enough to fit in our buffer\n\n  if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {\n    inputBuf.copy(stream.bufToStore, stream.pos);\n    stream.pos += inputBuf.length;\n    callback && callback(); // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // True means client can keep writing.\n\n    return true;\n  } // Otherwise, buffer is too big for current chunk, so we need to flush\n  // to MongoDB.\n\n\n  let inputBufRemaining = inputBuf.length;\n  let spaceRemaining = stream.chunkSizeBytes - stream.pos;\n  let numToCopy = Math.min(spaceRemaining, inputBuf.length);\n  let outstandingRequests = 0;\n\n  while (inputBufRemaining > 0) {\n    const inputBufPos = inputBuf.length - inputBufRemaining;\n    inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);\n    stream.pos += numToCopy;\n    spaceRemaining -= numToCopy;\n    let doc;\n\n    if (spaceRemaining === 0) {\n      doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));\n      ++stream.state.outstandingRequests;\n      ++outstandingRequests;\n\n      if (checkAborted(stream, callback)) {\n        return false;\n      }\n\n      stream.chunks.insertOne(doc, getWriteOptions(stream), error => {\n        if (error) {\n          return __handleError(stream, error);\n        }\n\n        --stream.state.outstandingRequests;\n        --outstandingRequests;\n\n        if (!outstandingRequests) {\n          stream.emit('drain', doc);\n          callback && callback();\n          checkDone(stream);\n        }\n      });\n      spaceRemaining = stream.chunkSizeBytes;\n      stream.pos = 0;\n      ++stream.n;\n    }\n\n    inputBufRemaining -= numToCopy;\n    numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n  } // Note that we reverse the typical semantics of write's return value\n  // to be compatible with node's `.pipe()` function.\n  // False means the client should wait for the 'drain' event.\n\n\n  return false;\n}\n\nfunction getWriteOptions(stream) {\n  const obj = {};\n\n  if (stream.writeConcern) {\n    obj.writeConcern = {\n      w: stream.writeConcern.w,\n      wtimeout: stream.writeConcern.wtimeout,\n      j: stream.writeConcern.j\n    };\n  }\n\n  return obj;\n}\n\nfunction waitForIndexes(stream, callback) {\n  if (stream.bucket.s.checkedIndexes) {\n    return callback(false);\n  }\n\n  stream.bucket.once('index', () => {\n    callback(true);\n  });\n  return true;\n}\n\nfunction writeRemnant(stream, callback) {\n  // Buffer is empty, so don't bother to insert\n  if (stream.pos === 0) {\n    return checkDone(stream, callback);\n  }\n\n  ++stream.state.outstandingRequests; // Create a new buffer to make sure the buffer isn't bigger than it needs\n  // to be.\n\n  const remnant = Buffer.alloc(stream.pos);\n  stream.bufToStore.copy(remnant, 0, 0, stream.pos);\n  const doc = createChunkDoc(stream.id, stream.n, remnant); // If the stream was aborted, do not write remnant\n\n  if (checkAborted(stream, callback)) {\n    return false;\n  }\n\n  stream.chunks.insertOne(doc, getWriteOptions(stream), error => {\n    if (error) {\n      return __handleError(stream, error);\n    }\n\n    --stream.state.outstandingRequests;\n    checkDone(stream);\n  });\n  return true;\n}\n\nfunction checkAborted(stream, callback) {\n  if (stream.state.aborted) {\n    if (typeof callback === 'function') {\n      // TODO(NODE-3485): Replace with MongoGridFSStreamClosedError\n      callback(new error_1.MongoAPIError('Stream has been aborted'));\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","GridFSBucketWriteStream","stream_1","require","bson_1","error_1","utils_1","write_concern_1","Writable","constructor","bucket","filename","options","chunks","s","_chunksCollection","files","_filesCollection","writeConcern","WriteConcern","fromOptions","done","id","ObjectId","chunkSizeBytes","bufToStore","Buffer","alloc","length","n","pos","state","streamEnd","outstandingRequests","errored","aborted","calledOpenUploadStream","checkIndexes","checkedIndexes","emit","write","chunk","encodingOrCallback","callback","encoding","undefined","waitForIndexes","doWrite","abort","maybePromise","MongoAPIError","deleteMany","files_id","error","end","chunkOrCallback","checkAborted","once","FINISH","result","writeRemnant","CLOSE","ERROR","__handleError","stream","createChunkDoc","filesId","data","_id","checkChunksIndex","listIndexes","toArray","indexes","index","MongoError","code","MONGODB_ERROR_CODES","NamespaceNotFound","createIndex","background","unique","hasChunksIndex","forEach","key","keys","writeConcernOptions","getWriteOptions","checkDone","filesDoc","createFilesDoc","contentType","aliases","metadata","insertOne","findOne","projection","doc","uploadDate","hasFileIndex","chunkSize","ret","Date","inputBuf","isBuffer","from","copy","inputBufRemaining","spaceRemaining","numToCopy","Math","min","inputBufPos","obj","w","wtimeout","j","remnant"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/gridfs/upload.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GridFSBucketWriteStream = void 0;\nconst stream_1 = require(\"stream\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst write_concern_1 = require(\"./../write_concern\");\n/**\n * A writable stream that enables you to write buffers to GridFS.\n *\n * Do not instantiate this class directly. Use `openUploadStream()` instead.\n * @public\n */\nclass GridFSBucketWriteStream extends stream_1.Writable {\n    /** @internal\n     * @param bucket - Handle for this stream's corresponding bucket\n     * @param filename - The value of the 'filename' key in the files doc\n     * @param options - Optional settings.\n     */\n    constructor(bucket, filename, options) {\n        super();\n        options = options !== null && options !== void 0 ? options : {};\n        this.bucket = bucket;\n        this.chunks = bucket.s._chunksCollection;\n        this.filename = filename;\n        this.files = bucket.s._filesCollection;\n        this.options = options;\n        this.writeConcern = write_concern_1.WriteConcern.fromOptions(options) || bucket.s.options.writeConcern;\n        // Signals the write is all done\n        this.done = false;\n        this.id = options.id ? options.id : new bson_1.ObjectId();\n        // properly inherit the default chunksize from parent\n        this.chunkSizeBytes = options.chunkSizeBytes || this.bucket.s.options.chunkSizeBytes;\n        this.bufToStore = Buffer.alloc(this.chunkSizeBytes);\n        this.length = 0;\n        this.n = 0;\n        this.pos = 0;\n        this.state = {\n            streamEnd: false,\n            outstandingRequests: 0,\n            errored: false,\n            aborted: false\n        };\n        if (!this.bucket.s.calledOpenUploadStream) {\n            this.bucket.s.calledOpenUploadStream = true;\n            checkIndexes(this, () => {\n                this.bucket.s.checkedIndexes = true;\n                this.bucket.emit('index');\n            });\n        }\n    }\n    write(chunk, encodingOrCallback, callback) {\n        const encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;\n        callback = typeof encodingOrCallback === 'function' ? encodingOrCallback : callback;\n        return waitForIndexes(this, () => doWrite(this, chunk, encoding, callback));\n    }\n    abort(callback) {\n        return utils_1.maybePromise(callback, callback => {\n            if (this.state.streamEnd) {\n                // TODO(NODE-3485): Replace with MongoGridFSStreamClosed\n                return callback(new error_1.MongoAPIError('Cannot abort a stream that has already completed'));\n            }\n            if (this.state.aborted) {\n                // TODO(NODE-3485): Replace with MongoGridFSStreamClosed\n                return callback(new error_1.MongoAPIError('Cannot call abort() on a stream twice'));\n            }\n            this.state.aborted = true;\n            this.chunks.deleteMany({ files_id: this.id }, error => callback(error));\n        });\n    }\n    end(chunkOrCallback, encodingOrCallback, callback) {\n        const chunk = typeof chunkOrCallback === 'function' ? undefined : chunkOrCallback;\n        const encoding = typeof encodingOrCallback === 'function' ? undefined : encodingOrCallback;\n        callback =\n            typeof chunkOrCallback === 'function'\n                ? chunkOrCallback\n                : typeof encodingOrCallback === 'function'\n                    ? encodingOrCallback\n                    : callback;\n        if (checkAborted(this, callback))\n            return;\n        this.state.streamEnd = true;\n        if (callback) {\n            this.once(GridFSBucketWriteStream.FINISH, (result) => {\n                if (callback)\n                    callback(undefined, result);\n            });\n        }\n        if (!chunk) {\n            waitForIndexes(this, () => !!writeRemnant(this));\n            return;\n        }\n        this.write(chunk, encoding, () => {\n            writeRemnant(this);\n        });\n    }\n}\nexports.GridFSBucketWriteStream = GridFSBucketWriteStream;\n/** @event */\nGridFSBucketWriteStream.CLOSE = 'close';\n/** @event */\nGridFSBucketWriteStream.ERROR = 'error';\n/**\n * `end()` was called and the write stream successfully wrote the file metadata and all the chunks to MongoDB.\n * @event\n */\nGridFSBucketWriteStream.FINISH = 'finish';\nfunction __handleError(stream, error, callback) {\n    if (stream.state.errored) {\n        return;\n    }\n    stream.state.errored = true;\n    if (callback) {\n        return callback(error);\n    }\n    stream.emit(GridFSBucketWriteStream.ERROR, error);\n}\nfunction createChunkDoc(filesId, n, data) {\n    return {\n        _id: new bson_1.ObjectId(),\n        files_id: filesId,\n        n,\n        data\n    };\n}\nfunction checkChunksIndex(stream, callback) {\n    stream.chunks.listIndexes().toArray((error, indexes) => {\n        let index;\n        if (error) {\n            // Collection doesn't exist so create index\n            if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n                index = { files_id: 1, n: 1 };\n                stream.chunks.createIndex(index, { background: false, unique: true }, error => {\n                    if (error) {\n                        return callback(error);\n                    }\n                    callback();\n                });\n                return;\n            }\n            return callback(error);\n        }\n        let hasChunksIndex = false;\n        if (indexes) {\n            indexes.forEach((index) => {\n                if (index.key) {\n                    const keys = Object.keys(index.key);\n                    if (keys.length === 2 && index.key.files_id === 1 && index.key.n === 1) {\n                        hasChunksIndex = true;\n                    }\n                }\n            });\n        }\n        if (hasChunksIndex) {\n            callback();\n        }\n        else {\n            index = { files_id: 1, n: 1 };\n            const writeConcernOptions = getWriteOptions(stream);\n            stream.chunks.createIndex(index, {\n                ...writeConcernOptions,\n                background: true,\n                unique: true\n            }, callback);\n        }\n    });\n}\nfunction checkDone(stream, callback) {\n    if (stream.done)\n        return true;\n    if (stream.state.streamEnd && stream.state.outstandingRequests === 0 && !stream.state.errored) {\n        // Set done so we do not trigger duplicate createFilesDoc\n        stream.done = true;\n        // Create a new files doc\n        const filesDoc = createFilesDoc(stream.id, stream.length, stream.chunkSizeBytes, stream.filename, stream.options.contentType, stream.options.aliases, stream.options.metadata);\n        if (checkAborted(stream, callback)) {\n            return false;\n        }\n        stream.files.insertOne(filesDoc, getWriteOptions(stream), (error) => {\n            if (error) {\n                return __handleError(stream, error, callback);\n            }\n            stream.emit(GridFSBucketWriteStream.FINISH, filesDoc);\n            stream.emit(GridFSBucketWriteStream.CLOSE);\n        });\n        return true;\n    }\n    return false;\n}\nfunction checkIndexes(stream, callback) {\n    stream.files.findOne({}, { projection: { _id: 1 } }, (error, doc) => {\n        if (error) {\n            return callback(error);\n        }\n        if (doc) {\n            return callback();\n        }\n        stream.files.listIndexes().toArray((error, indexes) => {\n            let index;\n            if (error) {\n                // Collection doesn't exist so create index\n                if (error instanceof error_1.MongoError && error.code === error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n                    index = { filename: 1, uploadDate: 1 };\n                    stream.files.createIndex(index, { background: false }, (error) => {\n                        if (error) {\n                            return callback(error);\n                        }\n                        checkChunksIndex(stream, callback);\n                    });\n                    return;\n                }\n                return callback(error);\n            }\n            let hasFileIndex = false;\n            if (indexes) {\n                indexes.forEach((index) => {\n                    const keys = Object.keys(index.key);\n                    if (keys.length === 2 && index.key.filename === 1 && index.key.uploadDate === 1) {\n                        hasFileIndex = true;\n                    }\n                });\n            }\n            if (hasFileIndex) {\n                checkChunksIndex(stream, callback);\n            }\n            else {\n                index = { filename: 1, uploadDate: 1 };\n                const writeConcernOptions = getWriteOptions(stream);\n                stream.files.createIndex(index, {\n                    ...writeConcernOptions,\n                    background: false\n                }, (error) => {\n                    if (error) {\n                        return callback(error);\n                    }\n                    checkChunksIndex(stream, callback);\n                });\n            }\n        });\n    });\n}\nfunction createFilesDoc(_id, length, chunkSize, filename, contentType, aliases, metadata) {\n    const ret = {\n        _id,\n        length,\n        chunkSize,\n        uploadDate: new Date(),\n        filename\n    };\n    if (contentType) {\n        ret.contentType = contentType;\n    }\n    if (aliases) {\n        ret.aliases = aliases;\n    }\n    if (metadata) {\n        ret.metadata = metadata;\n    }\n    return ret;\n}\nfunction doWrite(stream, chunk, encoding, callback) {\n    if (checkAborted(stream, callback)) {\n        return false;\n    }\n    const inputBuf = Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk, encoding);\n    stream.length += inputBuf.length;\n    // Input is small enough to fit in our buffer\n    if (stream.pos + inputBuf.length < stream.chunkSizeBytes) {\n        inputBuf.copy(stream.bufToStore, stream.pos);\n        stream.pos += inputBuf.length;\n        callback && callback();\n        // Note that we reverse the typical semantics of write's return value\n        // to be compatible with node's `.pipe()` function.\n        // True means client can keep writing.\n        return true;\n    }\n    // Otherwise, buffer is too big for current chunk, so we need to flush\n    // to MongoDB.\n    let inputBufRemaining = inputBuf.length;\n    let spaceRemaining = stream.chunkSizeBytes - stream.pos;\n    let numToCopy = Math.min(spaceRemaining, inputBuf.length);\n    let outstandingRequests = 0;\n    while (inputBufRemaining > 0) {\n        const inputBufPos = inputBuf.length - inputBufRemaining;\n        inputBuf.copy(stream.bufToStore, stream.pos, inputBufPos, inputBufPos + numToCopy);\n        stream.pos += numToCopy;\n        spaceRemaining -= numToCopy;\n        let doc;\n        if (spaceRemaining === 0) {\n            doc = createChunkDoc(stream.id, stream.n, Buffer.from(stream.bufToStore));\n            ++stream.state.outstandingRequests;\n            ++outstandingRequests;\n            if (checkAborted(stream, callback)) {\n                return false;\n            }\n            stream.chunks.insertOne(doc, getWriteOptions(stream), (error) => {\n                if (error) {\n                    return __handleError(stream, error);\n                }\n                --stream.state.outstandingRequests;\n                --outstandingRequests;\n                if (!outstandingRequests) {\n                    stream.emit('drain', doc);\n                    callback && callback();\n                    checkDone(stream);\n                }\n            });\n            spaceRemaining = stream.chunkSizeBytes;\n            stream.pos = 0;\n            ++stream.n;\n        }\n        inputBufRemaining -= numToCopy;\n        numToCopy = Math.min(spaceRemaining, inputBufRemaining);\n    }\n    // Note that we reverse the typical semantics of write's return value\n    // to be compatible with node's `.pipe()` function.\n    // False means the client should wait for the 'drain' event.\n    return false;\n}\nfunction getWriteOptions(stream) {\n    const obj = {};\n    if (stream.writeConcern) {\n        obj.writeConcern = {\n            w: stream.writeConcern.w,\n            wtimeout: stream.writeConcern.wtimeout,\n            j: stream.writeConcern.j\n        };\n    }\n    return obj;\n}\nfunction waitForIndexes(stream, callback) {\n    if (stream.bucket.s.checkedIndexes) {\n        return callback(false);\n    }\n    stream.bucket.once('index', () => {\n        callback(true);\n    });\n    return true;\n}\nfunction writeRemnant(stream, callback) {\n    // Buffer is empty, so don't bother to insert\n    if (stream.pos === 0) {\n        return checkDone(stream, callback);\n    }\n    ++stream.state.outstandingRequests;\n    // Create a new buffer to make sure the buffer isn't bigger than it needs\n    // to be.\n    const remnant = Buffer.alloc(stream.pos);\n    stream.bufToStore.copy(remnant, 0, 0, stream.pos);\n    const doc = createChunkDoc(stream.id, stream.n, remnant);\n    // If the stream was aborted, do not write remnant\n    if (checkAborted(stream, callback)) {\n        return false;\n    }\n    stream.chunks.insertOne(doc, getWriteOptions(stream), (error) => {\n        if (error) {\n            return __handleError(stream, error);\n        }\n        --stream.state.outstandingRequests;\n        checkDone(stream);\n    });\n    return true;\n}\nfunction checkAborted(stream, callback) {\n    if (stream.state.aborted) {\n        if (typeof callback === 'function') {\n            // TODO(NODE-3485): Replace with MongoGridFSStreamClosedError\n            callback(new error_1.MongoAPIError('Stream has been aborted'));\n        }\n        return true;\n    }\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}