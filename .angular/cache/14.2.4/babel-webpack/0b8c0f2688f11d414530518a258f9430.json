{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst error_1 = require(\"../error\");\n\nconst operation_1 = require(\"./operation\");\n\nconst utils_1 = require(\"../utils\");\n\nconst utils_2 = require(\"../utils\");\n\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\n\nfunction executeOperation(topology, operation, callback) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n\n  return utils_1.maybePromise(callback, cb => {\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, err => {\n        if (err) return cb(err);\n        executeOperation(topology, operation, cb);\n      });\n    } // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n\n\n    let session = operation.session;\n    let owner;\n\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = topology.startSession({\n          owner,\n          explicit: false\n        });\n      } else if (session.hasEnded) {\n        return cb(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return cb(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else if (session) {\n      // If the user passed an explicit session and we are still, after server selection,\n      // trying to run against a topology that doesn't support sessions we error out.\n      return cb(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    try {\n      executeWithServerSelection(topology, session, operation, (err, result) => {\n        if (session && session.owner && session.owner === owner) {\n          return session.endSession(err2 => cb(err2 || err, result));\n        }\n\n        cb(err, result);\n      });\n    } catch (e) {\n      if (session && session.owner && session.owner === owner) {\n        session.endSession();\n      }\n\n      throw e;\n    }\n  });\n}\n\nexports.executeOperation = executeOperation;\n\nfunction supportsRetryableReads(server) {\n  return utils_1.maxWireVersion(server) >= 6;\n}\n\nfunction executeWithServerSelection(topology, session, operation, callback) {\n  const readPreference = operation.readPreference || read_preference_1.ReadPreference.primary;\n  const inTransaction = session && session.inTransaction();\n\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  }\n\n  if (session && session.isPinned && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n\n  const serverSelectionOptions = {\n    session\n  };\n\n  function callbackWithRetry(err, result) {\n    if (err == null) {\n      return callback(undefined, result);\n    }\n\n    const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    const itShouldRetryWrite = shouldRetryWrite(err);\n\n    if (hasReadAspect && !error_1.isRetryableError(err) || hasWriteAspect && !itShouldRetryWrite) {\n      return callback(err);\n    }\n\n    if (hasWriteAspect && itShouldRetryWrite && err.code === MMAPv1_RETRY_WRITES_ERROR_CODE && err.errmsg.match(/Transaction numbers/)) {\n      callback(new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError: err\n      }));\n      return;\n    } // select a new server, and attempt to retry the operation\n\n\n    topology.selectServer(readPreference, serverSelectionOptions, (e, server) => {\n      if (e || operation.hasAspect(operation_1.Aspect.READ_OPERATION) && !supportsRetryableReads(server) || operation.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !utils_2.supportsRetryableWrites(server)) {\n        callback(e);\n        return;\n      } // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n\n\n      if (err && err instanceof error_1.MongoNetworkError && server.loadBalanced && session && session.isPinned && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n        session.unpin({\n          force: true,\n          forceClear: true\n        });\n      }\n\n      operation.execute(server, session, callback);\n    });\n  }\n\n  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && session && session.inTransaction()) {\n    callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n    return;\n  } // select a server, and execute the operation against it\n\n\n  topology.selectServer(readPreference, serverSelectionOptions, (err, server) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      const willRetryRead = topology.s.options.retryReads !== false && !inTransaction && supportsRetryableReads(server) && operation.canRetryRead;\n      const willRetryWrite = topology.s.options.retryWrites === true && !inTransaction && utils_2.supportsRetryableWrites(server) && operation.canRetryWrite;\n      const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n      const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n\n      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n\n        operation.execute(server, session, callbackWithRetry);\n        return;\n      }\n    }\n\n    operation.execute(server, session, callback);\n  });\n}\n\nfunction shouldRetryWrite(err) {\n  return err instanceof error_1.MongoError && err.hasErrorLabel('RetryableWriteError');\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","executeOperation","read_preference_1","require","error_1","operation_1","utils_1","utils_2","MMAPv1_RETRY_WRITES_ERROR_CODE","MONGODB_ERROR_CODES","IllegalOperation","MMAPv1_RETRY_WRITES_ERROR_MESSAGE","topology","operation","callback","AbstractOperation","MongoRuntimeError","maybePromise","cb","shouldCheckForSessionSupport","selectServer","ReadPreference","primaryPreferred","err","session","owner","hasSessionSupport","Symbol","startSession","explicit","hasEnded","MongoExpiredSessionError","snapshotEnabled","capabilities","supportsSnapshotReads","MongoCompatibilityError","executeWithServerSelection","result","endSession","err2","e","supportsRetryableReads","server","maxWireVersion","readPreference","primary","inTransaction","equals","MongoTransactionError","mode","isPinned","transaction","isCommitted","bypassPinningCheck","unpin","serverSelectionOptions","callbackWithRetry","undefined","hasReadAspect","hasAspect","Aspect","READ_OPERATION","hasWriteAspect","WRITE_OPERATION","itShouldRetryWrite","shouldRetryWrite","isRetryableError","code","errmsg","match","MongoServerError","message","originalError","supportsRetryableWrites","MongoNetworkError","loadBalanced","CURSOR_CREATING","force","forceClear","execute","RETRYABLE","willRetryRead","s","options","retryReads","canRetryRead","willRetryWrite","retryWrites","canRetryWrite","incrementTransactionNumber","MongoError","hasErrorLabel"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/operations/execute_operation.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.executeOperation = void 0;\nconst read_preference_1 = require(\"../read_preference\");\nconst error_1 = require(\"../error\");\nconst operation_1 = require(\"./operation\");\nconst utils_1 = require(\"../utils\");\nconst utils_2 = require(\"../utils\");\nconst MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nconst MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(topology, operation, callback) {\n    if (!(operation instanceof operation_1.AbstractOperation)) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n    }\n    return utils_1.maybePromise(callback, cb => {\n        if (topology.shouldCheckForSessionSupport()) {\n            return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, err => {\n                if (err)\n                    return cb(err);\n                executeOperation(topology, operation, cb);\n            });\n        }\n        // The driver sessions spec mandates that we implicitly create sessions for operations\n        // that are not explicitly provided with a session.\n        let session = operation.session;\n        let owner;\n        if (topology.hasSessionSupport()) {\n            if (session == null) {\n                owner = Symbol();\n                session = topology.startSession({ owner, explicit: false });\n            }\n            else if (session.hasEnded) {\n                return cb(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n            }\n            else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n                return cb(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n            }\n        }\n        else if (session) {\n            // If the user passed an explicit session and we are still, after server selection,\n            // trying to run against a topology that doesn't support sessions we error out.\n            return cb(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n        }\n        try {\n            executeWithServerSelection(topology, session, operation, (err, result) => {\n                if (session && session.owner && session.owner === owner) {\n                    return session.endSession(err2 => cb(err2 || err, result));\n                }\n                cb(err, result);\n            });\n        }\n        catch (e) {\n            if (session && session.owner && session.owner === owner) {\n                session.endSession();\n            }\n            throw e;\n        }\n    });\n}\nexports.executeOperation = executeOperation;\nfunction supportsRetryableReads(server) {\n    return utils_1.maxWireVersion(server) >= 6;\n}\nfunction executeWithServerSelection(topology, session, operation, callback) {\n    const readPreference = operation.readPreference || read_preference_1.ReadPreference.primary;\n    const inTransaction = session && session.inTransaction();\n    if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n        callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n        return;\n    }\n    if (session &&\n        session.isPinned &&\n        session.transaction.isCommitted &&\n        !operation.bypassPinningCheck) {\n        session.unpin();\n    }\n    const serverSelectionOptions = { session };\n    function callbackWithRetry(err, result) {\n        if (err == null) {\n            return callback(undefined, result);\n        }\n        const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n        const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n        const itShouldRetryWrite = shouldRetryWrite(err);\n        if ((hasReadAspect && !error_1.isRetryableError(err)) || (hasWriteAspect && !itShouldRetryWrite)) {\n            return callback(err);\n        }\n        if (hasWriteAspect &&\n            itShouldRetryWrite &&\n            err.code === MMAPv1_RETRY_WRITES_ERROR_CODE &&\n            err.errmsg.match(/Transaction numbers/)) {\n            callback(new error_1.MongoServerError({\n                message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n                errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n                originalError: err\n            }));\n            return;\n        }\n        // select a new server, and attempt to retry the operation\n        topology.selectServer(readPreference, serverSelectionOptions, (e, server) => {\n            if (e ||\n                (operation.hasAspect(operation_1.Aspect.READ_OPERATION) && !supportsRetryableReads(server)) ||\n                (operation.hasAspect(operation_1.Aspect.WRITE_OPERATION) && !utils_2.supportsRetryableWrites(server))) {\n                callback(e);\n                return;\n            }\n            // If we have a cursor and the initial command fails with a network error,\n            // we can retry it on another connection. So we need to check it back in, clear the\n            // pool for the service id, and retry again.\n            if (err &&\n                err instanceof error_1.MongoNetworkError &&\n                server.loadBalanced &&\n                session &&\n                session.isPinned &&\n                !session.inTransaction() &&\n                operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n                session.unpin({ force: true, forceClear: true });\n            }\n            operation.execute(server, session, callback);\n        });\n    }\n    if (readPreference &&\n        !readPreference.equals(read_preference_1.ReadPreference.primary) &&\n        session &&\n        session.inTransaction()) {\n        callback(new error_1.MongoTransactionError(`Read preference in a transaction must be primary, not: ${readPreference.mode}`));\n        return;\n    }\n    // select a server, and execute the operation against it\n    topology.selectServer(readPreference, serverSelectionOptions, (err, server) => {\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n            const willRetryRead = topology.s.options.retryReads !== false &&\n                !inTransaction &&\n                supportsRetryableReads(server) &&\n                operation.canRetryRead;\n            const willRetryWrite = topology.s.options.retryWrites === true &&\n                !inTransaction &&\n                utils_2.supportsRetryableWrites(server) &&\n                operation.canRetryWrite;\n            const hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n            const hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n            if ((hasReadAspect && willRetryRead) || (hasWriteAspect && willRetryWrite)) {\n                if (hasWriteAspect && willRetryWrite) {\n                    operation.options.willRetryWrite = true;\n                    session.incrementTransactionNumber();\n                }\n                operation.execute(server, session, callbackWithRetry);\n                return;\n            }\n        }\n        operation.execute(server, session, callback);\n    });\n}\nfunction shouldRetryWrite(err) {\n    return err instanceof error_1.MongoError && err.hasErrorLabel('RetryableWriteError');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}