{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;\n\nconst commands_1 = require(\"./commands\");\n\nconst utils_1 = require(\"../utils\");\n/**\n * An event indicating the start of a given\n * @public\n * @category Event\n */\n\n\nclass CommandStartedEvent {\n  /**\n   * Create a started event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   */\n  constructor(connection, command) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection); // TODO: remove in major revision, this is not spec behavior\n\n    if (SENSITIVE_COMMANDS.has(commandName)) {\n      this.commandObj = {};\n      this.commandObj[commandName] = true;\n    }\n\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.databaseName = databaseName(command);\n    this.commandName = commandName;\n    this.command = maybeRedact(commandName, cmd, cmd);\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandStartedEvent = CommandStartedEvent;\n/**\n * An event indicating the success of a given command\n * @public\n * @category Event\n */\n\nclass CommandSucceededEvent {\n  /**\n   * Create a succeeded event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   * @param reply - the reply for this command from the server\n   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(connection, command, reply, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection);\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.commandName = commandName;\n    this.duration = utils_1.calculateDurationInMs(started);\n    this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandSucceededEvent = CommandSucceededEvent;\n/**\n * An event indicating the failure of a given command\n * @public\n * @category Event\n */\n\nclass CommandFailedEvent {\n  /**\n   * Create a failure event\n   *\n   * @internal\n   * @param pool - the pool that originated the command\n   * @param command - the command\n   * @param error - the generated error or a server error response\n   * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n   */\n  constructor(connection, command, error, started) {\n    const cmd = extractCommand(command);\n    const commandName = extractCommandName(cmd);\n    const {\n      address,\n      connectionId,\n      serviceId\n    } = extractConnectionDetails(connection);\n    this.address = address;\n    this.connectionId = connectionId;\n    this.serviceId = serviceId;\n    this.requestId = command.requestId;\n    this.commandName = commandName;\n    this.duration = utils_1.calculateDurationInMs(started);\n    this.failure = maybeRedact(commandName, cmd, error);\n  }\n  /* @internal */\n\n\n  get hasServiceId() {\n    return !!this.serviceId;\n  }\n\n}\n\nexports.CommandFailedEvent = CommandFailedEvent;\n/** Commands that we want to redact because of the sensitive nature of their contents */\n\nconst SENSITIVE_COMMANDS = new Set(['authenticate', 'saslStart', 'saslContinue', 'getnonce', 'createUser', 'updateUser', 'copydbgetnonce', 'copydbsaslstart', 'copydb']);\nconst HELLO_COMMANDS = new Set(['hello', 'ismaster', 'isMaster']); // helper methods\n\nconst extractCommandName = commandDoc => Object.keys(commandDoc)[0];\n\nconst namespace = command => command.ns;\n\nconst databaseName = command => command.ns.split('.')[0];\n\nconst collectionName = command => command.ns.split('.')[1];\n\nconst maybeRedact = (commandName, commandDoc, result) => SENSITIVE_COMMANDS.has(commandName) || HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate ? {} : result;\n\nconst LEGACY_FIND_QUERY_MAP = {\n  $query: 'filter',\n  $orderby: 'sort',\n  $hint: 'hint',\n  $comment: 'comment',\n  $maxScan: 'maxScan',\n  $max: 'max',\n  $min: 'min',\n  $returnKey: 'returnKey',\n  $showDiskLoc: 'showRecordId',\n  $maxTimeMS: 'maxTimeMS',\n  $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n  numberToSkip: 'skip',\n  numberToReturn: 'batchSize',\n  returnFieldSelector: 'projection'\n};\nconst OP_QUERY_KEYS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial', 'exhaust'];\n/** Extract the actual command from the query, possibly up-converting if it's a legacy format */\n\nfunction extractCommand(command) {\n  var _a;\n\n  if (command instanceof commands_1.GetMore) {\n    return {\n      getMore: utils_1.deepCopy(command.cursorId),\n      collection: collectionName(command),\n      batchSize: command.numberToReturn\n    };\n  }\n\n  if (command instanceof commands_1.KillCursor) {\n    return {\n      killCursors: collectionName(command),\n      cursors: utils_1.deepCopy(command.cursorIds)\n    };\n  }\n\n  if (command instanceof commands_1.Msg) {\n    return utils_1.deepCopy(command.command);\n  }\n\n  if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {\n    let result;\n\n    if (command.ns === 'admin.$cmd') {\n      // up-convert legacy command\n      result = Object.assign({}, command.query.$query);\n    } else {\n      // up-convert legacy find command\n      result = {\n        find: collectionName(command)\n      };\n      Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n        if (command.query[key] != null) {\n          result[LEGACY_FIND_QUERY_MAP[key]] = utils_1.deepCopy(command.query[key]);\n        }\n      });\n    }\n\n    Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n      const legacyKey = key;\n\n      if (command[legacyKey] != null) {\n        result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = utils_1.deepCopy(command[legacyKey]);\n      }\n    });\n    OP_QUERY_KEYS.forEach(key => {\n      const opKey = key;\n\n      if (command[opKey]) {\n        result[opKey] = command[opKey];\n      }\n    });\n\n    if (command.pre32Limit != null) {\n      result.limit = command.pre32Limit;\n    }\n\n    if (command.query.$explain) {\n      return {\n        explain: result\n      };\n    }\n\n    return result;\n  }\n\n  const clonedQuery = {};\n  const clonedCommand = {};\n\n  if (command.query) {\n    for (const k in command.query) {\n      clonedQuery[k] = utils_1.deepCopy(command.query[k]);\n    }\n\n    clonedCommand.query = clonedQuery;\n  }\n\n  for (const k in command) {\n    if (k === 'query') continue;\n    clonedCommand[k] = utils_1.deepCopy(command[k]);\n  }\n\n  return command.query ? clonedQuery : clonedCommand;\n}\n\nfunction extractReply(command, reply) {\n  if (command instanceof commands_1.KillCursor) {\n    return {\n      ok: 1,\n      cursorsUnknown: command.cursorIds\n    };\n  }\n\n  if (!reply) {\n    return reply;\n  }\n\n  if (command instanceof commands_1.GetMore) {\n    return {\n      ok: 1,\n      cursor: {\n        id: utils_1.deepCopy(reply.cursorId),\n        ns: namespace(command),\n        nextBatch: utils_1.deepCopy(reply.documents)\n      }\n    };\n  }\n\n  if (command instanceof commands_1.Msg) {\n    return utils_1.deepCopy(reply.result ? reply.result : reply);\n  } // is this a legacy find command?\n\n\n  if (command.query && command.query.$query != null) {\n    return {\n      ok: 1,\n      cursor: {\n        id: utils_1.deepCopy(reply.cursorId),\n        ns: namespace(command),\n        firstBatch: utils_1.deepCopy(reply.documents)\n      }\n    };\n  }\n\n  return utils_1.deepCopy(reply.result ? reply.result : reply);\n}\n\nfunction extractConnectionDetails(connection) {\n  let connectionId;\n\n  if ('id' in connection) {\n    connectionId = connection.id;\n  }\n\n  return {\n    address: connection.address,\n    serviceId: connection.serviceId,\n    connectionId\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","CommandFailedEvent","CommandSucceededEvent","CommandStartedEvent","commands_1","require","utils_1","constructor","connection","command","cmd","extractCommand","commandName","extractCommandName","address","connectionId","serviceId","extractConnectionDetails","SENSITIVE_COMMANDS","has","commandObj","requestId","databaseName","maybeRedact","hasServiceId","reply","started","duration","calculateDurationInMs","extractReply","error","failure","Set","HELLO_COMMANDS","commandDoc","keys","namespace","ns","split","collectionName","result","speculativeAuthenticate","LEGACY_FIND_QUERY_MAP","$query","$orderby","$hint","$comment","$maxScan","$max","$min","$returnKey","$showDiskLoc","$maxTimeMS","$snapshot","LEGACY_FIND_OPTIONS_MAP","numberToSkip","numberToReturn","returnFieldSelector","OP_QUERY_KEYS","_a","GetMore","getMore","deepCopy","cursorId","collection","batchSize","KillCursor","killCursors","cursors","cursorIds","Msg","query","assign","find","forEach","key","legacyKey","opKey","pre32Limit","limit","$explain","explain","clonedQuery","clonedCommand","k","ok","cursorsUnknown","cursor","id","nextBatch","documents","firstBatch"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/cmap/command_monitoring_events.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommandFailedEvent = exports.CommandSucceededEvent = exports.CommandStartedEvent = void 0;\nconst commands_1 = require(\"./commands\");\nconst utils_1 = require(\"../utils\");\n/**\n * An event indicating the start of a given\n * @public\n * @category Event\n */\nclass CommandStartedEvent {\n    /**\n     * Create a started event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     */\n    constructor(connection, command) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        // TODO: remove in major revision, this is not spec behavior\n        if (SENSITIVE_COMMANDS.has(commandName)) {\n            this.commandObj = {};\n            this.commandObj[commandName] = true;\n        }\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.databaseName = databaseName(command);\n        this.commandName = commandName;\n        this.command = maybeRedact(commandName, cmd, cmd);\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandStartedEvent = CommandStartedEvent;\n/**\n * An event indicating the success of a given command\n * @public\n * @category Event\n */\nclass CommandSucceededEvent {\n    /**\n     * Create a succeeded event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     * @param reply - the reply for this command from the server\n     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n     */\n    constructor(connection, command, reply, started) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.commandName = commandName;\n        this.duration = utils_1.calculateDurationInMs(started);\n        this.reply = maybeRedact(commandName, cmd, extractReply(command, reply));\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandSucceededEvent = CommandSucceededEvent;\n/**\n * An event indicating the failure of a given command\n * @public\n * @category Event\n */\nclass CommandFailedEvent {\n    /**\n     * Create a failure event\n     *\n     * @internal\n     * @param pool - the pool that originated the command\n     * @param command - the command\n     * @param error - the generated error or a server error response\n     * @param started - a high resolution tuple timestamp of when the command was first sent, to calculate duration\n     */\n    constructor(connection, command, error, started) {\n        const cmd = extractCommand(command);\n        const commandName = extractCommandName(cmd);\n        const { address, connectionId, serviceId } = extractConnectionDetails(connection);\n        this.address = address;\n        this.connectionId = connectionId;\n        this.serviceId = serviceId;\n        this.requestId = command.requestId;\n        this.commandName = commandName;\n        this.duration = utils_1.calculateDurationInMs(started);\n        this.failure = maybeRedact(commandName, cmd, error);\n    }\n    /* @internal */\n    get hasServiceId() {\n        return !!this.serviceId;\n    }\n}\nexports.CommandFailedEvent = CommandFailedEvent;\n/** Commands that we want to redact because of the sensitive nature of their contents */\nconst SENSITIVE_COMMANDS = new Set([\n    'authenticate',\n    'saslStart',\n    'saslContinue',\n    'getnonce',\n    'createUser',\n    'updateUser',\n    'copydbgetnonce',\n    'copydbsaslstart',\n    'copydb'\n]);\nconst HELLO_COMMANDS = new Set(['hello', 'ismaster', 'isMaster']);\n// helper methods\nconst extractCommandName = (commandDoc) => Object.keys(commandDoc)[0];\nconst namespace = (command) => command.ns;\nconst databaseName = (command) => command.ns.split('.')[0];\nconst collectionName = (command) => command.ns.split('.')[1];\nconst maybeRedact = (commandName, commandDoc, result) => SENSITIVE_COMMANDS.has(commandName) ||\n    (HELLO_COMMANDS.has(commandName) && commandDoc.speculativeAuthenticate)\n    ? {}\n    : result;\nconst LEGACY_FIND_QUERY_MAP = {\n    $query: 'filter',\n    $orderby: 'sort',\n    $hint: 'hint',\n    $comment: 'comment',\n    $maxScan: 'maxScan',\n    $max: 'max',\n    $min: 'min',\n    $returnKey: 'returnKey',\n    $showDiskLoc: 'showRecordId',\n    $maxTimeMS: 'maxTimeMS',\n    $snapshot: 'snapshot'\n};\nconst LEGACY_FIND_OPTIONS_MAP = {\n    numberToSkip: 'skip',\n    numberToReturn: 'batchSize',\n    returnFieldSelector: 'projection'\n};\nconst OP_QUERY_KEYS = [\n    'tailable',\n    'oplogReplay',\n    'noCursorTimeout',\n    'awaitData',\n    'partial',\n    'exhaust'\n];\n/** Extract the actual command from the query, possibly up-converting if it's a legacy format */\nfunction extractCommand(command) {\n    var _a;\n    if (command instanceof commands_1.GetMore) {\n        return {\n            getMore: utils_1.deepCopy(command.cursorId),\n            collection: collectionName(command),\n            batchSize: command.numberToReturn\n        };\n    }\n    if (command instanceof commands_1.KillCursor) {\n        return {\n            killCursors: collectionName(command),\n            cursors: utils_1.deepCopy(command.cursorIds)\n        };\n    }\n    if (command instanceof commands_1.Msg) {\n        return utils_1.deepCopy(command.command);\n    }\n    if ((_a = command.query) === null || _a === void 0 ? void 0 : _a.$query) {\n        let result;\n        if (command.ns === 'admin.$cmd') {\n            // up-convert legacy command\n            result = Object.assign({}, command.query.$query);\n        }\n        else {\n            // up-convert legacy find command\n            result = { find: collectionName(command) };\n            Object.keys(LEGACY_FIND_QUERY_MAP).forEach(key => {\n                if (command.query[key] != null) {\n                    result[LEGACY_FIND_QUERY_MAP[key]] = utils_1.deepCopy(command.query[key]);\n                }\n            });\n        }\n        Object.keys(LEGACY_FIND_OPTIONS_MAP).forEach(key => {\n            const legacyKey = key;\n            if (command[legacyKey] != null) {\n                result[LEGACY_FIND_OPTIONS_MAP[legacyKey]] = utils_1.deepCopy(command[legacyKey]);\n            }\n        });\n        OP_QUERY_KEYS.forEach(key => {\n            const opKey = key;\n            if (command[opKey]) {\n                result[opKey] = command[opKey];\n            }\n        });\n        if (command.pre32Limit != null) {\n            result.limit = command.pre32Limit;\n        }\n        if (command.query.$explain) {\n            return { explain: result };\n        }\n        return result;\n    }\n    const clonedQuery = {};\n    const clonedCommand = {};\n    if (command.query) {\n        for (const k in command.query) {\n            clonedQuery[k] = utils_1.deepCopy(command.query[k]);\n        }\n        clonedCommand.query = clonedQuery;\n    }\n    for (const k in command) {\n        if (k === 'query')\n            continue;\n        clonedCommand[k] = utils_1.deepCopy(command[k]);\n    }\n    return command.query ? clonedQuery : clonedCommand;\n}\nfunction extractReply(command, reply) {\n    if (command instanceof commands_1.KillCursor) {\n        return {\n            ok: 1,\n            cursorsUnknown: command.cursorIds\n        };\n    }\n    if (!reply) {\n        return reply;\n    }\n    if (command instanceof commands_1.GetMore) {\n        return {\n            ok: 1,\n            cursor: {\n                id: utils_1.deepCopy(reply.cursorId),\n                ns: namespace(command),\n                nextBatch: utils_1.deepCopy(reply.documents)\n            }\n        };\n    }\n    if (command instanceof commands_1.Msg) {\n        return utils_1.deepCopy(reply.result ? reply.result : reply);\n    }\n    // is this a legacy find command?\n    if (command.query && command.query.$query != null) {\n        return {\n            ok: 1,\n            cursor: {\n                id: utils_1.deepCopy(reply.cursorId),\n                ns: namespace(command),\n                firstBatch: utils_1.deepCopy(reply.documents)\n            }\n        };\n    }\n    return utils_1.deepCopy(reply.result ? reply.result : reply);\n}\nfunction extractConnectionDetails(connection) {\n    let connectionId;\n    if ('id' in connection) {\n        connectionId = connection.id;\n    }\n    return {\n        address: connection.address,\n        serviceId: connection.serviceId,\n        connectionId\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}