{"ast":null,"code":"\"use strict\";\n\nvar _a;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateSessionFromResponse = exports.applySession = exports.commandSupportsReadConcern = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst bson_1 = require(\"./bson\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst transactions_1 = require(\"./transactions\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\n\nconst error_1 = require(\"./error\");\n\nconst utils_1 = require(\"./utils\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst run_command_1 = require(\"./operations/run_command\");\n\nconst connection_1 = require(\"./cmap/connection\");\n\nconst metrics_1 = require(\"./cmap/metrics\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst minWireVersionForShardedTransactions = 8;\n\nfunction assertAlive(session, callback) {\n  if (session.serverSession == null) {\n    const error = new error_1.MongoExpiredSessionError();\n\n    if (typeof callback === 'function') {\n      callback(error);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n/** @internal */\n\n\nconst kServerSession = Symbol('serverSession');\n/** @internal */\n\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\n\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\n\nconst kPinnedConnection = Symbol('pinnedConnection');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\n\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n  /**\n   * Create a client session.\n   * @internal\n   * @param topology - The current client's topology (Internal Class)\n   * @param sessionPool - The server session pool (Internal Class)\n   * @param options - Optional settings\n   * @param clientOptions - Optional settings provided when creating a MongoClient\n   */\n  constructor(topology, sessionPool, options, clientOptions) {\n    super();\n    /** @internal */\n\n    this[_a] = false;\n\n    if (topology == null) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a topology');\n    }\n\n    if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n      // TODO(NODE-3483)\n      throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n    }\n\n    options = options !== null && options !== void 0 ? options : {};\n\n    if (options.snapshot === true) {\n      this[kSnapshotEnabled] = true;\n\n      if (options.causalConsistency === true) {\n        throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n      }\n    }\n\n    this.topology = topology;\n    this.sessionPool = sessionPool;\n    this.hasEnded = false;\n    this.clientOptions = clientOptions;\n    this[kServerSession] = undefined;\n    this.supports = {\n      causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n    };\n    this.clusterTime = options.initialClusterTime;\n    this.operationTime = undefined;\n    this.explicit = !!options.explicit;\n    this.owner = options.owner;\n    this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n    this.transaction = new transactions_1.Transaction();\n  }\n  /** The server id associated with this session */\n\n\n  get id() {\n    var _b;\n\n    return (_b = this.serverSession) === null || _b === void 0 ? void 0 : _b.id;\n  }\n\n  get serverSession() {\n    if (this[kServerSession] == null) {\n      this[kServerSession] = this.sessionPool.acquire();\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    return this[kServerSession];\n  }\n  /** Whether or not this session is configured for snapshot reads */\n\n\n  get snapshotEnabled() {\n    return this[kSnapshotEnabled];\n  }\n\n  get loadBalanced() {\n    return this.topology.description.type === common_1.TopologyType.LoadBalanced;\n  }\n  /** @internal */\n\n\n  get pinnedConnection() {\n    return this[kPinnedConnection];\n  }\n  /** @internal */\n\n\n  pin(conn) {\n    if (this[kPinnedConnection]) {\n      throw TypeError('Cannot pin multiple connections to the same session');\n    }\n\n    this[kPinnedConnection] = conn;\n    conn.emit(connection_1.Connection.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n  }\n  /** @internal */\n\n\n  unpin(options) {\n    if (this.loadBalanced) {\n      return maybeClearPinnedConnection(this, options);\n    }\n\n    this.transaction.unpinServer();\n  }\n\n  get isPinned() {\n    return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n  }\n\n  endSession(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    const finalOptions = {\n      force: true,\n      ...options\n    };\n    return utils_1.maybePromise(callback, done => {\n      if (this.hasEnded) {\n        maybeClearPinnedConnection(this, finalOptions);\n        return done();\n      }\n\n      const completeEndSession = () => {\n        maybeClearPinnedConnection(this, finalOptions); // release the server session back to the pool\n\n        this.sessionPool.release(this.serverSession);\n        this[kServerSession] = undefined; // mark the session as ended, and emit a signal\n\n        this.hasEnded = true;\n        this.emit('ended', this); // spec indicates that we should ignore all errors for `endSessions`\n\n        done();\n      };\n\n      if (this.serverSession && this.inTransaction()) {\n        this.abortTransaction(err => {\n          if (err) return done(err);\n          completeEndSession();\n        });\n        return;\n      }\n\n      completeEndSession();\n    });\n  }\n  /**\n   * Advances the operationTime for a ClientSession.\n   *\n   * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n   */\n\n\n  advanceOperationTime(operationTime) {\n    if (this.operationTime == null) {\n      this.operationTime = operationTime;\n      return;\n    }\n\n    if (operationTime.greaterThan(this.operationTime)) {\n      this.operationTime = operationTime;\n    }\n  }\n  /**\n   * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n   *\n   * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n   */\n\n\n  advanceClusterTime(clusterTime) {\n    var _b, _c;\n\n    if (!clusterTime || typeof clusterTime !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n    }\n\n    if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n      throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n    }\n\n    if (!clusterTime.signature || ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' || typeof clusterTime.signature.keyId !== 'number' && ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long' // apparently we decode the key to number?\n    ) {\n      throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n    }\n\n    common_1._advanceClusterTime(this, clusterTime);\n  }\n  /**\n   * Used to determine if this session equals another\n   *\n   * @param session - The session to compare to\n   */\n\n\n  equals(session) {\n    if (!(session instanceof ClientSession)) {\n      return false;\n    }\n\n    if (this.id == null || session.id == null) {\n      return false;\n    }\n\n    return this.id.id.buffer.equals(session.id.id.buffer);\n  }\n  /** Increment the transaction number on the internal ServerSession */\n\n\n  incrementTransactionNumber() {\n    if (this.serverSession) {\n      this.serverSession.txnNumber = typeof this.serverSession.txnNumber === 'number' ? this.serverSession.txnNumber + 1 : 0;\n    }\n  }\n  /** @returns whether this session is currently in a transaction or not */\n\n\n  inTransaction() {\n    return this.transaction.isActive;\n  }\n  /**\n   * Starts a new transaction with the given options.\n   *\n   * @param options - Options for the transaction\n   */\n\n\n  startTransaction(options) {\n    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n\n    if (this[kSnapshotEnabled]) {\n      throw new error_1.MongoCompatibilityError('Transactions are not allowed with snapshot sessions');\n    }\n\n    assertAlive(this);\n\n    if (this.inTransaction()) {\n      throw new error_1.MongoTransactionError('Transaction already in progress');\n    }\n\n    if (this.isPinned && this.transaction.isCommitted) {\n      this.unpin();\n    }\n\n    const topologyMaxWireVersion = utils_1.maxWireVersion(this.topology);\n\n    if (shared_1.isSharded(this.topology) && topologyMaxWireVersion != null && topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n      throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n    } // increment txnNumber\n\n\n    this.incrementTransactionNumber(); // create transaction state\n\n    this.transaction = new transactions_1.Transaction({\n      readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n      writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n      readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n      maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n    });\n    this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n  }\n\n  commitTransaction(callback) {\n    return utils_1.maybePromise(callback, cb => endTransaction(this, 'commitTransaction', cb));\n  }\n\n  abortTransaction(callback) {\n    return utils_1.maybePromise(callback, cb => endTransaction(this, 'abortTransaction', cb));\n  }\n  /**\n   * This is here to ensure that ClientSession is never serialized to BSON.\n   */\n\n\n  toBSON() {\n    throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n  }\n  /**\n   * Runs a provided lambda within a transaction, retrying either the commit operation\n   * or entire transaction as needed (and when the error permits) to better ensure that\n   * the transaction can complete successfully.\n   *\n   * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n   * return a Promise will result in undefined behavior.\n   *\n   * @param fn - A lambda to run within a transaction\n   * @param options - Optional settings for the transaction\n   */\n\n\n  withTransaction(fn, options) {\n    const startTime = utils_1.now();\n    return attemptTransaction(this, startTime, fn, options);\n  }\n\n}\n\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set(['CannotSatisfyWriteConcern', 'UnknownReplWriteConcern', 'UnsatisfiableWriteConcern']);\n\nfunction hasNotTimedOut(startTime, max) {\n  return utils_1.calculateDurationInMs(startTime) < max;\n}\n\nfunction isUnknownTransactionCommitResult(err) {\n  const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError && err.codeName && NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n  return isMaxTimeMSExpiredError(err) || !isNonDeterministicWriteConcernError && err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern && err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern;\n}\n\nfunction maybeClearPinnedConnection(session, options) {\n  // unpin a connection if it has been pinned\n  const conn = session[kPinnedConnection];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n\n  if (session.inTransaction() && error && error instanceof error_1.MongoError && error.hasErrorLabel('TransientTransactionError')) {\n    return;\n  } // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n  //       to validate that we don't unpin on _all_ errors?\n\n\n  if (conn) {\n    const servers = Array.from(session.topology.s.servers.values());\n    const loadBalancer = servers[0];\n\n    if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {\n      loadBalancer.s.pool.checkIn(conn);\n      conn.emit(connection_1.Connection.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n\n      if (options === null || options === void 0 ? void 0 : options.forceClear) {\n        loadBalancer.s.pool.clear(conn.serviceId);\n      }\n    }\n\n    session[kPinnedConnection] = undefined;\n  }\n}\n\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\n\nfunction isMaxTimeMSExpiredError(err) {\n  if (err == null || !(err instanceof error_1.MongoServerError)) {\n    return false;\n  }\n\n  return err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired || err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired;\n}\n\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n  return session.commitTransaction().catch(err => {\n    if (err instanceof error_1.MongoError && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) && !isMaxTimeMSExpiredError(err)) {\n      if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n        return attemptTransactionCommit(session, startTime, fn, options);\n      }\n\n      if (err.hasErrorLabel('TransientTransactionError')) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n    }\n\n    throw err;\n  });\n}\n\nconst USER_EXPLICIT_TXN_END_STATES = new Set([transactions_1.TxnState.NO_TRANSACTION, transactions_1.TxnState.TRANSACTION_COMMITTED, transactions_1.TxnState.TRANSACTION_ABORTED]);\n\nfunction userExplicitlyEndedTransaction(session) {\n  return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\n\nfunction attemptTransaction(session, startTime, fn, options) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  session.startTransaction(options);\n  let promise;\n\n  try {\n    promise = fn(session);\n  } catch (err) {\n    promise = Promise.reject(err);\n  }\n\n  if (!utils_1.isPromiseLike(promise)) {\n    session.abortTransaction();\n    throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n  }\n\n  return promise.then(() => {\n    if (userExplicitlyEndedTransaction(session)) {\n      return;\n    }\n\n    return attemptTransactionCommit(session, startTime, fn, options);\n  }, err => {\n    function maybeRetryOrThrow(err) {\n      if (err instanceof error_1.MongoError && err.hasErrorLabel('TransientTransactionError') && hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n        return attemptTransaction(session, startTime, fn, options);\n      }\n\n      if (isMaxTimeMSExpiredError(err)) {\n        err.addErrorLabel('UnknownTransactionCommitResult');\n      }\n\n      throw err;\n    }\n\n    if (session.transaction.isActive) {\n      return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n    }\n\n    return maybeRetryOrThrow(err);\n  });\n}\n\nfunction endTransaction(session, commandName, callback) {\n  if (!assertAlive(session, callback)) {\n    // checking result in case callback was called\n    return;\n  } // handle any initial problematic cases\n\n\n  const txnState = session.transaction.state;\n\n  if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n    callback(new error_1.MongoTransactionError('No transaction started'));\n    return;\n  }\n\n  if (commandName === 'commitTransaction') {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n      return;\n    }\n  } else {\n    if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n      // the transaction was never started, we can safely exit here\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n      callback();\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n      return;\n    }\n\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED || txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n      callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n      return;\n    }\n  } // construct and send the command\n\n\n  const command = {\n    [commandName]: 1\n  }; // apply a writeConcern if specified\n\n  let writeConcern;\n\n  if (session.transaction.options.writeConcern) {\n    writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n  } else if (session.clientOptions && session.clientOptions.writeConcern) {\n    writeConcern = {\n      w: session.clientOptions.writeConcern.w\n    };\n  }\n\n  if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n    writeConcern = Object.assign({\n      wtimeout: 10000\n    }, writeConcern, {\n      w: 'majority'\n    });\n  }\n\n  if (writeConcern) {\n    Object.assign(command, {\n      writeConcern\n    });\n  }\n\n  if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n    Object.assign(command, {\n      maxTimeMS: session.transaction.options.maxTimeMS\n    });\n  }\n\n  function commandHandler(e, r) {\n    if (commandName !== 'commitTransaction') {\n      session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n\n      if (session.loadBalanced) {\n        maybeClearPinnedConnection(session, {\n          force: false\n        });\n      } // The spec indicates that we should ignore all errors on `abortTransaction`\n\n\n      return callback();\n    }\n\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n\n    if (e) {\n      if (e instanceof error_1.MongoNetworkError || e instanceof error_1.MongoWriteConcernError || error_1.isRetryableError(e) || isMaxTimeMSExpiredError(e)) {\n        if (isUnknownTransactionCommitResult(e)) {\n          e.addErrorLabel('UnknownTransactionCommitResult'); // per txns spec, must unpin session in this case\n\n          session.unpin({\n            error: e\n          });\n        }\n      } else if (e.hasErrorLabel('TransientTransactionError')) {\n        session.unpin({\n          error: e\n        });\n      }\n    }\n\n    callback(e, r);\n  } // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n\n\n  if (session.transaction.recoveryToken) {\n    command.recoveryToken = session.transaction.recoveryToken;\n  } // send the command\n\n\n  execute_operation_1.executeOperation(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n    session,\n    readPreference: read_preference_1.ReadPreference.primary,\n    bypassPinningCheck: true\n  }), (err, reply) => {\n    if (command.abortTransaction) {\n      // always unpin on abort regardless of command outcome\n      session.unpin();\n    }\n\n    if (err && error_1.isRetryableError(err)) {\n      // SPEC-1185: apply majority write concern when retrying commitTransaction\n      if (command.commitTransaction) {\n        // per txns spec, must unpin session in this case\n        session.unpin({\n          force: true\n        });\n        command.writeConcern = Object.assign({\n          wtimeout: 10000\n        }, command.writeConcern, {\n          w: 'majority'\n        });\n      }\n\n      return execute_operation_1.executeOperation(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n      }), (_err, _reply) => commandHandler(_err, _reply));\n    }\n\n    commandHandler(err, reply);\n  });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\n\n\nclass ServerSession {\n  /** @internal */\n  constructor() {\n    this.id = {\n      id: new bson_1.Binary(utils_1.uuidV4(), bson_1.Binary.SUBTYPE_UUID)\n    };\n    this.lastUse = utils_1.now();\n    this.txnNumber = 0;\n    this.isDirty = false;\n  }\n  /**\n   * Determines if the server session has timed out.\n   *\n   * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n   */\n\n\n  hasTimedOut(sessionTimeoutMinutes) {\n    // Take the difference of the lastUse timestamp and now, which will result in a value in\n    // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n    const idleTimeMinutes = Math.round(utils_1.calculateDurationInMs(this.lastUse) % 86400000 % 3600000 / 60000);\n    return idleTimeMinutes > sessionTimeoutMinutes - 1;\n  }\n\n}\n\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\n\nclass ServerSessionPool {\n  constructor(topology) {\n    if (topology == null) {\n      throw new error_1.MongoRuntimeError('ServerSessionPool requires a topology');\n    }\n\n    this.topology = topology;\n    this.sessions = [];\n  }\n  /** Ends all sessions in the session pool */\n\n\n  endAllPooledSessions(callback) {\n    if (this.sessions.length) {\n      this.topology.endSessions(this.sessions.map(session => session.id), () => {\n        this.sessions = [];\n\n        if (typeof callback === 'function') {\n          callback();\n        }\n      });\n      return;\n    }\n\n    if (typeof callback === 'function') {\n      callback();\n    }\n  }\n  /**\n   * Acquire a Server Session from the pool.\n   * Iterates through each session in the pool, removing any stale sessions\n   * along the way. The first non-stale session found is removed from the\n   * pool and returned. If no non-stale session is found, a new ServerSession is created.\n   */\n\n\n  acquire() {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes || 10;\n\n    while (this.sessions.length) {\n      const session = this.sessions.shift();\n\n      if (session && (this.topology.loadBalanced || !session.hasTimedOut(sessionTimeoutMinutes))) {\n        return session;\n      }\n    }\n\n    return new ServerSession();\n  }\n  /**\n   * Release a session to the session pool\n   * Adds the session back to the session pool if the session has not timed out yet.\n   * This method also removes any stale sessions from the pool.\n   *\n   * @param session - The session to release to the pool\n   */\n\n\n  release(session) {\n    const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n\n    if (this.topology.loadBalanced && !sessionTimeoutMinutes) {\n      this.sessions.unshift(session);\n    }\n\n    if (!sessionTimeoutMinutes) {\n      return;\n    }\n\n    while (this.sessions.length) {\n      const pooledSession = this.sessions[this.sessions.length - 1];\n\n      if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n        this.sessions.pop();\n      } else {\n        break;\n      }\n    }\n\n    if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n      if (session.isDirty) {\n        return;\n      } // otherwise, readd this session to the session pool\n\n\n      this.sessions.unshift(session);\n    }\n  }\n\n}\n\nexports.ServerSessionPool = ServerSessionPool; // TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\n\nfunction commandSupportsReadConcern(command, options) {\n  if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n    return true;\n  }\n\n  if (command.mapReduce && options && options.out && (options.out.inline === 1 || options.out === 'inline')) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n */\n\nfunction applySession(session, command, options) {\n  var _b; // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n\n\n  if (session.hasEnded) {\n    return new error_1.MongoExpiredSessionError();\n  }\n\n  const serverSession = session.serverSession;\n\n  if (serverSession == null) {\n    return new error_1.MongoRuntimeError('Unable to acquire server session');\n  } // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n  // FIXME: NODE-2781, this check for write concern shouldn't be happening here, but instead during command construction\n\n\n  if (options && options.writeConcern && options.writeConcern.w === 0) {\n    if (session && session.explicit) {\n      return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n    }\n\n    return;\n  } // mark the last use of this session, and apply the `lsid`\n\n\n  serverSession.lastUse = utils_1.now();\n  command.lsid = serverSession.id; // first apply non-transaction-specific sessions data\n\n  const inTransaction = session.inTransaction() || transactions_1.isTransactionCommand(command);\n  const isRetryableWrite = (options === null || options === void 0 ? void 0 : options.willRetryWrite) || false;\n\n  if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n    command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n  }\n\n  if (!inTransaction) {\n    if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n      session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n    }\n\n    if (session.supports.causalConsistency && session.operationTime && commandSupportsReadConcern(command, options)) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    } else if (session[kSnapshotEnabled]) {\n      command.readConcern = command.readConcern || {\n        level: read_concern_1.ReadConcernLevel.snapshot\n      };\n\n      if (session[kSnapshotTime] != null) {\n        Object.assign(command.readConcern, {\n          atClusterTime: session[kSnapshotTime]\n        });\n      }\n    }\n\n    return;\n  } // now attempt to apply transaction-specific sessions data\n  // `autocommit` must always be false to differentiate from retryable writes\n\n\n  command.autocommit = false;\n\n  if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n    session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n    command.startTransaction = true;\n    const readConcern = session.transaction.options.readConcern || ((_b = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _b === void 0 ? void 0 : _b.readConcern);\n\n    if (readConcern) {\n      command.readConcern = readConcern;\n    }\n\n    if (session.supports.causalConsistency && session.operationTime) {\n      command.readConcern = command.readConcern || {};\n      Object.assign(command.readConcern, {\n        afterClusterTime: session.operationTime\n      });\n    }\n  }\n}\n\nexports.applySession = applySession;\n\nfunction updateSessionFromResponse(session, document) {\n  var _b;\n\n  if (document.$clusterTime) {\n    common_1._advanceClusterTime(session, document.$clusterTime);\n  }\n\n  if (document.operationTime && session && session.supports.causalConsistency) {\n    session.advanceOperationTime(document.operationTime);\n  }\n\n  if (document.recoveryToken && session && session.inTransaction()) {\n    session.transaction._recoveryToken = document.recoveryToken;\n  }\n\n  if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {\n    // find and aggregate commands return atClusterTime on the cursor\n    // distinct includes it in the response body\n    const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n\n    if (atClusterTime) {\n      session[kSnapshotTime] = atClusterTime;\n    }\n  }\n}\n\nexports.updateSessionFromResponse = updateSessionFromResponse;","map":{"version":3,"names":["_a","Object","defineProperty","exports","value","updateSessionFromResponse","applySession","commandSupportsReadConcern","ServerSessionPool","ServerSession","maybeClearPinnedConnection","ClientSession","promise_provider_1","require","bson_1","read_preference_1","transactions_1","common_1","shared_1","error_1","utils_1","execute_operation_1","run_command_1","connection_1","metrics_1","mongo_types_1","read_concern_1","minWireVersionForShardedTransactions","assertAlive","session","callback","serverSession","error","MongoExpiredSessionError","kServerSession","Symbol","kSnapshotTime","kSnapshotEnabled","kPinnedConnection","TypedEventEmitter","constructor","topology","sessionPool","options","clientOptions","MongoRuntimeError","snapshot","causalConsistency","MongoInvalidArgumentError","hasEnded","undefined","supports","clusterTime","initialClusterTime","operationTime","explicit","owner","defaultTransactionOptions","assign","transaction","Transaction","id","_b","acquire","snapshotEnabled","loadBalanced","description","type","TopologyType","LoadBalanced","pinnedConnection","pin","conn","TypeError","emit","Connection","PINNED","inTransaction","ConnectionPoolMetrics","TXN","CURSOR","unpin","unpinServer","isPinned","endSession","finalOptions","force","maybePromise","done","completeEndSession","release","abortTransaction","err","advanceOperationTime","greaterThan","advanceClusterTime","_c","_bsontype","signature","hash","keyId","_advanceClusterTime","equals","buffer","incrementTransactionNumber","txnNumber","isActive","startTransaction","_d","_e","_f","_g","_h","_j","_k","_l","MongoCompatibilityError","MongoTransactionError","isCommitted","topologyMaxWireVersion","maxWireVersion","isSharded","readConcern","writeConcern","readPreference","maxCommitTimeMS","transition","TxnState","STARTING_TRANSACTION","commitTransaction","cb","endTransaction","toBSON","withTransaction","fn","startTime","now","attemptTransaction","MAX_WITH_TRANSACTION_TIMEOUT","NON_DETERMINISTIC_WRITE_CONCERN_ERRORS","Set","hasNotTimedOut","max","calculateDurationInMs","isUnknownTransactionCommitResult","isNonDeterministicWriteConcernError","MongoServerError","codeName","has","isMaxTimeMSExpiredError","code","MONGODB_ERROR_CODES","UnsatisfiableWriteConcern","UnknownReplWriteConcern","MongoError","hasErrorLabel","servers","Array","from","s","values","loadBalancer","pool","checkIn","UNPINNED","state","NO_TRANSACTION","forceClear","clear","serviceId","MaxTimeMSExpired","writeConcernError","attemptTransactionCommit","catch","USER_EXPLICIT_TXN_END_STATES","TRANSACTION_COMMITTED","TRANSACTION_ABORTED","userExplicitlyEndedTransaction","Promise","PromiseProvider","get","promise","reject","isPromiseLike","then","maybeRetryOrThrow","addErrorLabel","commandName","txnState","TRANSACTION_COMMITTED_EMPTY","command","w","wtimeout","maxTimeMS","commandHandler","e","r","MongoNetworkError","MongoWriteConcernError","isRetryableError","recoveryToken","executeOperation","RunAdminCommandOperation","ReadPreference","primary","bypassPinningCheck","reply","_err","_reply","Binary","uuidV4","SUBTYPE_UUID","lastUse","isDirty","hasTimedOut","sessionTimeoutMinutes","idleTimeMinutes","Math","round","sessions","endAllPooledSessions","length","endSessions","map","logicalSessionTimeoutMinutes","shift","unshift","pooledSession","pop","aggregate","count","distinct","find","geoNear","mapReduce","out","inline","MongoAPIError","lsid","isTransactionCommand","isRetryableWrite","willRetryWrite","Long","fromNumber","afterClusterTime","level","ReadConcernLevel","atClusterTime","autocommit","TRANSACTION_IN_PROGRESS","document","$clusterTime","_recoveryToken","cursor"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/sessions.js"],"sourcesContent":["\"use strict\";\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.updateSessionFromResponse = exports.applySession = exports.commandSupportsReadConcern = exports.ServerSessionPool = exports.ServerSession = exports.maybeClearPinnedConnection = exports.ClientSession = void 0;\nconst promise_provider_1 = require(\"./promise_provider\");\nconst bson_1 = require(\"./bson\");\nconst read_preference_1 = require(\"./read_preference\");\nconst transactions_1 = require(\"./transactions\");\nconst common_1 = require(\"./sdam/common\");\nconst shared_1 = require(\"./cmap/wire_protocol/shared\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst run_command_1 = require(\"./operations/run_command\");\nconst connection_1 = require(\"./cmap/connection\");\nconst metrics_1 = require(\"./cmap/metrics\");\nconst mongo_types_1 = require(\"./mongo_types\");\nconst read_concern_1 = require(\"./read_concern\");\nconst minWireVersionForShardedTransactions = 8;\nfunction assertAlive(session, callback) {\n    if (session.serverSession == null) {\n        const error = new error_1.MongoExpiredSessionError();\n        if (typeof callback === 'function') {\n            callback(error);\n            return false;\n        }\n        throw error;\n    }\n    return true;\n}\n/** @internal */\nconst kServerSession = Symbol('serverSession');\n/** @internal */\nconst kSnapshotTime = Symbol('snapshotTime');\n/** @internal */\nconst kSnapshotEnabled = Symbol('snapshotEnabled');\n/** @internal */\nconst kPinnedConnection = Symbol('pinnedConnection');\n/**\n * A class representing a client session on the server\n *\n * NOTE: not meant to be instantiated directly.\n * @public\n */\nclass ClientSession extends mongo_types_1.TypedEventEmitter {\n    /**\n     * Create a client session.\n     * @internal\n     * @param topology - The current client's topology (Internal Class)\n     * @param sessionPool - The server session pool (Internal Class)\n     * @param options - Optional settings\n     * @param clientOptions - Optional settings provided when creating a MongoClient\n     */\n    constructor(topology, sessionPool, options, clientOptions) {\n        super();\n        /** @internal */\n        this[_a] = false;\n        if (topology == null) {\n            // TODO(NODE-3483)\n            throw new error_1.MongoRuntimeError('ClientSession requires a topology');\n        }\n        if (sessionPool == null || !(sessionPool instanceof ServerSessionPool)) {\n            // TODO(NODE-3483)\n            throw new error_1.MongoRuntimeError('ClientSession requires a ServerSessionPool');\n        }\n        options = options !== null && options !== void 0 ? options : {};\n        if (options.snapshot === true) {\n            this[kSnapshotEnabled] = true;\n            if (options.causalConsistency === true) {\n                throw new error_1.MongoInvalidArgumentError('Properties \"causalConsistency\" and \"snapshot\" are mutually exclusive');\n            }\n        }\n        this.topology = topology;\n        this.sessionPool = sessionPool;\n        this.hasEnded = false;\n        this.clientOptions = clientOptions;\n        this[kServerSession] = undefined;\n        this.supports = {\n            causalConsistency: options.snapshot !== true && options.causalConsistency !== false\n        };\n        this.clusterTime = options.initialClusterTime;\n        this.operationTime = undefined;\n        this.explicit = !!options.explicit;\n        this.owner = options.owner;\n        this.defaultTransactionOptions = Object.assign({}, options.defaultTransactionOptions);\n        this.transaction = new transactions_1.Transaction();\n    }\n    /** The server id associated with this session */\n    get id() {\n        var _b;\n        return (_b = this.serverSession) === null || _b === void 0 ? void 0 : _b.id;\n    }\n    get serverSession() {\n        if (this[kServerSession] == null) {\n            this[kServerSession] = this.sessionPool.acquire();\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this[kServerSession];\n    }\n    /** Whether or not this session is configured for snapshot reads */\n    get snapshotEnabled() {\n        return this[kSnapshotEnabled];\n    }\n    get loadBalanced() {\n        return this.topology.description.type === common_1.TopologyType.LoadBalanced;\n    }\n    /** @internal */\n    get pinnedConnection() {\n        return this[kPinnedConnection];\n    }\n    /** @internal */\n    pin(conn) {\n        if (this[kPinnedConnection]) {\n            throw TypeError('Cannot pin multiple connections to the same session');\n        }\n        this[kPinnedConnection] = conn;\n        conn.emit(connection_1.Connection.PINNED, this.inTransaction() ? metrics_1.ConnectionPoolMetrics.TXN : metrics_1.ConnectionPoolMetrics.CURSOR);\n    }\n    /** @internal */\n    unpin(options) {\n        if (this.loadBalanced) {\n            return maybeClearPinnedConnection(this, options);\n        }\n        this.transaction.unpinServer();\n    }\n    get isPinned() {\n        return this.loadBalanced ? !!this[kPinnedConnection] : this.transaction.isPinned;\n    }\n    endSession(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        const finalOptions = { force: true, ...options };\n        return utils_1.maybePromise(callback, done => {\n            if (this.hasEnded) {\n                maybeClearPinnedConnection(this, finalOptions);\n                return done();\n            }\n            const completeEndSession = () => {\n                maybeClearPinnedConnection(this, finalOptions);\n                // release the server session back to the pool\n                this.sessionPool.release(this.serverSession);\n                this[kServerSession] = undefined;\n                // mark the session as ended, and emit a signal\n                this.hasEnded = true;\n                this.emit('ended', this);\n                // spec indicates that we should ignore all errors for `endSessions`\n                done();\n            };\n            if (this.serverSession && this.inTransaction()) {\n                this.abortTransaction(err => {\n                    if (err)\n                        return done(err);\n                    completeEndSession();\n                });\n                return;\n            }\n            completeEndSession();\n        });\n    }\n    /**\n     * Advances the operationTime for a ClientSession.\n     *\n     * @param operationTime - the `BSON.Timestamp` of the operation type it is desired to advance to\n     */\n    advanceOperationTime(operationTime) {\n        if (this.operationTime == null) {\n            this.operationTime = operationTime;\n            return;\n        }\n        if (operationTime.greaterThan(this.operationTime)) {\n            this.operationTime = operationTime;\n        }\n    }\n    /**\n     * Advances the clusterTime for a ClientSession to the provided clusterTime of another ClientSession\n     *\n     * @param clusterTime - the $clusterTime returned by the server from another session in the form of a document containing the `BSON.Timestamp` clusterTime and signature\n     */\n    advanceClusterTime(clusterTime) {\n        var _b, _c;\n        if (!clusterTime || typeof clusterTime !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('input cluster time must be an object');\n        }\n        if (!clusterTime.clusterTime || clusterTime.clusterTime._bsontype !== 'Timestamp') {\n            throw new error_1.MongoInvalidArgumentError('input cluster time \"clusterTime\" property must be a valid BSON Timestamp');\n        }\n        if (!clusterTime.signature ||\n            ((_b = clusterTime.signature.hash) === null || _b === void 0 ? void 0 : _b._bsontype) !== 'Binary' ||\n            (typeof clusterTime.signature.keyId !== 'number' &&\n                ((_c = clusterTime.signature.keyId) === null || _c === void 0 ? void 0 : _c._bsontype) !== 'Long') // apparently we decode the key to number?\n        ) {\n            throw new error_1.MongoInvalidArgumentError('input cluster time must have a valid \"signature\" property with BSON Binary hash and BSON Long keyId');\n        }\n        common_1._advanceClusterTime(this, clusterTime);\n    }\n    /**\n     * Used to determine if this session equals another\n     *\n     * @param session - The session to compare to\n     */\n    equals(session) {\n        if (!(session instanceof ClientSession)) {\n            return false;\n        }\n        if (this.id == null || session.id == null) {\n            return false;\n        }\n        return this.id.id.buffer.equals(session.id.id.buffer);\n    }\n    /** Increment the transaction number on the internal ServerSession */\n    incrementTransactionNumber() {\n        if (this.serverSession) {\n            this.serverSession.txnNumber =\n                typeof this.serverSession.txnNumber === 'number' ? this.serverSession.txnNumber + 1 : 0;\n        }\n    }\n    /** @returns whether this session is currently in a transaction or not */\n    inTransaction() {\n        return this.transaction.isActive;\n    }\n    /**\n     * Starts a new transaction with the given options.\n     *\n     * @param options - Options for the transaction\n     */\n    startTransaction(options) {\n        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        if (this[kSnapshotEnabled]) {\n            throw new error_1.MongoCompatibilityError('Transactions are not allowed with snapshot sessions');\n        }\n        assertAlive(this);\n        if (this.inTransaction()) {\n            throw new error_1.MongoTransactionError('Transaction already in progress');\n        }\n        if (this.isPinned && this.transaction.isCommitted) {\n            this.unpin();\n        }\n        const topologyMaxWireVersion = utils_1.maxWireVersion(this.topology);\n        if (shared_1.isSharded(this.topology) &&\n            topologyMaxWireVersion != null &&\n            topologyMaxWireVersion < minWireVersionForShardedTransactions) {\n            throw new error_1.MongoCompatibilityError('Transactions are not supported on sharded clusters in MongoDB < 4.2.');\n        }\n        // increment txnNumber\n        this.incrementTransactionNumber();\n        // create transaction state\n        this.transaction = new transactions_1.Transaction({\n            readConcern: (_c = (_b = options === null || options === void 0 ? void 0 : options.readConcern) !== null && _b !== void 0 ? _b : this.defaultTransactionOptions.readConcern) !== null && _c !== void 0 ? _c : (_d = this.clientOptions) === null || _d === void 0 ? void 0 : _d.readConcern,\n            writeConcern: (_f = (_e = options === null || options === void 0 ? void 0 : options.writeConcern) !== null && _e !== void 0 ? _e : this.defaultTransactionOptions.writeConcern) !== null && _f !== void 0 ? _f : (_g = this.clientOptions) === null || _g === void 0 ? void 0 : _g.writeConcern,\n            readPreference: (_j = (_h = options === null || options === void 0 ? void 0 : options.readPreference) !== null && _h !== void 0 ? _h : this.defaultTransactionOptions.readPreference) !== null && _j !== void 0 ? _j : (_k = this.clientOptions) === null || _k === void 0 ? void 0 : _k.readPreference,\n            maxCommitTimeMS: (_l = options === null || options === void 0 ? void 0 : options.maxCommitTimeMS) !== null && _l !== void 0 ? _l : this.defaultTransactionOptions.maxCommitTimeMS\n        });\n        this.transaction.transition(transactions_1.TxnState.STARTING_TRANSACTION);\n    }\n    commitTransaction(callback) {\n        return utils_1.maybePromise(callback, cb => endTransaction(this, 'commitTransaction', cb));\n    }\n    abortTransaction(callback) {\n        return utils_1.maybePromise(callback, cb => endTransaction(this, 'abortTransaction', cb));\n    }\n    /**\n     * This is here to ensure that ClientSession is never serialized to BSON.\n     */\n    toBSON() {\n        throw new error_1.MongoRuntimeError('ClientSession cannot be serialized to BSON.');\n    }\n    /**\n     * Runs a provided lambda within a transaction, retrying either the commit operation\n     * or entire transaction as needed (and when the error permits) to better ensure that\n     * the transaction can complete successfully.\n     *\n     * IMPORTANT: This method requires the user to return a Promise, all lambdas that do not\n     * return a Promise will result in undefined behavior.\n     *\n     * @param fn - A lambda to run within a transaction\n     * @param options - Optional settings for the transaction\n     */\n    withTransaction(fn, options) {\n        const startTime = utils_1.now();\n        return attemptTransaction(this, startTime, fn, options);\n    }\n}\nexports.ClientSession = ClientSession;\n_a = kSnapshotEnabled;\nconst MAX_WITH_TRANSACTION_TIMEOUT = 120000;\nconst NON_DETERMINISTIC_WRITE_CONCERN_ERRORS = new Set([\n    'CannotSatisfyWriteConcern',\n    'UnknownReplWriteConcern',\n    'UnsatisfiableWriteConcern'\n]);\nfunction hasNotTimedOut(startTime, max) {\n    return utils_1.calculateDurationInMs(startTime) < max;\n}\nfunction isUnknownTransactionCommitResult(err) {\n    const isNonDeterministicWriteConcernError = err instanceof error_1.MongoServerError &&\n        err.codeName &&\n        NON_DETERMINISTIC_WRITE_CONCERN_ERRORS.has(err.codeName);\n    return (isMaxTimeMSExpiredError(err) ||\n        (!isNonDeterministicWriteConcernError &&\n            err.code !== error_1.MONGODB_ERROR_CODES.UnsatisfiableWriteConcern &&\n            err.code !== error_1.MONGODB_ERROR_CODES.UnknownReplWriteConcern));\n}\nfunction maybeClearPinnedConnection(session, options) {\n    // unpin a connection if it has been pinned\n    const conn = session[kPinnedConnection];\n    const error = options === null || options === void 0 ? void 0 : options.error;\n    if (session.inTransaction() &&\n        error &&\n        error instanceof error_1.MongoError &&\n        error.hasErrorLabel('TransientTransactionError')) {\n        return;\n    }\n    // NOTE: the spec talks about what to do on a network error only, but the tests seem to\n    //       to validate that we don't unpin on _all_ errors?\n    if (conn) {\n        const servers = Array.from(session.topology.s.servers.values());\n        const loadBalancer = servers[0];\n        if ((options === null || options === void 0 ? void 0 : options.error) == null || (options === null || options === void 0 ? void 0 : options.force)) {\n            loadBalancer.s.pool.checkIn(conn);\n            conn.emit(connection_1.Connection.UNPINNED, session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION\n                ? metrics_1.ConnectionPoolMetrics.TXN\n                : metrics_1.ConnectionPoolMetrics.CURSOR);\n            if (options === null || options === void 0 ? void 0 : options.forceClear) {\n                loadBalancer.s.pool.clear(conn.serviceId);\n            }\n        }\n        session[kPinnedConnection] = undefined;\n    }\n}\nexports.maybeClearPinnedConnection = maybeClearPinnedConnection;\nfunction isMaxTimeMSExpiredError(err) {\n    if (err == null || !(err instanceof error_1.MongoServerError)) {\n        return false;\n    }\n    return (err.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired ||\n        (err.writeConcernError && err.writeConcernError.code === error_1.MONGODB_ERROR_CODES.MaxTimeMSExpired));\n}\nfunction attemptTransactionCommit(session, startTime, fn, options) {\n    return session.commitTransaction().catch((err) => {\n        if (err instanceof error_1.MongoError &&\n            hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT) &&\n            !isMaxTimeMSExpiredError(err)) {\n            if (err.hasErrorLabel('UnknownTransactionCommitResult')) {\n                return attemptTransactionCommit(session, startTime, fn, options);\n            }\n            if (err.hasErrorLabel('TransientTransactionError')) {\n                return attemptTransaction(session, startTime, fn, options);\n            }\n        }\n        throw err;\n    });\n}\nconst USER_EXPLICIT_TXN_END_STATES = new Set([\n    transactions_1.TxnState.NO_TRANSACTION,\n    transactions_1.TxnState.TRANSACTION_COMMITTED,\n    transactions_1.TxnState.TRANSACTION_ABORTED\n]);\nfunction userExplicitlyEndedTransaction(session) {\n    return USER_EXPLICIT_TXN_END_STATES.has(session.transaction.state);\n}\nfunction attemptTransaction(session, startTime, fn, options) {\n    const Promise = promise_provider_1.PromiseProvider.get();\n    session.startTransaction(options);\n    let promise;\n    try {\n        promise = fn(session);\n    }\n    catch (err) {\n        promise = Promise.reject(err);\n    }\n    if (!utils_1.isPromiseLike(promise)) {\n        session.abortTransaction();\n        throw new error_1.MongoInvalidArgumentError('Function provided to `withTransaction` must return a Promise');\n    }\n    return promise.then(() => {\n        if (userExplicitlyEndedTransaction(session)) {\n            return;\n        }\n        return attemptTransactionCommit(session, startTime, fn, options);\n    }, err => {\n        function maybeRetryOrThrow(err) {\n            if (err instanceof error_1.MongoError &&\n                err.hasErrorLabel('TransientTransactionError') &&\n                hasNotTimedOut(startTime, MAX_WITH_TRANSACTION_TIMEOUT)) {\n                return attemptTransaction(session, startTime, fn, options);\n            }\n            if (isMaxTimeMSExpiredError(err)) {\n                err.addErrorLabel('UnknownTransactionCommitResult');\n            }\n            throw err;\n        }\n        if (session.transaction.isActive) {\n            return session.abortTransaction().then(() => maybeRetryOrThrow(err));\n        }\n        return maybeRetryOrThrow(err);\n    });\n}\nfunction endTransaction(session, commandName, callback) {\n    if (!assertAlive(session, callback)) {\n        // checking result in case callback was called\n        return;\n    }\n    // handle any initial problematic cases\n    const txnState = session.transaction.state;\n    if (txnState === transactions_1.TxnState.NO_TRANSACTION) {\n        callback(new error_1.MongoTransactionError('No transaction started'));\n        return;\n    }\n    if (commandName === 'commitTransaction') {\n        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION ||\n            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n            // the transaction was never started, we can safely exit here\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY);\n            callback();\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n            callback(new error_1.MongoTransactionError('Cannot call commitTransaction after calling abortTransaction'));\n            return;\n        }\n    }\n    else {\n        if (txnState === transactions_1.TxnState.STARTING_TRANSACTION) {\n            // the transaction was never started, we can safely exit here\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n            callback();\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_ABORTED) {\n            callback(new error_1.MongoTransactionError('Cannot call abortTransaction twice'));\n            return;\n        }\n        if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED ||\n            txnState === transactions_1.TxnState.TRANSACTION_COMMITTED_EMPTY) {\n            callback(new error_1.MongoTransactionError('Cannot call abortTransaction after calling commitTransaction'));\n            return;\n        }\n    }\n    // construct and send the command\n    const command = { [commandName]: 1 };\n    // apply a writeConcern if specified\n    let writeConcern;\n    if (session.transaction.options.writeConcern) {\n        writeConcern = Object.assign({}, session.transaction.options.writeConcern);\n    }\n    else if (session.clientOptions && session.clientOptions.writeConcern) {\n        writeConcern = { w: session.clientOptions.writeConcern.w };\n    }\n    if (txnState === transactions_1.TxnState.TRANSACTION_COMMITTED) {\n        writeConcern = Object.assign({ wtimeout: 10000 }, writeConcern, { w: 'majority' });\n    }\n    if (writeConcern) {\n        Object.assign(command, { writeConcern });\n    }\n    if (commandName === 'commitTransaction' && session.transaction.options.maxTimeMS) {\n        Object.assign(command, { maxTimeMS: session.transaction.options.maxTimeMS });\n    }\n    function commandHandler(e, r) {\n        if (commandName !== 'commitTransaction') {\n            session.transaction.transition(transactions_1.TxnState.TRANSACTION_ABORTED);\n            if (session.loadBalanced) {\n                maybeClearPinnedConnection(session, { force: false });\n            }\n            // The spec indicates that we should ignore all errors on `abortTransaction`\n            return callback();\n        }\n        session.transaction.transition(transactions_1.TxnState.TRANSACTION_COMMITTED);\n        if (e) {\n            if (e instanceof error_1.MongoNetworkError ||\n                e instanceof error_1.MongoWriteConcernError ||\n                error_1.isRetryableError(e) ||\n                isMaxTimeMSExpiredError(e)) {\n                if (isUnknownTransactionCommitResult(e)) {\n                    e.addErrorLabel('UnknownTransactionCommitResult');\n                    // per txns spec, must unpin session in this case\n                    session.unpin({ error: e });\n                }\n            }\n            else if (e.hasErrorLabel('TransientTransactionError')) {\n                session.unpin({ error: e });\n            }\n        }\n        callback(e, r);\n    }\n    // Assumption here that commandName is \"commitTransaction\" or \"abortTransaction\"\n    if (session.transaction.recoveryToken) {\n        command.recoveryToken = session.transaction.recoveryToken;\n    }\n    // send the command\n    execute_operation_1.executeOperation(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n        session,\n        readPreference: read_preference_1.ReadPreference.primary,\n        bypassPinningCheck: true\n    }), (err, reply) => {\n        if (command.abortTransaction) {\n            // always unpin on abort regardless of command outcome\n            session.unpin();\n        }\n        if (err && error_1.isRetryableError(err)) {\n            // SPEC-1185: apply majority write concern when retrying commitTransaction\n            if (command.commitTransaction) {\n                // per txns spec, must unpin session in this case\n                session.unpin({ force: true });\n                command.writeConcern = Object.assign({ wtimeout: 10000 }, command.writeConcern, {\n                    w: 'majority'\n                });\n            }\n            return execute_operation_1.executeOperation(session.topology, new run_command_1.RunAdminCommandOperation(undefined, command, {\n                session,\n                readPreference: read_preference_1.ReadPreference.primary,\n                bypassPinningCheck: true\n            }), (_err, _reply) => commandHandler(_err, _reply));\n        }\n        commandHandler(err, reply);\n    });\n}\n/**\n * Reflects the existence of a session on the server. Can be reused by the session pool.\n * WARNING: not meant to be instantiated directly. For internal use only.\n * @public\n */\nclass ServerSession {\n    /** @internal */\n    constructor() {\n        this.id = { id: new bson_1.Binary(utils_1.uuidV4(), bson_1.Binary.SUBTYPE_UUID) };\n        this.lastUse = utils_1.now();\n        this.txnNumber = 0;\n        this.isDirty = false;\n    }\n    /**\n     * Determines if the server session has timed out.\n     *\n     * @param sessionTimeoutMinutes - The server's \"logicalSessionTimeoutMinutes\"\n     */\n    hasTimedOut(sessionTimeoutMinutes) {\n        // Take the difference of the lastUse timestamp and now, which will result in a value in\n        // milliseconds, and then convert milliseconds to minutes to compare to `sessionTimeoutMinutes`\n        const idleTimeMinutes = Math.round(((utils_1.calculateDurationInMs(this.lastUse) % 86400000) % 3600000) / 60000);\n        return idleTimeMinutes > sessionTimeoutMinutes - 1;\n    }\n}\nexports.ServerSession = ServerSession;\n/**\n * Maintains a pool of Server Sessions.\n * For internal use only\n * @internal\n */\nclass ServerSessionPool {\n    constructor(topology) {\n        if (topology == null) {\n            throw new error_1.MongoRuntimeError('ServerSessionPool requires a topology');\n        }\n        this.topology = topology;\n        this.sessions = [];\n    }\n    /** Ends all sessions in the session pool */\n    endAllPooledSessions(callback) {\n        if (this.sessions.length) {\n            this.topology.endSessions(this.sessions.map((session) => session.id), () => {\n                this.sessions = [];\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            });\n            return;\n        }\n        if (typeof callback === 'function') {\n            callback();\n        }\n    }\n    /**\n     * Acquire a Server Session from the pool.\n     * Iterates through each session in the pool, removing any stale sessions\n     * along the way. The first non-stale session found is removed from the\n     * pool and returned. If no non-stale session is found, a new ServerSession is created.\n     */\n    acquire() {\n        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes || 10;\n        while (this.sessions.length) {\n            const session = this.sessions.shift();\n            if (session && (this.topology.loadBalanced || !session.hasTimedOut(sessionTimeoutMinutes))) {\n                return session;\n            }\n        }\n        return new ServerSession();\n    }\n    /**\n     * Release a session to the session pool\n     * Adds the session back to the session pool if the session has not timed out yet.\n     * This method also removes any stale sessions from the pool.\n     *\n     * @param session - The session to release to the pool\n     */\n    release(session) {\n        const sessionTimeoutMinutes = this.topology.logicalSessionTimeoutMinutes;\n        if (this.topology.loadBalanced && !sessionTimeoutMinutes) {\n            this.sessions.unshift(session);\n        }\n        if (!sessionTimeoutMinutes) {\n            return;\n        }\n        while (this.sessions.length) {\n            const pooledSession = this.sessions[this.sessions.length - 1];\n            if (pooledSession.hasTimedOut(sessionTimeoutMinutes)) {\n                this.sessions.pop();\n            }\n            else {\n                break;\n            }\n        }\n        if (!session.hasTimedOut(sessionTimeoutMinutes)) {\n            if (session.isDirty) {\n                return;\n            }\n            // otherwise, readd this session to the session pool\n            this.sessions.unshift(session);\n        }\n    }\n}\nexports.ServerSessionPool = ServerSessionPool;\n// TODO: this should be codified in command construction\n// @see https://github.com/mongodb/specifications/blob/master/source/read-write-concern/read-write-concern.rst#read-concern\nfunction commandSupportsReadConcern(command, options) {\n    if (command.aggregate || command.count || command.distinct || command.find || command.geoNear) {\n        return true;\n    }\n    if (command.mapReduce &&\n        options &&\n        options.out &&\n        (options.out.inline === 1 || options.out === 'inline')) {\n        return true;\n    }\n    return false;\n}\nexports.commandSupportsReadConcern = commandSupportsReadConcern;\n/**\n * Optionally decorate a command with sessions specific keys\n *\n * @param session - the session tracking transaction state\n * @param command - the command to decorate\n * @param options - Optional settings passed to calling operation\n */\nfunction applySession(session, command, options) {\n    var _b;\n    // TODO: merge this with `assertAlive`, did not want to throw a try/catch here\n    if (session.hasEnded) {\n        return new error_1.MongoExpiredSessionError();\n    }\n    const serverSession = session.serverSession;\n    if (serverSession == null) {\n        return new error_1.MongoRuntimeError('Unable to acquire server session');\n    }\n    // SPEC-1019: silently ignore explicit session with unacknowledged write for backwards compatibility\n    // FIXME: NODE-2781, this check for write concern shouldn't be happening here, but instead during command construction\n    if (options && options.writeConcern && options.writeConcern.w === 0) {\n        if (session && session.explicit) {\n            return new error_1.MongoAPIError('Cannot have explicit session with unacknowledged writes');\n        }\n        return;\n    }\n    // mark the last use of this session, and apply the `lsid`\n    serverSession.lastUse = utils_1.now();\n    command.lsid = serverSession.id;\n    // first apply non-transaction-specific sessions data\n    const inTransaction = session.inTransaction() || transactions_1.isTransactionCommand(command);\n    const isRetryableWrite = (options === null || options === void 0 ? void 0 : options.willRetryWrite) || false;\n    if (serverSession.txnNumber && (isRetryableWrite || inTransaction)) {\n        command.txnNumber = bson_1.Long.fromNumber(serverSession.txnNumber);\n    }\n    if (!inTransaction) {\n        if (session.transaction.state !== transactions_1.TxnState.NO_TRANSACTION) {\n            session.transaction.transition(transactions_1.TxnState.NO_TRANSACTION);\n        }\n        if (session.supports.causalConsistency &&\n            session.operationTime &&\n            commandSupportsReadConcern(command, options)) {\n            command.readConcern = command.readConcern || {};\n            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n        }\n        else if (session[kSnapshotEnabled]) {\n            command.readConcern = command.readConcern || { level: read_concern_1.ReadConcernLevel.snapshot };\n            if (session[kSnapshotTime] != null) {\n                Object.assign(command.readConcern, { atClusterTime: session[kSnapshotTime] });\n            }\n        }\n        return;\n    }\n    // now attempt to apply transaction-specific sessions data\n    // `autocommit` must always be false to differentiate from retryable writes\n    command.autocommit = false;\n    if (session.transaction.state === transactions_1.TxnState.STARTING_TRANSACTION) {\n        session.transaction.transition(transactions_1.TxnState.TRANSACTION_IN_PROGRESS);\n        command.startTransaction = true;\n        const readConcern = session.transaction.options.readConcern || ((_b = session === null || session === void 0 ? void 0 : session.clientOptions) === null || _b === void 0 ? void 0 : _b.readConcern);\n        if (readConcern) {\n            command.readConcern = readConcern;\n        }\n        if (session.supports.causalConsistency && session.operationTime) {\n            command.readConcern = command.readConcern || {};\n            Object.assign(command.readConcern, { afterClusterTime: session.operationTime });\n        }\n    }\n}\nexports.applySession = applySession;\nfunction updateSessionFromResponse(session, document) {\n    var _b;\n    if (document.$clusterTime) {\n        common_1._advanceClusterTime(session, document.$clusterTime);\n    }\n    if (document.operationTime && session && session.supports.causalConsistency) {\n        session.advanceOperationTime(document.operationTime);\n    }\n    if (document.recoveryToken && session && session.inTransaction()) {\n        session.transaction._recoveryToken = document.recoveryToken;\n    }\n    if ((session === null || session === void 0 ? void 0 : session[kSnapshotEnabled]) && session[kSnapshotTime] == null) {\n        // find and aggregate commands return atClusterTime on the cursor\n        // distinct includes it in the response body\n        const atClusterTime = ((_b = document.cursor) === null || _b === void 0 ? void 0 : _b.atClusterTime) || document.atClusterTime;\n        if (atClusterTime) {\n            session[kSnapshotTime] = atClusterTime;\n        }\n    }\n}\nexports.updateSessionFromResponse = updateSessionFromResponse;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}