{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\n\nconst crypto = require(\"crypto\");\n\nconst bson_1 = require(\"../../bson\");\n\nconst error_1 = require(\"../../error\");\n\nconst auth_provider_1 = require(\"./auth_provider\");\n\nconst utils_1 = require(\"../../utils\");\n\nconst deps_1 = require(\"../../deps\");\n\nconst defaultAuthProviders_1 = require(\"./defaultAuthProviders\");\n\nclass ScramSHA extends auth_provider_1.AuthProvider {\n  constructor(cryptoMethod) {\n    super();\n    this.cryptoMethod = cryptoMethod || 'sha1';\n  }\n\n  prepare(handshakeDoc, authContext, callback) {\n    const cryptoMethod = this.cryptoMethod;\n    const credentials = authContext.credentials;\n\n    if (!credentials) {\n      return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n\n    if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n      utils_1.emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\n    }\n\n    crypto.randomBytes(24, (err, nonce) => {\n      if (err) {\n        return callback(err);\n      } // store the nonce for later use\n\n\n      Object.assign(authContext, {\n        nonce\n      });\n      const request = Object.assign({}, handshakeDoc, {\n        speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n          db: credentials.source\n        })\n      });\n      callback(undefined, request);\n    });\n  }\n\n  auth(authContext, callback) {\n    const response = authContext.response;\n\n    if (response && response.speculativeAuthenticate) {\n      continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n      return;\n    }\n\n    executeScram(this.cryptoMethod, authContext, callback);\n  }\n\n}\n\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\n\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\n\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  const username = cleanUsername(credentials.username);\n  const mechanism = cryptoMethod === 'sha1' ? defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA1 : defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256; // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n\n  return {\n    saslStart: 1,\n    mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\n\nfunction executeScram(cryptoMethod, authContext, callback) {\n  const {\n    connection,\n    credentials\n  } = authContext;\n\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));\n  }\n\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command(utils_1.ns(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n    const err = resolveError(_err, result);\n\n    if (err) {\n      return callback(err);\n    }\n\n    continueScramConversation(cryptoMethod, result, authContext, callback);\n  });\n}\n\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  const connection = authContext.connection;\n  const credentials = authContext.credentials;\n\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n  }\n\n  const nonce = authContext.nonce;\n  const db = credentials.source;\n  const username = cleanUsername(credentials.username);\n  const password = credentials.password;\n  let processedPassword;\n\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in deps_1.saslprep ? password : deps_1.saslprep(password);\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n\n  const payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n  const dict = parsePayload(payload.value());\n  const iterations = parseInt(dict.i, 10);\n\n  if (iterations && iterations < 4096) {\n    callback( // TODO(NODE-3483)\n    new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`), false);\n    return;\n  }\n\n  const salt = dict.s;\n  const rnonce = dict.r;\n\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    callback(new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);\n    return;\n  } // Set up start of proof\n\n\n  const withoutProof = `c=biws,r=${rnonce}`;\n  const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  const storedKey = H(cryptoMethod, clientKey);\n  const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n  const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  const clientProof = `p=${xor(clientKey, clientSignature)}`;\n  const clientFinal = [withoutProof, clientProof].join(',');\n  const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  const saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new bson_1.Binary(Buffer.from(clientFinal))\n  };\n  connection.command(utils_1.ns(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n    const err = resolveError(_err, r);\n\n    if (err) {\n      return callback(err);\n    }\n\n    const parsedResponse = parsePayload(r.payload.value());\n\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));\n      return;\n    }\n\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n\n    const retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command(utils_1.ns(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n  });\n}\n\nfunction parsePayload(payload) {\n  const dict = {};\n  const parts = payload.split(',');\n\n  for (let i = 0; i < parts.length; i++) {\n    const valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n\n  return dict;\n}\n\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Username must be a string');\n  }\n\n  if (typeof password !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Password must be a string');\n  }\n\n  if (password.length === 0) {\n    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n  }\n\n  const md5 = crypto.createHash('md5');\n  md5.update(`${username}:mongo:${password}`, 'utf8');\n  return md5.digest('hex');\n} // XOR two buffers\n\n\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n\n  const length = Math.max(a.length, b.length);\n  const res = [];\n\n  for (let i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n\n  return Buffer.from(res).toString('base64');\n}\n\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\n\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\n\nlet _hiCache = {};\nlet _hiCacheCount = 0;\n\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\n\nconst hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\n\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  const key = [data, salt.toString('base64'), iterations].join('_');\n\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  } // generate the salt\n\n\n  const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod); // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\n\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n\n  let result = 0;\n\n  for (let i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n\n  return result === 0;\n}\n\nfunction resolveError(err, result) {\n  if (err) return err;\n\n  if (result) {\n    if (result.$err || result.errmsg) return new error_1.MongoServerError(result);\n  }\n}\n\nclass ScramSHA1 extends ScramSHA {\n  constructor() {\n    super('sha1');\n  }\n\n}\n\nexports.ScramSHA1 = ScramSHA1;\n\nclass ScramSHA256 extends ScramSHA {\n  constructor() {\n    super('sha256');\n  }\n\n}\n\nexports.ScramSHA256 = ScramSHA256;","map":{"version":3,"names":["Object","defineProperty","exports","value","ScramSHA256","ScramSHA1","crypto","require","bson_1","error_1","auth_provider_1","utils_1","deps_1","defaultAuthProviders_1","ScramSHA","AuthProvider","constructor","cryptoMethod","prepare","handshakeDoc","authContext","callback","credentials","MongoMissingCredentialsError","saslprep","emitWarning","randomBytes","err","nonce","assign","request","speculativeAuthenticate","makeFirstMessage","db","source","undefined","auth","response","continueScramConversation","executeScram","cleanUsername","username","replace","clientFirstMessageBare","Buffer","concat","from","toString","mechanism","AuthMechanism","MONGODB_SCRAM_SHA1","MONGODB_SCRAM_SHA256","saslStart","payload","Binary","autoAuthorize","options","skipEmptyExchange","connection","MongoInvalidArgumentError","saslStartCmd","command","ns","_err","result","resolveError","password","processedPassword","passwordDigest","e","isBuffer","dict","parsePayload","iterations","parseInt","i","MongoRuntimeError","salt","s","rnonce","r","startsWith","withoutProof","saltedPassword","HI","clientKey","HMAC","serverKey","storedKey","H","authMessage","join","clientSignature","clientProof","xor","clientFinal","serverSignature","saslContinueCmd","saslContinue","conversationId","parsedResponse","compareDigest","v","done","retrySaslContinueCmd","alloc","parts","split","length","valueParts","md5","createHash","update","digest","a","b","Math","max","res","push","method","text","key","createHmac","_hiCache","_hiCacheCount","_hiCachePurge","hiLengthMap","sha256","sha1","data","saltedData","pbkdf2Sync","lhs","rhs","timingSafeEqual","$err","errmsg","MongoServerError"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/cmap/auth/scram.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\nconst crypto = require(\"crypto\");\nconst bson_1 = require(\"../../bson\");\nconst error_1 = require(\"../../error\");\nconst auth_provider_1 = require(\"./auth_provider\");\nconst utils_1 = require(\"../../utils\");\nconst deps_1 = require(\"../../deps\");\nconst defaultAuthProviders_1 = require(\"./defaultAuthProviders\");\nclass ScramSHA extends auth_provider_1.AuthProvider {\n    constructor(cryptoMethod) {\n        super();\n        this.cryptoMethod = cryptoMethod || 'sha1';\n    }\n    prepare(handshakeDoc, authContext, callback) {\n        const cryptoMethod = this.cryptoMethod;\n        const credentials = authContext.credentials;\n        if (!credentials) {\n            return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n        }\n        if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n            utils_1.emitWarning('Warning: no saslprep library specified. Passwords will not be sanitized');\n        }\n        crypto.randomBytes(24, (err, nonce) => {\n            if (err) {\n                return callback(err);\n            }\n            // store the nonce for later use\n            Object.assign(authContext, { nonce });\n            const request = Object.assign({}, handshakeDoc, {\n                speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n                    db: credentials.source\n                })\n            });\n            callback(undefined, request);\n        });\n    }\n    auth(authContext, callback) {\n        const response = authContext.response;\n        if (response && response.speculativeAuthenticate) {\n            continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n            return;\n        }\n        executeScram(this.cryptoMethod, authContext, callback);\n    }\n}\nfunction cleanUsername(username) {\n    return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    return Buffer.concat([\n        Buffer.from('n=', 'utf8'),\n        Buffer.from(username, 'utf8'),\n        Buffer.from(',r=', 'utf8'),\n        Buffer.from(nonce.toString('base64'), 'utf8')\n    ]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n    const username = cleanUsername(credentials.username);\n    const mechanism = cryptoMethod === 'sha1' ? defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA1 : defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256;\n    // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n    // Since the username is not sasl-prep-d, we need to do this here.\n    return {\n        saslStart: 1,\n        mechanism,\n        payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n        autoAuthorize: 1,\n        options: { skipEmptyExchange: true }\n    };\n}\nfunction executeScram(cryptoMethod, authContext, callback) {\n    const { connection, credentials } = authContext;\n    if (!credentials) {\n        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n    if (!authContext.nonce) {\n        return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));\n    }\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n    connection.command(utils_1.ns(`${db}.$cmd`), saslStartCmd, undefined, (_err, result) => {\n        const err = resolveError(_err, result);\n        if (err) {\n            return callback(err);\n        }\n        continueScramConversation(cryptoMethod, result, authContext, callback);\n    });\n}\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n    const connection = authContext.connection;\n    const credentials = authContext.credentials;\n    if (!credentials) {\n        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n    }\n    if (!authContext.nonce) {\n        return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n    }\n    const nonce = authContext.nonce;\n    const db = credentials.source;\n    const username = cleanUsername(credentials.username);\n    const password = credentials.password;\n    let processedPassword;\n    if (cryptoMethod === 'sha256') {\n        processedPassword = 'kModuleError' in deps_1.saslprep ? password : deps_1.saslprep(password);\n    }\n    else {\n        try {\n            processedPassword = passwordDigest(username, password);\n        }\n        catch (e) {\n            return callback(e);\n        }\n    }\n    const payload = Buffer.isBuffer(response.payload)\n        ? new bson_1.Binary(response.payload)\n        : response.payload;\n    const dict = parsePayload(payload.value());\n    const iterations = parseInt(dict.i, 10);\n    if (iterations && iterations < 4096) {\n        callback(\n        // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`Server returned an invalid iteration count ${iterations}`), false);\n        return;\n    }\n    const salt = dict.s;\n    const rnonce = dict.r;\n    if (rnonce.startsWith('nonce')) {\n        // TODO(NODE-3483)\n        callback(new error_1.MongoRuntimeError(`Server returned an invalid nonce: ${rnonce}`), false);\n        return;\n    }\n    // Set up start of proof\n    const withoutProof = `c=biws,r=${rnonce}`;\n    const saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n    const clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n    const serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n    const storedKey = H(cryptoMethod, clientKey);\n    const authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n    const clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n    const clientProof = `p=${xor(clientKey, clientSignature)}`;\n    const clientFinal = [withoutProof, clientProof].join(',');\n    const serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n    const saslContinueCmd = {\n        saslContinue: 1,\n        conversationId: response.conversationId,\n        payload: new bson_1.Binary(Buffer.from(clientFinal))\n    };\n    connection.command(utils_1.ns(`${db}.$cmd`), saslContinueCmd, undefined, (_err, r) => {\n        const err = resolveError(_err, r);\n        if (err) {\n            return callback(err);\n        }\n        const parsedResponse = parsePayload(r.payload.value());\n        if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n            callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));\n            return;\n        }\n        if (!r || r.done !== false) {\n            return callback(err, r);\n        }\n        const retrySaslContinueCmd = {\n            saslContinue: 1,\n            conversationId: r.conversationId,\n            payload: Buffer.alloc(0)\n        };\n        connection.command(utils_1.ns(`${db}.$cmd`), retrySaslContinueCmd, undefined, callback);\n    });\n}\nfunction parsePayload(payload) {\n    const dict = {};\n    const parts = payload.split(',');\n    for (let i = 0; i < parts.length; i++) {\n        const valueParts = parts[i].split('=');\n        dict[valueParts[0]] = valueParts[1];\n    }\n    return dict;\n}\nfunction passwordDigest(username, password) {\n    if (typeof username !== 'string') {\n        throw new error_1.MongoInvalidArgumentError('Username must be a string');\n    }\n    if (typeof password !== 'string') {\n        throw new error_1.MongoInvalidArgumentError('Password must be a string');\n    }\n    if (password.length === 0) {\n        throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n    }\n    const md5 = crypto.createHash('md5');\n    md5.update(`${username}:mongo:${password}`, 'utf8');\n    return md5.digest('hex');\n}\n// XOR two buffers\nfunction xor(a, b) {\n    if (!Buffer.isBuffer(a)) {\n        a = Buffer.from(a);\n    }\n    if (!Buffer.isBuffer(b)) {\n        b = Buffer.from(b);\n    }\n    const length = Math.max(a.length, b.length);\n    const res = [];\n    for (let i = 0; i < length; i += 1) {\n        res.push(a[i] ^ b[i]);\n    }\n    return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n    return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n    return crypto.createHmac(method, key).update(text).digest();\n}\nlet _hiCache = {};\nlet _hiCacheCount = 0;\nfunction _hiCachePurge() {\n    _hiCache = {};\n    _hiCacheCount = 0;\n}\nconst hiLengthMap = {\n    sha256: 32,\n    sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n    // omit the work if already generated\n    const key = [data, salt.toString('base64'), iterations].join('_');\n    if (_hiCache[key] != null) {\n        return _hiCache[key];\n    }\n    // generate the salt\n    const saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n    // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n    if (_hiCacheCount >= 200) {\n        _hiCachePurge();\n    }\n    _hiCache[key] = saltedData;\n    _hiCacheCount += 1;\n    return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n    if (lhs.length !== rhs.length) {\n        return false;\n    }\n    if (typeof crypto.timingSafeEqual === 'function') {\n        return crypto.timingSafeEqual(lhs, rhs);\n    }\n    let result = 0;\n    for (let i = 0; i < lhs.length; i++) {\n        result |= lhs[i] ^ rhs[i];\n    }\n    return result === 0;\n}\nfunction resolveError(err, result) {\n    if (err)\n        return err;\n    if (result) {\n        if (result.$err || result.errmsg)\n            return new error_1.MongoServerError(result);\n    }\n}\nclass ScramSHA1 extends ScramSHA {\n    constructor() {\n        super('sha1');\n    }\n}\nexports.ScramSHA1 = ScramSHA1;\nclass ScramSHA256 extends ScramSHA {\n    constructor() {\n        super('sha256');\n    }\n}\nexports.ScramSHA256 = ScramSHA256;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}