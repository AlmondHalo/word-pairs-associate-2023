{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = void 0;\n\nconst stream_1 = require(\"stream\");\n\nconst commands_1 = require(\"./commands\");\n\nconst error_1 = require(\"../error\");\n\nconst constants_1 = require(\"./wire_protocol/constants\");\n\nconst compression_1 = require(\"./wire_protocol/compression\");\n\nconst utils_1 = require(\"../utils\");\n\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\n\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\n\nclass MessageStream extends stream_1.Duplex {\n  constructor(options = {}) {\n    super(options);\n    this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    this[kBuffer] = new utils_1.BufferPool();\n  }\n\n  _write(chunk, _, callback) {\n    this[kBuffer].append(chunk);\n    processIncomingData(this, callback);\n  }\n\n  _read() {\n    // NOTE: This implementation is empty because we explicitly push data to be read\n    //       when `writeMessage` is called.\n    return;\n  }\n\n  writeCommand(command, operationDescription) {\n    // TODO: agreed compressor should live in `StreamDescription`\n    const compressorName = operationDescription && operationDescription.agreedCompressor ? operationDescription.agreedCompressor : 'none';\n\n    if (compressorName === 'none' || !canCompress(command)) {\n      const data = command.toBin();\n      this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n      return;\n    } // otherwise, compress the message\n\n\n    const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n    const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE); // Extract information needed for OP_COMPRESSED from the uncompressed message\n\n    const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12); // Compress the message body\n\n    compression_1.compress({\n      options: operationDescription\n    }, messageToBeCompressed, (err, compressedMessage) => {\n      if (err || !compressedMessage) {\n        operationDescription.cb(err);\n        return;\n      } // Create the msgHeader of OP_COMPRESSED\n\n\n      const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n      msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n\n      msgHeader.writeInt32LE(command.requestId, 4); // requestID\n\n      msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n\n      msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n      // Create the compression details of OP_COMPRESSED\n\n      const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n      compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n\n      compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n\n      compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n\n      this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n    });\n  }\n\n}\n\nexports.MessageStream = MessageStream; // Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\n\nfunction canCompress(command) {\n  const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n  const commandName = Object.keys(commandDoc)[0];\n  return !compression_1.uncompressibleCommands.has(commandName);\n}\n\nfunction processIncomingData(stream, callback) {\n  const buffer = stream[kBuffer];\n\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n\n  const sizeOfMessage = buffer.peek(4).readInt32LE();\n\n  if (sizeOfMessage < 0) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n    return;\n  }\n\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n    return;\n  }\n\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n\n  const message = buffer.read(sizeOfMessage);\n  const messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n\n  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n    const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n\n    return;\n  }\n\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9); // recalculate based on wrapped opcode\n\n  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  compression_1.decompress(compressorID, compressedBuffer, (err, messageBody) => {\n    if (err || !messageBody) {\n      callback(err);\n      return;\n    }\n\n    if (messageBody.length !== messageHeader.length) {\n      callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n      return;\n    }\n\n    stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n\n    if (buffer.length >= 4) {\n      processIncomingData(stream, callback);\n    } else {\n      callback();\n    }\n  });\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","MessageStream","stream_1","require","commands_1","error_1","constants_1","compression_1","utils_1","MESSAGE_HEADER_SIZE","COMPRESSION_DETAILS_SIZE","kDefaultMaxBsonMessageSize","kBuffer","Symbol","Duplex","constructor","options","maxBsonMessageSize","BufferPool","_write","chunk","_","callback","append","processIncomingData","_read","writeCommand","command","operationDescription","compressorName","agreedCompressor","canCompress","data","toBin","push","Array","isArray","Buffer","concat","concatenatedOriginalCommandBuffer","messageToBeCompressed","slice","originalCommandOpCode","readInt32LE","compress","err","compressedMessage","cb","msgHeader","alloc","writeInt32LE","length","requestId","OP_COMPRESSED","compressionDetails","writeUInt8","Compressor","commandDoc","Msg","query","commandName","keys","uncompressibleCommands","has","stream","buffer","sizeOfMessage","peek","MongoParseError","message","read","messageHeader","responseTo","opCode","ResponseType","OP_MSG","BinMsg","Response","messageBody","emit","fromCompressed","compressorID","compressedBuffer","decompress","MongoDecompressionError"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/cmap/message_stream.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MessageStream = void 0;\nconst stream_1 = require(\"stream\");\nconst commands_1 = require(\"./commands\");\nconst error_1 = require(\"../error\");\nconst constants_1 = require(\"./wire_protocol/constants\");\nconst compression_1 = require(\"./wire_protocol/compression\");\nconst utils_1 = require(\"../utils\");\nconst MESSAGE_HEADER_SIZE = 16;\nconst COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nconst kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\nclass MessageStream extends stream_1.Duplex {\n    constructor(options = {}) {\n        super(options);\n        this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n        this[kBuffer] = new utils_1.BufferPool();\n    }\n    _write(chunk, _, callback) {\n        this[kBuffer].append(chunk);\n        processIncomingData(this, callback);\n    }\n    _read( /* size */) {\n        // NOTE: This implementation is empty because we explicitly push data to be read\n        //       when `writeMessage` is called.\n        return;\n    }\n    writeCommand(command, operationDescription) {\n        // TODO: agreed compressor should live in `StreamDescription`\n        const compressorName = operationDescription && operationDescription.agreedCompressor\n            ? operationDescription.agreedCompressor\n            : 'none';\n        if (compressorName === 'none' || !canCompress(command)) {\n            const data = command.toBin();\n            this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n            return;\n        }\n        // otherwise, compress the message\n        const concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n        const messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n        // Extract information needed for OP_COMPRESSED from the uncompressed message\n        const originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n        // Compress the message body\n        compression_1.compress({ options: operationDescription }, messageToBeCompressed, (err, compressedMessage) => {\n            if (err || !compressedMessage) {\n                operationDescription.cb(err);\n                return;\n            }\n            // Create the msgHeader of OP_COMPRESSED\n            const msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n            msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n            msgHeader.writeInt32LE(command.requestId, 4); // requestID\n            msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n            msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n            // Create the compression details of OP_COMPRESSED\n            const compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n            compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n            compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n            compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n            this.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n        });\n    }\n}\nexports.MessageStream = MessageStream;\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n    const commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n    const commandName = Object.keys(commandDoc)[0];\n    return !compression_1.uncompressibleCommands.has(commandName);\n}\nfunction processIncomingData(stream, callback) {\n    const buffer = stream[kBuffer];\n    if (buffer.length < 4) {\n        callback();\n        return;\n    }\n    const sizeOfMessage = buffer.peek(4).readInt32LE();\n    if (sizeOfMessage < 0) {\n        callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`));\n        return;\n    }\n    if (sizeOfMessage > stream.maxBsonMessageSize) {\n        callback(new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${stream.maxBsonMessageSize}`));\n        return;\n    }\n    if (sizeOfMessage > buffer.length) {\n        callback();\n        return;\n    }\n    const message = buffer.read(sizeOfMessage);\n    const messageHeader = {\n        length: message.readInt32LE(0),\n        requestId: message.readInt32LE(4),\n        responseTo: message.readInt32LE(8),\n        opCode: message.readInt32LE(12)\n    };\n    let ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n    if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n        const messageBody = message.slice(MESSAGE_HEADER_SIZE);\n        stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n        if (buffer.length >= 4) {\n            processIncomingData(stream, callback);\n        }\n        else {\n            callback();\n        }\n        return;\n    }\n    messageHeader.fromCompressed = true;\n    messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n    messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n    const compressorID = message[MESSAGE_HEADER_SIZE + 8];\n    const compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n    // recalculate based on wrapped opcode\n    ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n    compression_1.decompress(compressorID, compressedBuffer, (err, messageBody) => {\n        if (err || !messageBody) {\n            callback(err);\n            return;\n        }\n        if (messageBody.length !== messageHeader.length) {\n            callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n            return;\n        }\n        stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n        if (buffer.length >= 4) {\n            processIncomingData(stream, callback);\n        }\n        else {\n            callback();\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}