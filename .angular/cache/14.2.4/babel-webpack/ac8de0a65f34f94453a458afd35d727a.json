{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BulkOperationBase = exports.FindOperators = exports.MongoBulkWriteError = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = void 0;\n\nconst promise_provider_1 = require(\"../promise_provider\");\n\nconst bson_1 = require(\"../bson\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst execute_operation_1 = require(\"../operations/execute_operation\");\n\nconst insert_1 = require(\"../operations/insert\");\n\nconst update_1 = require(\"../operations/update\");\n\nconst delete_1 = require(\"../operations/delete\");\n\nconst write_concern_1 = require(\"../write_concern\");\n/** @internal */\n\n\nconst kServerError = Symbol('serverError');\n/** @public */\n\nexports.BatchType = Object.freeze({\n  INSERT: 1,\n  UPDATE: 2,\n  DELETE: 3\n});\n/**\n * Keeps the state of a unordered batch so we can rewrite the results\n * correctly after command execution\n *\n * @public\n */\n\nclass Batch {\n  constructor(batchType, originalZeroIndex) {\n    this.originalZeroIndex = originalZeroIndex;\n    this.currentIndex = 0;\n    this.originalIndexes = [];\n    this.batchType = batchType;\n    this.operations = [];\n    this.size = 0;\n    this.sizeBytes = 0;\n  }\n\n}\n\nexports.Batch = Batch;\n/**\n * @public\n * The result of a bulk write.\n */\n\nclass BulkWriteResult {\n  /**\n   * Create a new BulkWriteResult instance\n   * @internal\n   */\n  constructor(bulkResult) {\n    this.result = bulkResult;\n  }\n  /** Number of documents inserted. */\n\n\n  get insertedCount() {\n    var _a;\n\n    return (_a = this.result.nInserted) !== null && _a !== void 0 ? _a : 0;\n  }\n  /** Number of documents matched for update. */\n\n\n  get matchedCount() {\n    var _a;\n\n    return (_a = this.result.nMatched) !== null && _a !== void 0 ? _a : 0;\n  }\n  /** Number of documents modified. */\n\n\n  get modifiedCount() {\n    var _a;\n\n    return (_a = this.result.nModified) !== null && _a !== void 0 ? _a : 0;\n  }\n  /** Number of documents deleted. */\n\n\n  get deletedCount() {\n    var _a;\n\n    return (_a = this.result.nRemoved) !== null && _a !== void 0 ? _a : 0;\n  }\n  /** Number of documents upserted. */\n\n\n  get upsertedCount() {\n    var _a;\n\n    return (_a = this.result.upserted.length) !== null && _a !== void 0 ? _a : 0;\n  }\n  /** Upserted document generated Id's, hash key is the index of the originating operation */\n\n\n  get upsertedIds() {\n    var _a;\n\n    const upserted = {};\n\n    for (const doc of (_a = this.result.upserted) !== null && _a !== void 0 ? _a : []) {\n      upserted[doc.index] = doc._id;\n    }\n\n    return upserted;\n  }\n  /** Inserted document generated Id's, hash key is the index of the originating operation */\n\n\n  get insertedIds() {\n    var _a;\n\n    const inserted = {};\n\n    for (const doc of (_a = this.result.insertedIds) !== null && _a !== void 0 ? _a : []) {\n      inserted[doc.index] = doc._id;\n    }\n\n    return inserted;\n  }\n  /** Evaluates to true if the bulk operation correctly executes */\n\n\n  get ok() {\n    return this.result.ok;\n  }\n  /** The number of inserted documents */\n\n\n  get nInserted() {\n    return this.result.nInserted;\n  }\n  /** Number of upserted documents */\n\n\n  get nUpserted() {\n    return this.result.nUpserted;\n  }\n  /** Number of matched documents */\n\n\n  get nMatched() {\n    return this.result.nMatched;\n  }\n  /** Number of documents updated physically on disk */\n\n\n  get nModified() {\n    return this.result.nModified;\n  }\n  /** Number of removed documents */\n\n\n  get nRemoved() {\n    return this.result.nRemoved;\n  }\n  /** Returns an array of all inserted ids */\n\n\n  getInsertedIds() {\n    return this.result.insertedIds;\n  }\n  /** Returns an array of all upserted ids */\n\n\n  getUpsertedIds() {\n    return this.result.upserted;\n  }\n  /** Returns the upserted id at the given index */\n\n\n  getUpsertedIdAt(index) {\n    return this.result.upserted[index];\n  }\n  /** Returns raw internal result */\n\n\n  getRawResponse() {\n    return this.result;\n  }\n  /** Returns true if the bulk operation contains a write error */\n\n\n  hasWriteErrors() {\n    return this.result.writeErrors.length > 0;\n  }\n  /** Returns the number of write errors off the bulk operation */\n\n\n  getWriteErrorCount() {\n    return this.result.writeErrors.length;\n  }\n  /** Returns a specific write error object */\n\n\n  getWriteErrorAt(index) {\n    if (index < this.result.writeErrors.length) {\n      return this.result.writeErrors[index];\n    }\n  }\n  /** Retrieve all write errors */\n\n\n  getWriteErrors() {\n    return this.result.writeErrors;\n  }\n  /** Retrieve lastOp if available */\n\n\n  getLastOp() {\n    return this.result.opTime;\n  }\n  /** Retrieve the write concern error if one exists */\n\n\n  getWriteConcernError() {\n    if (this.result.writeConcernErrors.length === 0) {\n      return;\n    } else if (this.result.writeConcernErrors.length === 1) {\n      // Return the error\n      return this.result.writeConcernErrors[0];\n    } else {\n      // Combine the errors\n      let errmsg = '';\n\n      for (let i = 0; i < this.result.writeConcernErrors.length; i++) {\n        const err = this.result.writeConcernErrors[i];\n        errmsg = errmsg + err.errmsg; // TODO: Something better\n\n        if (i === 0) errmsg = errmsg + ' and ';\n      }\n\n      return new WriteConcernError({\n        errmsg,\n        code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed\n      });\n    }\n  }\n\n  toJSON() {\n    return this.result;\n  }\n\n  toString() {\n    return `BulkWriteResult(${this.toJSON()})`;\n  }\n\n  isOk() {\n    return this.result.ok === 1;\n  }\n\n}\n\nexports.BulkWriteResult = BulkWriteResult;\n/**\n * An error representing a failure by the server to apply the requested write concern to the bulk operation.\n * @public\n * @category Error\n */\n\nclass WriteConcernError {\n  constructor(error) {\n    this[kServerError] = error;\n  }\n  /** Write concern error code. */\n\n\n  get code() {\n    return this[kServerError].code;\n  }\n  /** Write concern error message. */\n\n\n  get errmsg() {\n    return this[kServerError].errmsg;\n  }\n  /** Write concern error info. */\n\n\n  get errInfo() {\n    return this[kServerError].errInfo;\n  }\n  /** @deprecated The `err` prop that contained a MongoServerError has been deprecated. */\n\n\n  get err() {\n    return this[kServerError];\n  }\n\n  toJSON() {\n    return this[kServerError];\n  }\n\n  toString() {\n    return `WriteConcernError(${this.errmsg})`;\n  }\n\n}\n\nexports.WriteConcernError = WriteConcernError;\n/**\n * An error that occurred during a BulkWrite on the server.\n * @public\n * @category Error\n */\n\nclass WriteError {\n  constructor(err) {\n    this.err = err;\n  }\n  /** WriteError code. */\n\n\n  get code() {\n    return this.err.code;\n  }\n  /** WriteError original bulk operation index. */\n\n\n  get index() {\n    return this.err.index;\n  }\n  /** WriteError message. */\n\n\n  get errmsg() {\n    return this.err.errmsg;\n  }\n  /** Returns the underlying operation that caused the error */\n\n\n  getOperation() {\n    return this.err.op;\n  }\n\n  toJSON() {\n    return {\n      code: this.err.code,\n      index: this.err.index,\n      errmsg: this.err.errmsg,\n      op: this.err.op\n    };\n  }\n\n  toString() {\n    return `WriteError(${JSON.stringify(this.toJSON())})`;\n  }\n\n}\n\nexports.WriteError = WriteError;\n/** Merges results into shared data structure */\n\nfunction mergeBatchResults(batch, bulkResult, err, result) {\n  // If we have an error set the result to be the err object\n  if (err) {\n    result = err;\n  } else if (result && result.result) {\n    result = result.result;\n  }\n\n  if (result == null) {\n    return;\n  } // Do we have a top level error stop processing and return\n\n\n  if (result.ok === 0 && bulkResult.ok === 1) {\n    bulkResult.ok = 0;\n    const writeError = {\n      index: 0,\n      code: result.code || 0,\n      errmsg: result.message,\n      op: batch.operations[0]\n    };\n    bulkResult.writeErrors.push(new WriteError(writeError));\n    return;\n  } else if (result.ok === 0 && bulkResult.ok === 0) {\n    return;\n  } // Deal with opTime if available\n\n\n  if (result.opTime || result.lastOp) {\n    const opTime = result.lastOp || result.opTime;\n    let lastOpTS = null;\n    let lastOpT = null; // We have a time stamp\n\n    if (opTime && opTime._bsontype === 'Timestamp') {\n      if (bulkResult.opTime == null) {\n        bulkResult.opTime = opTime;\n      } else if (opTime.greaterThan(bulkResult.opTime)) {\n        bulkResult.opTime = opTime;\n      }\n    } else {\n      // Existing TS\n      if (bulkResult.opTime) {\n        lastOpTS = typeof bulkResult.opTime.ts === 'number' ? bson_1.Long.fromNumber(bulkResult.opTime.ts) : bulkResult.opTime.ts;\n        lastOpT = typeof bulkResult.opTime.t === 'number' ? bson_1.Long.fromNumber(bulkResult.opTime.t) : bulkResult.opTime.t;\n      } // Current OpTime TS\n\n\n      const opTimeTS = typeof opTime.ts === 'number' ? bson_1.Long.fromNumber(opTime.ts) : opTime.ts;\n      const opTimeT = typeof opTime.t === 'number' ? bson_1.Long.fromNumber(opTime.t) : opTime.t; // Compare the opTime's\n\n      if (bulkResult.opTime == null) {\n        bulkResult.opTime = opTime;\n      } else if (opTimeTS.greaterThan(lastOpTS)) {\n        bulkResult.opTime = opTime;\n      } else if (opTimeTS.equals(lastOpTS)) {\n        if (opTimeT.greaterThan(lastOpT)) {\n          bulkResult.opTime = opTime;\n        }\n      }\n    }\n  } // If we have an insert Batch type\n\n\n  if (isInsertBatch(batch) && result.n) {\n    bulkResult.nInserted = bulkResult.nInserted + result.n;\n  } // If we have an insert Batch type\n\n\n  if (isDeleteBatch(batch) && result.n) {\n    bulkResult.nRemoved = bulkResult.nRemoved + result.n;\n  }\n\n  let nUpserted = 0; // We have an array of upserted values, we need to rewrite the indexes\n\n  if (Array.isArray(result.upserted)) {\n    nUpserted = result.upserted.length;\n\n    for (let i = 0; i < result.upserted.length; i++) {\n      bulkResult.upserted.push({\n        index: result.upserted[i].index + batch.originalZeroIndex,\n        _id: result.upserted[i]._id\n      });\n    }\n  } else if (result.upserted) {\n    nUpserted = 1;\n    bulkResult.upserted.push({\n      index: batch.originalZeroIndex,\n      _id: result.upserted\n    });\n  } // If we have an update Batch type\n\n\n  if (isUpdateBatch(batch) && result.n) {\n    const nModified = result.nModified;\n    bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;\n    bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);\n\n    if (typeof nModified === 'number') {\n      bulkResult.nModified = bulkResult.nModified + nModified;\n    } else {\n      bulkResult.nModified = 0;\n    }\n  }\n\n  if (Array.isArray(result.writeErrors)) {\n    for (let i = 0; i < result.writeErrors.length; i++) {\n      const writeError = {\n        index: batch.originalIndexes[result.writeErrors[i].index],\n        code: result.writeErrors[i].code,\n        errmsg: result.writeErrors[i].errmsg,\n        op: batch.operations[result.writeErrors[i].index]\n      };\n      bulkResult.writeErrors.push(new WriteError(writeError));\n    }\n  }\n\n  if (result.writeConcernError) {\n    bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));\n  }\n}\n\nfunction executeCommands(bulkOperation, options, callback) {\n  if (bulkOperation.s.batches.length === 0) {\n    return callback(undefined, new BulkWriteResult(bulkOperation.s.bulkResult));\n  }\n\n  const batch = bulkOperation.s.batches.shift();\n\n  function resultHandler(err, result) {\n    // Error is a driver related error not a bulk op error, return early\n    if (err && 'message' in err && !(err instanceof error_1.MongoWriteConcernError)) {\n      return callback(new MongoBulkWriteError(err, new BulkWriteResult(bulkOperation.s.bulkResult)));\n    }\n\n    if (err instanceof error_1.MongoWriteConcernError) {\n      return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);\n    } // Merge the results together\n\n\n    const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);\n    const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);\n\n    if (mergeResult != null) {\n      return callback(undefined, writeResult);\n    }\n\n    if (bulkOperation.handleWriteError(callback, writeResult)) return; // Execute the next command in line\n\n    executeCommands(bulkOperation, options, callback);\n  }\n\n  const finalOptions = utils_1.resolveOptions(bulkOperation, { ...options,\n    ordered: bulkOperation.isOrdered\n  });\n\n  if (finalOptions.bypassDocumentValidation !== true) {\n    delete finalOptions.bypassDocumentValidation;\n  } // Set an operationIf if provided\n\n\n  if (bulkOperation.operationId) {\n    resultHandler.operationId = bulkOperation.operationId;\n  } // Is the bypassDocumentValidation options specific\n\n\n  if (bulkOperation.s.bypassDocumentValidation === true) {\n    finalOptions.bypassDocumentValidation = true;\n  } // Is the checkKeys option disabled\n\n\n  if (bulkOperation.s.checkKeys === false) {\n    finalOptions.checkKeys = false;\n  }\n\n  if (finalOptions.retryWrites) {\n    if (isUpdateBatch(batch)) {\n      finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some(op => op.multi);\n    }\n\n    if (isDeleteBatch(batch)) {\n      finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some(op => op.limit === 0);\n    }\n  }\n\n  try {\n    if (isInsertBatch(batch)) {\n      execute_operation_1.executeOperation(bulkOperation.s.topology, new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);\n    } else if (isUpdateBatch(batch)) {\n      execute_operation_1.executeOperation(bulkOperation.s.topology, new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);\n    } else if (isDeleteBatch(batch)) {\n      execute_operation_1.executeOperation(bulkOperation.s.topology, new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);\n    }\n  } catch (err) {\n    // Force top level error\n    err.ok = 0; // Merge top level error and return\n\n    mergeBatchResults(batch, bulkOperation.s.bulkResult, err, undefined);\n    callback();\n  }\n}\n\nfunction handleMongoWriteConcernError(batch, bulkResult, err, callback) {\n  var _a, _b;\n\n  mergeBatchResults(batch, bulkResult, undefined, err.result);\n  callback(new MongoBulkWriteError({\n    message: (_a = err.result) === null || _a === void 0 ? void 0 : _a.writeConcernError.errmsg,\n    code: (_b = err.result) === null || _b === void 0 ? void 0 : _b.writeConcernError.result\n  }, new BulkWriteResult(bulkResult)));\n}\n/**\n * An error indicating an unsuccessful Bulk Write\n * @public\n * @category Error\n */\n\n\nclass MongoBulkWriteError extends error_1.MongoServerError {\n  /** Creates a new MongoBulkWriteError */\n  constructor(error, result) {\n    var _a;\n\n    super(error);\n    this.writeErrors = [];\n    if (error instanceof WriteConcernError) this.err = error;else if (!(error instanceof Error)) {\n      this.message = error.message;\n      this.code = error.code;\n      this.writeErrors = (_a = error.writeErrors) !== null && _a !== void 0 ? _a : [];\n    }\n    this.result = result;\n    Object.assign(this, error);\n  }\n\n  get name() {\n    return 'MongoBulkWriteError';\n  }\n  /** Number of documents inserted. */\n\n\n  get insertedCount() {\n    return this.result.insertedCount;\n  }\n  /** Number of documents matched for update. */\n\n\n  get matchedCount() {\n    return this.result.matchedCount;\n  }\n  /** Number of documents modified. */\n\n\n  get modifiedCount() {\n    return this.result.modifiedCount;\n  }\n  /** Number of documents deleted. */\n\n\n  get deletedCount() {\n    return this.result.deletedCount;\n  }\n  /** Number of documents upserted. */\n\n\n  get upsertedCount() {\n    return this.result.upsertedCount;\n  }\n  /** Inserted document generated Id's, hash key is the index of the originating operation */\n\n\n  get insertedIds() {\n    return this.result.insertedIds;\n  }\n  /** Upserted document generated Id's, hash key is the index of the originating operation */\n\n\n  get upsertedIds() {\n    return this.result.upsertedIds;\n  }\n\n}\n\nexports.MongoBulkWriteError = MongoBulkWriteError;\n/**\n * A builder object that is returned from {@link BulkOperationBase#find}.\n * Is used to build a write operation that involves a query filter.\n *\n * @public\n */\n\nclass FindOperators {\n  /**\n   * Creates a new FindOperators object.\n   * @internal\n   */\n  constructor(bulkOperation) {\n    this.bulkOperation = bulkOperation;\n  }\n  /** Add a multiple update operation to the bulk operation */\n\n\n  update(updateDocument) {\n    const currentOp = buildCurrentOp(this.bulkOperation);\n    return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, updateDocument, { ...currentOp,\n      multi: true\n    }));\n  }\n  /** Add a single update operation to the bulk operation */\n\n\n  updateOne(updateDocument) {\n    if (!utils_1.hasAtomicOperators(updateDocument)) {\n      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n    }\n\n    const currentOp = buildCurrentOp(this.bulkOperation);\n    return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, updateDocument, { ...currentOp,\n      multi: false\n    }));\n  }\n  /** Add a replace one operation to the bulk operation */\n\n\n  replaceOne(replacement) {\n    if (utils_1.hasAtomicOperators(replacement)) {\n      throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');\n    }\n\n    const currentOp = buildCurrentOp(this.bulkOperation);\n    return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, replacement, { ...currentOp,\n      multi: false\n    }));\n  }\n  /** Add a delete one operation to the bulk operation */\n\n\n  deleteOne() {\n    const currentOp = buildCurrentOp(this.bulkOperation);\n    return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(currentOp.selector, { ...currentOp,\n      limit: 1\n    }));\n  }\n  /** Add a delete many operation to the bulk operation */\n\n\n  delete() {\n    const currentOp = buildCurrentOp(this.bulkOperation);\n    return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(currentOp.selector, { ...currentOp,\n      limit: 0\n    }));\n  }\n  /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */\n\n\n  upsert() {\n    if (!this.bulkOperation.s.currentOp) {\n      this.bulkOperation.s.currentOp = {};\n    }\n\n    this.bulkOperation.s.currentOp.upsert = true;\n    return this;\n  }\n  /** Specifies the collation for the query condition. */\n\n\n  collation(collation) {\n    if (!this.bulkOperation.s.currentOp) {\n      this.bulkOperation.s.currentOp = {};\n    }\n\n    this.bulkOperation.s.currentOp.collation = collation;\n    return this;\n  }\n  /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */\n\n\n  arrayFilters(arrayFilters) {\n    if (!this.bulkOperation.s.currentOp) {\n      this.bulkOperation.s.currentOp = {};\n    }\n\n    this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;\n    return this;\n  }\n\n}\n\nexports.FindOperators = FindOperators;\n/** @public */\n\nclass BulkOperationBase {\n  /**\n   * Create a new OrderedBulkOperation or UnorderedBulkOperation instance\n   * @internal\n   */\n  constructor(collection, options, isOrdered) {\n    // determine whether bulkOperation is ordered or unordered\n    this.isOrdered = isOrdered;\n    const topology = utils_1.getTopology(collection);\n    options = options == null ? {} : options; // TODO Bring from driver information in isMaster\n    // Get the namespace for the write operations\n\n    const namespace = collection.s.namespace; // Used to mark operation as executed\n\n    const executed = false; // Current item\n\n    const currentOp = undefined; // Set max byte size\n\n    const isMaster = topology.lastIsMaster(); // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents\n    // over 2mb are still allowed\n\n    const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);\n    const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;\n    const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;\n    const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1000; // Calculates the largest possible size of an Array key, represented as a BSON string\n    // element. This calculation:\n    //     1 byte for BSON type\n    //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))\n    //   + 1 bytes for null terminator\n\n    const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2; // Final options for retryable writes\n\n    let finalOptions = Object.assign({}, options);\n    finalOptions = utils_1.applyRetryableWrites(finalOptions, collection.s.db); // Final results\n\n    const bulkResult = {\n      ok: 1,\n      writeErrors: [],\n      writeConcernErrors: [],\n      insertedIds: [],\n      nInserted: 0,\n      nUpserted: 0,\n      nMatched: 0,\n      nModified: 0,\n      nRemoved: 0,\n      upserted: []\n    }; // Internal state\n\n    this.s = {\n      // Final result\n      bulkResult,\n      // Current batch state\n      currentBatch: undefined,\n      currentIndex: 0,\n      // ordered specific\n      currentBatchSize: 0,\n      currentBatchSizeBytes: 0,\n      // unordered specific\n      currentInsertBatch: undefined,\n      currentUpdateBatch: undefined,\n      currentRemoveBatch: undefined,\n      batches: [],\n      // Write concern\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n      // Max batch size options\n      maxBsonObjectSize,\n      maxBatchSizeBytes,\n      maxWriteBatchSize,\n      maxKeySize,\n      // Namespace\n      namespace,\n      // Topology\n      topology,\n      // Options\n      options: finalOptions,\n      // BSON options\n      bsonOptions: bson_1.resolveBSONOptions(options),\n      // Current operation\n      currentOp,\n      // Executed\n      executed,\n      // Collection\n      collection,\n      // Fundamental error\n      err: undefined,\n      // check keys\n      checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : false\n    }; // bypass Validation\n\n    if (options.bypassDocumentValidation === true) {\n      this.s.bypassDocumentValidation = true;\n    }\n  }\n  /**\n   * Add a single insert document to the bulk operation\n   *\n   * @example\n   * ```js\n   * const bulkOp = collection.initializeOrderedBulkOp();\n   *\n   * // Adds three inserts to the bulkOp.\n   * bulkOp\n   *   .insert({ a: 1 })\n   *   .insert({ b: 2 })\n   *   .insert({ c: 3 });\n   * await bulkOp.execute();\n   * ```\n   */\n\n\n  insert(document) {\n    if (document._id == null && !shouldForceServerObjectId(this)) {\n      document._id = new bson_1.ObjectId();\n    }\n\n    return this.addToOperationsList(exports.BatchType.INSERT, document);\n  }\n  /**\n   * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.\n   * Returns a builder object used to complete the definition of the operation.\n   *\n   * @example\n   * ```js\n   * const bulkOp = collection.initializeOrderedBulkOp();\n   *\n   * // Add an updateOne to the bulkOp\n   * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });\n   *\n   * // Add an updateMany to the bulkOp\n   * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });\n   *\n   * // Add an upsert\n   * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });\n   *\n   * // Add a deletion\n   * bulkOp.find({ g: 7 }).deleteOne();\n   *\n   * // Add a multi deletion\n   * bulkOp.find({ h: 8 }).delete();\n   *\n   * // Add a replaceOne\n   * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});\n   *\n   * // Update using a pipeline (requires Mongodb 4.2 or higher)\n   * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([\n   *   { $set: { total: { $sum: [ '$y', '$z' ] } } }\n   * ]);\n   *\n   * // All of the ops will now be executed\n   * await bulkOp.execute();\n   * ```\n   */\n\n\n  find(selector) {\n    if (!selector) {\n      throw new error_1.MongoInvalidArgumentError('Bulk find operation must specify a selector');\n    } // Save a current selector\n\n\n    this.s.currentOp = {\n      selector: selector\n    };\n    return new FindOperators(this);\n  }\n  /** Specifies a raw operation to perform in the bulk write. */\n\n\n  raw(op) {\n    if ('insertOne' in op) {\n      const forceServerObjectId = shouldForceServerObjectId(this);\n\n      if (op.insertOne && op.insertOne.document == null) {\n        // NOTE: provided for legacy support, but this is a malformed operation\n        if (forceServerObjectId !== true && op.insertOne._id == null) {\n          op.insertOne._id = new bson_1.ObjectId();\n        }\n\n        return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne);\n      }\n\n      if (forceServerObjectId !== true && op.insertOne.document._id == null) {\n        op.insertOne.document._id = new bson_1.ObjectId();\n      }\n\n      return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne.document);\n    }\n\n    if ('replaceOne' in op || 'updateOne' in op || 'updateMany' in op) {\n      if ('replaceOne' in op) {\n        if ('q' in op.replaceOne) {\n          throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n        }\n\n        const updateStatement = update_1.makeUpdateStatement(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne,\n          multi: false\n        });\n\n        if (utils_1.hasAtomicOperators(updateStatement.u)) {\n          throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');\n        }\n\n        return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);\n      }\n\n      if ('updateOne' in op) {\n        if ('q' in op.updateOne) {\n          throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n        }\n\n        const updateStatement = update_1.makeUpdateStatement(op.updateOne.filter, op.updateOne.update, { ...op.updateOne,\n          multi: false\n        });\n\n        if (!utils_1.hasAtomicOperators(updateStatement.u)) {\n          throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n        }\n\n        return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);\n      }\n\n      if ('updateMany' in op) {\n        if ('q' in op.updateMany) {\n          throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n        }\n\n        const updateStatement = update_1.makeUpdateStatement(op.updateMany.filter, op.updateMany.update, { ...op.updateMany,\n          multi: true\n        });\n\n        if (!utils_1.hasAtomicOperators(updateStatement.u)) {\n          throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n        }\n\n        return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);\n      }\n    }\n\n    if ('deleteOne' in op) {\n      if ('q' in op.deleteOne) {\n        throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n      }\n\n      return this.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(op.deleteOne.filter, { ...op.deleteOne,\n        limit: 1\n      }));\n    }\n\n    if ('deleteMany' in op) {\n      if ('q' in op.deleteMany) {\n        throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n      }\n\n      return this.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(op.deleteMany.filter, { ...op.deleteMany,\n        limit: 0\n      }));\n    } // otherwise an unknown operation was provided\n\n\n    throw new error_1.MongoInvalidArgumentError('bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany');\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n\n  get batches() {\n    const batches = [...this.s.batches];\n\n    if (this.isOrdered) {\n      if (this.s.currentBatch) batches.push(this.s.currentBatch);\n    } else {\n      if (this.s.currentInsertBatch) batches.push(this.s.currentInsertBatch);\n      if (this.s.currentUpdateBatch) batches.push(this.s.currentUpdateBatch);\n      if (this.s.currentRemoveBatch) batches.push(this.s.currentRemoveBatch);\n    }\n\n    return batches;\n  }\n  /** An internal helper method. Do not invoke directly. Will be going away in the future */\n\n\n  execute(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n\n    if (this.s.executed) {\n      return handleEarlyError(new error_1.MongoBatchReExecutionError(), callback);\n    }\n\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n\n    if (writeConcern) {\n      this.s.writeConcern = writeConcern;\n    } // If we have current batch\n\n\n    if (this.isOrdered) {\n      if (this.s.currentBatch) this.s.batches.push(this.s.currentBatch);\n    } else {\n      if (this.s.currentInsertBatch) this.s.batches.push(this.s.currentInsertBatch);\n      if (this.s.currentUpdateBatch) this.s.batches.push(this.s.currentUpdateBatch);\n      if (this.s.currentRemoveBatch) this.s.batches.push(this.s.currentRemoveBatch);\n    } // If we have no operations in the bulk raise an error\n\n\n    if (this.s.batches.length === 0) {\n      const emptyBatchError = new error_1.MongoInvalidArgumentError('Invalid BulkOperation, Batch cannot be empty');\n      return handleEarlyError(emptyBatchError, callback);\n    }\n\n    this.s.executed = true;\n    const finalOptions = { ...this.s.options,\n      ...options\n    };\n    return utils_1.executeLegacyOperation(this.s.topology, executeCommands, [this, finalOptions, callback]);\n  }\n  /**\n   * Handles the write error before executing commands\n   * @internal\n   */\n\n\n  handleWriteError(callback, writeResult) {\n    if (this.s.bulkResult.writeErrors.length > 0) {\n      const msg = this.s.bulkResult.writeErrors[0].errmsg ? this.s.bulkResult.writeErrors[0].errmsg : 'write operation failed';\n      callback(new MongoBulkWriteError({\n        message: msg,\n        code: this.s.bulkResult.writeErrors[0].code,\n        writeErrors: this.s.bulkResult.writeErrors\n      }, writeResult));\n      return true;\n    }\n\n    const writeConcernError = writeResult.getWriteConcernError();\n\n    if (writeConcernError) {\n      callback(new MongoBulkWriteError(writeConcernError, writeResult));\n      return true;\n    }\n  }\n\n}\n\nexports.BulkOperationBase = BulkOperationBase;\nObject.defineProperty(BulkOperationBase.prototype, 'length', {\n  enumerable: true,\n\n  get() {\n    return this.s.currentIndex;\n  }\n\n});\n/** helper function to assist with promiseOrCallback behavior */\n\nfunction handleEarlyError(err, callback) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n\n  if (typeof callback === 'function') {\n    callback(err);\n    return;\n  }\n\n  return Promise.reject(err);\n}\n\nfunction shouldForceServerObjectId(bulkOperation) {\n  var _a, _b;\n\n  if (typeof bulkOperation.s.options.forceServerObjectId === 'boolean') {\n    return bulkOperation.s.options.forceServerObjectId;\n  }\n\n  if (typeof ((_a = bulkOperation.s.collection.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId) === 'boolean') {\n    return (_b = bulkOperation.s.collection.s.db.options) === null || _b === void 0 ? void 0 : _b.forceServerObjectId;\n  }\n\n  return false;\n}\n\nfunction isInsertBatch(batch) {\n  return batch.batchType === exports.BatchType.INSERT;\n}\n\nfunction isUpdateBatch(batch) {\n  return batch.batchType === exports.BatchType.UPDATE;\n}\n\nfunction isDeleteBatch(batch) {\n  return batch.batchType === exports.BatchType.DELETE;\n}\n\nfunction buildCurrentOp(bulkOp) {\n  let {\n    currentOp\n  } = bulkOp.s;\n  bulkOp.s.currentOp = undefined;\n  if (!currentOp) currentOp = {};\n  return currentOp;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","BulkOperationBase","FindOperators","MongoBulkWriteError","WriteError","WriteConcernError","BulkWriteResult","Batch","BatchType","promise_provider_1","require","bson_1","error_1","utils_1","execute_operation_1","insert_1","update_1","delete_1","write_concern_1","kServerError","Symbol","freeze","INSERT","UPDATE","DELETE","constructor","batchType","originalZeroIndex","currentIndex","originalIndexes","operations","size","sizeBytes","bulkResult","result","insertedCount","_a","nInserted","matchedCount","nMatched","modifiedCount","nModified","deletedCount","nRemoved","upsertedCount","upserted","length","upsertedIds","doc","index","_id","insertedIds","inserted","ok","nUpserted","getInsertedIds","getUpsertedIds","getUpsertedIdAt","getRawResponse","hasWriteErrors","writeErrors","getWriteErrorCount","getWriteErrorAt","getWriteErrors","getLastOp","opTime","getWriteConcernError","writeConcernErrors","errmsg","i","err","code","MONGODB_ERROR_CODES","WriteConcernFailed","toJSON","toString","isOk","error","errInfo","getOperation","op","JSON","stringify","mergeBatchResults","batch","writeError","message","push","lastOp","lastOpTS","lastOpT","_bsontype","greaterThan","ts","Long","fromNumber","t","opTimeTS","opTimeT","equals","isInsertBatch","n","isDeleteBatch","Array","isArray","isUpdateBatch","writeConcernError","executeCommands","bulkOperation","options","callback","s","batches","undefined","shift","resultHandler","MongoWriteConcernError","handleMongoWriteConcernError","writeResult","mergeResult","handleWriteError","finalOptions","resolveOptions","ordered","isOrdered","bypassDocumentValidation","operationId","checkKeys","retryWrites","some","multi","limit","executeOperation","topology","InsertOperation","namespace","UpdateOperation","DeleteOperation","_b","MongoServerError","Error","assign","name","update","updateDocument","currentOp","buildCurrentOp","addToOperationsList","makeUpdateStatement","selector","updateOne","hasAtomicOperators","MongoInvalidArgumentError","replaceOne","replacement","deleteOne","makeDeleteStatement","delete","upsert","collation","arrayFilters","collection","getTopology","executed","isMaster","lastIsMaster","usingAutoEncryption","autoEncrypter","maxBsonObjectSize","maxBatchSizeBytes","maxWriteBatchSize","maxKeySize","applyRetryableWrites","db","currentBatch","currentBatchSize","currentBatchSizeBytes","currentInsertBatch","currentUpdateBatch","currentRemoveBatch","writeConcern","WriteConcern","fromOptions","bsonOptions","resolveBSONOptions","insert","document","shouldForceServerObjectId","ObjectId","find","raw","forceServerObjectId","insertOne","updateStatement","filter","u","updateMany","deleteMany","execute","handleEarlyError","MongoBatchReExecutionError","emptyBatchError","executeLegacyOperation","msg","prototype","enumerable","get","Promise","PromiseProvider","reject","bulkOp"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/bulk/common.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BulkOperationBase = exports.FindOperators = exports.MongoBulkWriteError = exports.WriteError = exports.WriteConcernError = exports.BulkWriteResult = exports.Batch = exports.BatchType = void 0;\nconst promise_provider_1 = require(\"../promise_provider\");\nconst bson_1 = require(\"../bson\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst execute_operation_1 = require(\"../operations/execute_operation\");\nconst insert_1 = require(\"../operations/insert\");\nconst update_1 = require(\"../operations/update\");\nconst delete_1 = require(\"../operations/delete\");\nconst write_concern_1 = require(\"../write_concern\");\n/** @internal */\nconst kServerError = Symbol('serverError');\n/** @public */\nexports.BatchType = Object.freeze({\n    INSERT: 1,\n    UPDATE: 2,\n    DELETE: 3\n});\n/**\n * Keeps the state of a unordered batch so we can rewrite the results\n * correctly after command execution\n *\n * @public\n */\nclass Batch {\n    constructor(batchType, originalZeroIndex) {\n        this.originalZeroIndex = originalZeroIndex;\n        this.currentIndex = 0;\n        this.originalIndexes = [];\n        this.batchType = batchType;\n        this.operations = [];\n        this.size = 0;\n        this.sizeBytes = 0;\n    }\n}\nexports.Batch = Batch;\n/**\n * @public\n * The result of a bulk write.\n */\nclass BulkWriteResult {\n    /**\n     * Create a new BulkWriteResult instance\n     * @internal\n     */\n    constructor(bulkResult) {\n        this.result = bulkResult;\n    }\n    /** Number of documents inserted. */\n    get insertedCount() {\n        var _a;\n        return (_a = this.result.nInserted) !== null && _a !== void 0 ? _a : 0;\n    }\n    /** Number of documents matched for update. */\n    get matchedCount() {\n        var _a;\n        return (_a = this.result.nMatched) !== null && _a !== void 0 ? _a : 0;\n    }\n    /** Number of documents modified. */\n    get modifiedCount() {\n        var _a;\n        return (_a = this.result.nModified) !== null && _a !== void 0 ? _a : 0;\n    }\n    /** Number of documents deleted. */\n    get deletedCount() {\n        var _a;\n        return (_a = this.result.nRemoved) !== null && _a !== void 0 ? _a : 0;\n    }\n    /** Number of documents upserted. */\n    get upsertedCount() {\n        var _a;\n        return (_a = this.result.upserted.length) !== null && _a !== void 0 ? _a : 0;\n    }\n    /** Upserted document generated Id's, hash key is the index of the originating operation */\n    get upsertedIds() {\n        var _a;\n        const upserted = {};\n        for (const doc of (_a = this.result.upserted) !== null && _a !== void 0 ? _a : []) {\n            upserted[doc.index] = doc._id;\n        }\n        return upserted;\n    }\n    /** Inserted document generated Id's, hash key is the index of the originating operation */\n    get insertedIds() {\n        var _a;\n        const inserted = {};\n        for (const doc of (_a = this.result.insertedIds) !== null && _a !== void 0 ? _a : []) {\n            inserted[doc.index] = doc._id;\n        }\n        return inserted;\n    }\n    /** Evaluates to true if the bulk operation correctly executes */\n    get ok() {\n        return this.result.ok;\n    }\n    /** The number of inserted documents */\n    get nInserted() {\n        return this.result.nInserted;\n    }\n    /** Number of upserted documents */\n    get nUpserted() {\n        return this.result.nUpserted;\n    }\n    /** Number of matched documents */\n    get nMatched() {\n        return this.result.nMatched;\n    }\n    /** Number of documents updated physically on disk */\n    get nModified() {\n        return this.result.nModified;\n    }\n    /** Number of removed documents */\n    get nRemoved() {\n        return this.result.nRemoved;\n    }\n    /** Returns an array of all inserted ids */\n    getInsertedIds() {\n        return this.result.insertedIds;\n    }\n    /** Returns an array of all upserted ids */\n    getUpsertedIds() {\n        return this.result.upserted;\n    }\n    /** Returns the upserted id at the given index */\n    getUpsertedIdAt(index) {\n        return this.result.upserted[index];\n    }\n    /** Returns raw internal result */\n    getRawResponse() {\n        return this.result;\n    }\n    /** Returns true if the bulk operation contains a write error */\n    hasWriteErrors() {\n        return this.result.writeErrors.length > 0;\n    }\n    /** Returns the number of write errors off the bulk operation */\n    getWriteErrorCount() {\n        return this.result.writeErrors.length;\n    }\n    /** Returns a specific write error object */\n    getWriteErrorAt(index) {\n        if (index < this.result.writeErrors.length) {\n            return this.result.writeErrors[index];\n        }\n    }\n    /** Retrieve all write errors */\n    getWriteErrors() {\n        return this.result.writeErrors;\n    }\n    /** Retrieve lastOp if available */\n    getLastOp() {\n        return this.result.opTime;\n    }\n    /** Retrieve the write concern error if one exists */\n    getWriteConcernError() {\n        if (this.result.writeConcernErrors.length === 0) {\n            return;\n        }\n        else if (this.result.writeConcernErrors.length === 1) {\n            // Return the error\n            return this.result.writeConcernErrors[0];\n        }\n        else {\n            // Combine the errors\n            let errmsg = '';\n            for (let i = 0; i < this.result.writeConcernErrors.length; i++) {\n                const err = this.result.writeConcernErrors[i];\n                errmsg = errmsg + err.errmsg;\n                // TODO: Something better\n                if (i === 0)\n                    errmsg = errmsg + ' and ';\n            }\n            return new WriteConcernError({ errmsg, code: error_1.MONGODB_ERROR_CODES.WriteConcernFailed });\n        }\n    }\n    toJSON() {\n        return this.result;\n    }\n    toString() {\n        return `BulkWriteResult(${this.toJSON()})`;\n    }\n    isOk() {\n        return this.result.ok === 1;\n    }\n}\nexports.BulkWriteResult = BulkWriteResult;\n/**\n * An error representing a failure by the server to apply the requested write concern to the bulk operation.\n * @public\n * @category Error\n */\nclass WriteConcernError {\n    constructor(error) {\n        this[kServerError] = error;\n    }\n    /** Write concern error code. */\n    get code() {\n        return this[kServerError].code;\n    }\n    /** Write concern error message. */\n    get errmsg() {\n        return this[kServerError].errmsg;\n    }\n    /** Write concern error info. */\n    get errInfo() {\n        return this[kServerError].errInfo;\n    }\n    /** @deprecated The `err` prop that contained a MongoServerError has been deprecated. */\n    get err() {\n        return this[kServerError];\n    }\n    toJSON() {\n        return this[kServerError];\n    }\n    toString() {\n        return `WriteConcernError(${this.errmsg})`;\n    }\n}\nexports.WriteConcernError = WriteConcernError;\n/**\n * An error that occurred during a BulkWrite on the server.\n * @public\n * @category Error\n */\nclass WriteError {\n    constructor(err) {\n        this.err = err;\n    }\n    /** WriteError code. */\n    get code() {\n        return this.err.code;\n    }\n    /** WriteError original bulk operation index. */\n    get index() {\n        return this.err.index;\n    }\n    /** WriteError message. */\n    get errmsg() {\n        return this.err.errmsg;\n    }\n    /** Returns the underlying operation that caused the error */\n    getOperation() {\n        return this.err.op;\n    }\n    toJSON() {\n        return { code: this.err.code, index: this.err.index, errmsg: this.err.errmsg, op: this.err.op };\n    }\n    toString() {\n        return `WriteError(${JSON.stringify(this.toJSON())})`;\n    }\n}\nexports.WriteError = WriteError;\n/** Merges results into shared data structure */\nfunction mergeBatchResults(batch, bulkResult, err, result) {\n    // If we have an error set the result to be the err object\n    if (err) {\n        result = err;\n    }\n    else if (result && result.result) {\n        result = result.result;\n    }\n    if (result == null) {\n        return;\n    }\n    // Do we have a top level error stop processing and return\n    if (result.ok === 0 && bulkResult.ok === 1) {\n        bulkResult.ok = 0;\n        const writeError = {\n            index: 0,\n            code: result.code || 0,\n            errmsg: result.message,\n            op: batch.operations[0]\n        };\n        bulkResult.writeErrors.push(new WriteError(writeError));\n        return;\n    }\n    else if (result.ok === 0 && bulkResult.ok === 0) {\n        return;\n    }\n    // Deal with opTime if available\n    if (result.opTime || result.lastOp) {\n        const opTime = result.lastOp || result.opTime;\n        let lastOpTS = null;\n        let lastOpT = null;\n        // We have a time stamp\n        if (opTime && opTime._bsontype === 'Timestamp') {\n            if (bulkResult.opTime == null) {\n                bulkResult.opTime = opTime;\n            }\n            else if (opTime.greaterThan(bulkResult.opTime)) {\n                bulkResult.opTime = opTime;\n            }\n        }\n        else {\n            // Existing TS\n            if (bulkResult.opTime) {\n                lastOpTS =\n                    typeof bulkResult.opTime.ts === 'number'\n                        ? bson_1.Long.fromNumber(bulkResult.opTime.ts)\n                        : bulkResult.opTime.ts;\n                lastOpT =\n                    typeof bulkResult.opTime.t === 'number'\n                        ? bson_1.Long.fromNumber(bulkResult.opTime.t)\n                        : bulkResult.opTime.t;\n            }\n            // Current OpTime TS\n            const opTimeTS = typeof opTime.ts === 'number' ? bson_1.Long.fromNumber(opTime.ts) : opTime.ts;\n            const opTimeT = typeof opTime.t === 'number' ? bson_1.Long.fromNumber(opTime.t) : opTime.t;\n            // Compare the opTime's\n            if (bulkResult.opTime == null) {\n                bulkResult.opTime = opTime;\n            }\n            else if (opTimeTS.greaterThan(lastOpTS)) {\n                bulkResult.opTime = opTime;\n            }\n            else if (opTimeTS.equals(lastOpTS)) {\n                if (opTimeT.greaterThan(lastOpT)) {\n                    bulkResult.opTime = opTime;\n                }\n            }\n        }\n    }\n    // If we have an insert Batch type\n    if (isInsertBatch(batch) && result.n) {\n        bulkResult.nInserted = bulkResult.nInserted + result.n;\n    }\n    // If we have an insert Batch type\n    if (isDeleteBatch(batch) && result.n) {\n        bulkResult.nRemoved = bulkResult.nRemoved + result.n;\n    }\n    let nUpserted = 0;\n    // We have an array of upserted values, we need to rewrite the indexes\n    if (Array.isArray(result.upserted)) {\n        nUpserted = result.upserted.length;\n        for (let i = 0; i < result.upserted.length; i++) {\n            bulkResult.upserted.push({\n                index: result.upserted[i].index + batch.originalZeroIndex,\n                _id: result.upserted[i]._id\n            });\n        }\n    }\n    else if (result.upserted) {\n        nUpserted = 1;\n        bulkResult.upserted.push({\n            index: batch.originalZeroIndex,\n            _id: result.upserted\n        });\n    }\n    // If we have an update Batch type\n    if (isUpdateBatch(batch) && result.n) {\n        const nModified = result.nModified;\n        bulkResult.nUpserted = bulkResult.nUpserted + nUpserted;\n        bulkResult.nMatched = bulkResult.nMatched + (result.n - nUpserted);\n        if (typeof nModified === 'number') {\n            bulkResult.nModified = bulkResult.nModified + nModified;\n        }\n        else {\n            bulkResult.nModified = 0;\n        }\n    }\n    if (Array.isArray(result.writeErrors)) {\n        for (let i = 0; i < result.writeErrors.length; i++) {\n            const writeError = {\n                index: batch.originalIndexes[result.writeErrors[i].index],\n                code: result.writeErrors[i].code,\n                errmsg: result.writeErrors[i].errmsg,\n                op: batch.operations[result.writeErrors[i].index]\n            };\n            bulkResult.writeErrors.push(new WriteError(writeError));\n        }\n    }\n    if (result.writeConcernError) {\n        bulkResult.writeConcernErrors.push(new WriteConcernError(result.writeConcernError));\n    }\n}\nfunction executeCommands(bulkOperation, options, callback) {\n    if (bulkOperation.s.batches.length === 0) {\n        return callback(undefined, new BulkWriteResult(bulkOperation.s.bulkResult));\n    }\n    const batch = bulkOperation.s.batches.shift();\n    function resultHandler(err, result) {\n        // Error is a driver related error not a bulk op error, return early\n        if (err && 'message' in err && !(err instanceof error_1.MongoWriteConcernError)) {\n            return callback(new MongoBulkWriteError(err, new BulkWriteResult(bulkOperation.s.bulkResult)));\n        }\n        if (err instanceof error_1.MongoWriteConcernError) {\n            return handleMongoWriteConcernError(batch, bulkOperation.s.bulkResult, err, callback);\n        }\n        // Merge the results together\n        const writeResult = new BulkWriteResult(bulkOperation.s.bulkResult);\n        const mergeResult = mergeBatchResults(batch, bulkOperation.s.bulkResult, err, result);\n        if (mergeResult != null) {\n            return callback(undefined, writeResult);\n        }\n        if (bulkOperation.handleWriteError(callback, writeResult))\n            return;\n        // Execute the next command in line\n        executeCommands(bulkOperation, options, callback);\n    }\n    const finalOptions = utils_1.resolveOptions(bulkOperation, {\n        ...options,\n        ordered: bulkOperation.isOrdered\n    });\n    if (finalOptions.bypassDocumentValidation !== true) {\n        delete finalOptions.bypassDocumentValidation;\n    }\n    // Set an operationIf if provided\n    if (bulkOperation.operationId) {\n        resultHandler.operationId = bulkOperation.operationId;\n    }\n    // Is the bypassDocumentValidation options specific\n    if (bulkOperation.s.bypassDocumentValidation === true) {\n        finalOptions.bypassDocumentValidation = true;\n    }\n    // Is the checkKeys option disabled\n    if (bulkOperation.s.checkKeys === false) {\n        finalOptions.checkKeys = false;\n    }\n    if (finalOptions.retryWrites) {\n        if (isUpdateBatch(batch)) {\n            finalOptions.retryWrites = finalOptions.retryWrites && !batch.operations.some(op => op.multi);\n        }\n        if (isDeleteBatch(batch)) {\n            finalOptions.retryWrites =\n                finalOptions.retryWrites && !batch.operations.some(op => op.limit === 0);\n        }\n    }\n    try {\n        if (isInsertBatch(batch)) {\n            execute_operation_1.executeOperation(bulkOperation.s.topology, new insert_1.InsertOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);\n        }\n        else if (isUpdateBatch(batch)) {\n            execute_operation_1.executeOperation(bulkOperation.s.topology, new update_1.UpdateOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);\n        }\n        else if (isDeleteBatch(batch)) {\n            execute_operation_1.executeOperation(bulkOperation.s.topology, new delete_1.DeleteOperation(bulkOperation.s.namespace, batch.operations, finalOptions), resultHandler);\n        }\n    }\n    catch (err) {\n        // Force top level error\n        err.ok = 0;\n        // Merge top level error and return\n        mergeBatchResults(batch, bulkOperation.s.bulkResult, err, undefined);\n        callback();\n    }\n}\nfunction handleMongoWriteConcernError(batch, bulkResult, err, callback) {\n    var _a, _b;\n    mergeBatchResults(batch, bulkResult, undefined, err.result);\n    callback(new MongoBulkWriteError({\n        message: (_a = err.result) === null || _a === void 0 ? void 0 : _a.writeConcernError.errmsg,\n        code: (_b = err.result) === null || _b === void 0 ? void 0 : _b.writeConcernError.result\n    }, new BulkWriteResult(bulkResult)));\n}\n/**\n * An error indicating an unsuccessful Bulk Write\n * @public\n * @category Error\n */\nclass MongoBulkWriteError extends error_1.MongoServerError {\n    /** Creates a new MongoBulkWriteError */\n    constructor(error, result) {\n        var _a;\n        super(error);\n        this.writeErrors = [];\n        if (error instanceof WriteConcernError)\n            this.err = error;\n        else if (!(error instanceof Error)) {\n            this.message = error.message;\n            this.code = error.code;\n            this.writeErrors = (_a = error.writeErrors) !== null && _a !== void 0 ? _a : [];\n        }\n        this.result = result;\n        Object.assign(this, error);\n    }\n    get name() {\n        return 'MongoBulkWriteError';\n    }\n    /** Number of documents inserted. */\n    get insertedCount() {\n        return this.result.insertedCount;\n    }\n    /** Number of documents matched for update. */\n    get matchedCount() {\n        return this.result.matchedCount;\n    }\n    /** Number of documents modified. */\n    get modifiedCount() {\n        return this.result.modifiedCount;\n    }\n    /** Number of documents deleted. */\n    get deletedCount() {\n        return this.result.deletedCount;\n    }\n    /** Number of documents upserted. */\n    get upsertedCount() {\n        return this.result.upsertedCount;\n    }\n    /** Inserted document generated Id's, hash key is the index of the originating operation */\n    get insertedIds() {\n        return this.result.insertedIds;\n    }\n    /** Upserted document generated Id's, hash key is the index of the originating operation */\n    get upsertedIds() {\n        return this.result.upsertedIds;\n    }\n}\nexports.MongoBulkWriteError = MongoBulkWriteError;\n/**\n * A builder object that is returned from {@link BulkOperationBase#find}.\n * Is used to build a write operation that involves a query filter.\n *\n * @public\n */\nclass FindOperators {\n    /**\n     * Creates a new FindOperators object.\n     * @internal\n     */\n    constructor(bulkOperation) {\n        this.bulkOperation = bulkOperation;\n    }\n    /** Add a multiple update operation to the bulk operation */\n    update(updateDocument) {\n        const currentOp = buildCurrentOp(this.bulkOperation);\n        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, updateDocument, {\n            ...currentOp,\n            multi: true\n        }));\n    }\n    /** Add a single update operation to the bulk operation */\n    updateOne(updateDocument) {\n        if (!utils_1.hasAtomicOperators(updateDocument)) {\n            throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n        }\n        const currentOp = buildCurrentOp(this.bulkOperation);\n        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, updateDocument, { ...currentOp, multi: false }));\n    }\n    /** Add a replace one operation to the bulk operation */\n    replaceOne(replacement) {\n        if (utils_1.hasAtomicOperators(replacement)) {\n            throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');\n        }\n        const currentOp = buildCurrentOp(this.bulkOperation);\n        return this.bulkOperation.addToOperationsList(exports.BatchType.UPDATE, update_1.makeUpdateStatement(currentOp.selector, replacement, { ...currentOp, multi: false }));\n    }\n    /** Add a delete one operation to the bulk operation */\n    deleteOne() {\n        const currentOp = buildCurrentOp(this.bulkOperation);\n        return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(currentOp.selector, { ...currentOp, limit: 1 }));\n    }\n    /** Add a delete many operation to the bulk operation */\n    delete() {\n        const currentOp = buildCurrentOp(this.bulkOperation);\n        return this.bulkOperation.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(currentOp.selector, { ...currentOp, limit: 0 }));\n    }\n    /** Upsert modifier for update bulk operation, noting that this operation is an upsert. */\n    upsert() {\n        if (!this.bulkOperation.s.currentOp) {\n            this.bulkOperation.s.currentOp = {};\n        }\n        this.bulkOperation.s.currentOp.upsert = true;\n        return this;\n    }\n    /** Specifies the collation for the query condition. */\n    collation(collation) {\n        if (!this.bulkOperation.s.currentOp) {\n            this.bulkOperation.s.currentOp = {};\n        }\n        this.bulkOperation.s.currentOp.collation = collation;\n        return this;\n    }\n    /** Specifies arrayFilters for UpdateOne or UpdateMany bulk operations. */\n    arrayFilters(arrayFilters) {\n        if (!this.bulkOperation.s.currentOp) {\n            this.bulkOperation.s.currentOp = {};\n        }\n        this.bulkOperation.s.currentOp.arrayFilters = arrayFilters;\n        return this;\n    }\n}\nexports.FindOperators = FindOperators;\n/** @public */\nclass BulkOperationBase {\n    /**\n     * Create a new OrderedBulkOperation or UnorderedBulkOperation instance\n     * @internal\n     */\n    constructor(collection, options, isOrdered) {\n        // determine whether bulkOperation is ordered or unordered\n        this.isOrdered = isOrdered;\n        const topology = utils_1.getTopology(collection);\n        options = options == null ? {} : options;\n        // TODO Bring from driver information in isMaster\n        // Get the namespace for the write operations\n        const namespace = collection.s.namespace;\n        // Used to mark operation as executed\n        const executed = false;\n        // Current item\n        const currentOp = undefined;\n        // Set max byte size\n        const isMaster = topology.lastIsMaster();\n        // If we have autoEncryption on, batch-splitting must be done on 2mb chunks, but single documents\n        // over 2mb are still allowed\n        const usingAutoEncryption = !!(topology.s.options && topology.s.options.autoEncrypter);\n        const maxBsonObjectSize = isMaster && isMaster.maxBsonObjectSize ? isMaster.maxBsonObjectSize : 1024 * 1024 * 16;\n        const maxBatchSizeBytes = usingAutoEncryption ? 1024 * 1024 * 2 : maxBsonObjectSize;\n        const maxWriteBatchSize = isMaster && isMaster.maxWriteBatchSize ? isMaster.maxWriteBatchSize : 1000;\n        // Calculates the largest possible size of an Array key, represented as a BSON string\n        // element. This calculation:\n        //     1 byte for BSON type\n        //     # of bytes = length of (string representation of (maxWriteBatchSize - 1))\n        //   + 1 bytes for null terminator\n        const maxKeySize = (maxWriteBatchSize - 1).toString(10).length + 2;\n        // Final options for retryable writes\n        let finalOptions = Object.assign({}, options);\n        finalOptions = utils_1.applyRetryableWrites(finalOptions, collection.s.db);\n        // Final results\n        const bulkResult = {\n            ok: 1,\n            writeErrors: [],\n            writeConcernErrors: [],\n            insertedIds: [],\n            nInserted: 0,\n            nUpserted: 0,\n            nMatched: 0,\n            nModified: 0,\n            nRemoved: 0,\n            upserted: []\n        };\n        // Internal state\n        this.s = {\n            // Final result\n            bulkResult,\n            // Current batch state\n            currentBatch: undefined,\n            currentIndex: 0,\n            // ordered specific\n            currentBatchSize: 0,\n            currentBatchSizeBytes: 0,\n            // unordered specific\n            currentInsertBatch: undefined,\n            currentUpdateBatch: undefined,\n            currentRemoveBatch: undefined,\n            batches: [],\n            // Write concern\n            writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n            // Max batch size options\n            maxBsonObjectSize,\n            maxBatchSizeBytes,\n            maxWriteBatchSize,\n            maxKeySize,\n            // Namespace\n            namespace,\n            // Topology\n            topology,\n            // Options\n            options: finalOptions,\n            // BSON options\n            bsonOptions: bson_1.resolveBSONOptions(options),\n            // Current operation\n            currentOp,\n            // Executed\n            executed,\n            // Collection\n            collection,\n            // Fundamental error\n            err: undefined,\n            // check keys\n            checkKeys: typeof options.checkKeys === 'boolean' ? options.checkKeys : false\n        };\n        // bypass Validation\n        if (options.bypassDocumentValidation === true) {\n            this.s.bypassDocumentValidation = true;\n        }\n    }\n    /**\n     * Add a single insert document to the bulk operation\n     *\n     * @example\n     * ```js\n     * const bulkOp = collection.initializeOrderedBulkOp();\n     *\n     * // Adds three inserts to the bulkOp.\n     * bulkOp\n     *   .insert({ a: 1 })\n     *   .insert({ b: 2 })\n     *   .insert({ c: 3 });\n     * await bulkOp.execute();\n     * ```\n     */\n    insert(document) {\n        if (document._id == null && !shouldForceServerObjectId(this)) {\n            document._id = new bson_1.ObjectId();\n        }\n        return this.addToOperationsList(exports.BatchType.INSERT, document);\n    }\n    /**\n     * Builds a find operation for an update/updateOne/delete/deleteOne/replaceOne.\n     * Returns a builder object used to complete the definition of the operation.\n     *\n     * @example\n     * ```js\n     * const bulkOp = collection.initializeOrderedBulkOp();\n     *\n     * // Add an updateOne to the bulkOp\n     * bulkOp.find({ a: 1 }).updateOne({ $set: { b: 2 } });\n     *\n     * // Add an updateMany to the bulkOp\n     * bulkOp.find({ c: 3 }).update({ $set: { d: 4 } });\n     *\n     * // Add an upsert\n     * bulkOp.find({ e: 5 }).upsert().updateOne({ $set: { f: 6 } });\n     *\n     * // Add a deletion\n     * bulkOp.find({ g: 7 }).deleteOne();\n     *\n     * // Add a multi deletion\n     * bulkOp.find({ h: 8 }).delete();\n     *\n     * // Add a replaceOne\n     * bulkOp.find({ i: 9 }).replaceOne({writeConcern: { j: 10 }});\n     *\n     * // Update using a pipeline (requires Mongodb 4.2 or higher)\n     * bulk.find({ k: 11, y: { $exists: true }, z: { $exists: true } }).updateOne([\n     *   { $set: { total: { $sum: [ '$y', '$z' ] } } }\n     * ]);\n     *\n     * // All of the ops will now be executed\n     * await bulkOp.execute();\n     * ```\n     */\n    find(selector) {\n        if (!selector) {\n            throw new error_1.MongoInvalidArgumentError('Bulk find operation must specify a selector');\n        }\n        // Save a current selector\n        this.s.currentOp = {\n            selector: selector\n        };\n        return new FindOperators(this);\n    }\n    /** Specifies a raw operation to perform in the bulk write. */\n    raw(op) {\n        if ('insertOne' in op) {\n            const forceServerObjectId = shouldForceServerObjectId(this);\n            if (op.insertOne && op.insertOne.document == null) {\n                // NOTE: provided for legacy support, but this is a malformed operation\n                if (forceServerObjectId !== true && op.insertOne._id == null) {\n                    op.insertOne._id = new bson_1.ObjectId();\n                }\n                return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne);\n            }\n            if (forceServerObjectId !== true && op.insertOne.document._id == null) {\n                op.insertOne.document._id = new bson_1.ObjectId();\n            }\n            return this.addToOperationsList(exports.BatchType.INSERT, op.insertOne.document);\n        }\n        if ('replaceOne' in op || 'updateOne' in op || 'updateMany' in op) {\n            if ('replaceOne' in op) {\n                if ('q' in op.replaceOne) {\n                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n                }\n                const updateStatement = update_1.makeUpdateStatement(op.replaceOne.filter, op.replaceOne.replacement, { ...op.replaceOne, multi: false });\n                if (utils_1.hasAtomicOperators(updateStatement.u)) {\n                    throw new error_1.MongoInvalidArgumentError('Replacement document must not use atomic operators');\n                }\n                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);\n            }\n            if ('updateOne' in op) {\n                if ('q' in op.updateOne) {\n                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n                }\n                const updateStatement = update_1.makeUpdateStatement(op.updateOne.filter, op.updateOne.update, {\n                    ...op.updateOne,\n                    multi: false\n                });\n                if (!utils_1.hasAtomicOperators(updateStatement.u)) {\n                    throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n                }\n                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);\n            }\n            if ('updateMany' in op) {\n                if ('q' in op.updateMany) {\n                    throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n                }\n                const updateStatement = update_1.makeUpdateStatement(op.updateMany.filter, op.updateMany.update, {\n                    ...op.updateMany,\n                    multi: true\n                });\n                if (!utils_1.hasAtomicOperators(updateStatement.u)) {\n                    throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n                }\n                return this.addToOperationsList(exports.BatchType.UPDATE, updateStatement);\n            }\n        }\n        if ('deleteOne' in op) {\n            if ('q' in op.deleteOne) {\n                throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n            }\n            return this.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(op.deleteOne.filter, { ...op.deleteOne, limit: 1 }));\n        }\n        if ('deleteMany' in op) {\n            if ('q' in op.deleteMany) {\n                throw new error_1.MongoInvalidArgumentError('Raw operations are not allowed');\n            }\n            return this.addToOperationsList(exports.BatchType.DELETE, delete_1.makeDeleteStatement(op.deleteMany.filter, { ...op.deleteMany, limit: 0 }));\n        }\n        // otherwise an unknown operation was provided\n        throw new error_1.MongoInvalidArgumentError('bulkWrite only supports insertOne, updateOne, updateMany, deleteOne, deleteMany');\n    }\n    get bsonOptions() {\n        return this.s.bsonOptions;\n    }\n    get writeConcern() {\n        return this.s.writeConcern;\n    }\n    get batches() {\n        const batches = [...this.s.batches];\n        if (this.isOrdered) {\n            if (this.s.currentBatch)\n                batches.push(this.s.currentBatch);\n        }\n        else {\n            if (this.s.currentInsertBatch)\n                batches.push(this.s.currentInsertBatch);\n            if (this.s.currentUpdateBatch)\n                batches.push(this.s.currentUpdateBatch);\n            if (this.s.currentRemoveBatch)\n                batches.push(this.s.currentRemoveBatch);\n        }\n        return batches;\n    }\n    /** An internal helper method. Do not invoke directly. Will be going away in the future */\n    execute(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        if (this.s.executed) {\n            return handleEarlyError(new error_1.MongoBatchReExecutionError(), callback);\n        }\n        const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n        if (writeConcern) {\n            this.s.writeConcern = writeConcern;\n        }\n        // If we have current batch\n        if (this.isOrdered) {\n            if (this.s.currentBatch)\n                this.s.batches.push(this.s.currentBatch);\n        }\n        else {\n            if (this.s.currentInsertBatch)\n                this.s.batches.push(this.s.currentInsertBatch);\n            if (this.s.currentUpdateBatch)\n                this.s.batches.push(this.s.currentUpdateBatch);\n            if (this.s.currentRemoveBatch)\n                this.s.batches.push(this.s.currentRemoveBatch);\n        }\n        // If we have no operations in the bulk raise an error\n        if (this.s.batches.length === 0) {\n            const emptyBatchError = new error_1.MongoInvalidArgumentError('Invalid BulkOperation, Batch cannot be empty');\n            return handleEarlyError(emptyBatchError, callback);\n        }\n        this.s.executed = true;\n        const finalOptions = { ...this.s.options, ...options };\n        return utils_1.executeLegacyOperation(this.s.topology, executeCommands, [this, finalOptions, callback]);\n    }\n    /**\n     * Handles the write error before executing commands\n     * @internal\n     */\n    handleWriteError(callback, writeResult) {\n        if (this.s.bulkResult.writeErrors.length > 0) {\n            const msg = this.s.bulkResult.writeErrors[0].errmsg\n                ? this.s.bulkResult.writeErrors[0].errmsg\n                : 'write operation failed';\n            callback(new MongoBulkWriteError({\n                message: msg,\n                code: this.s.bulkResult.writeErrors[0].code,\n                writeErrors: this.s.bulkResult.writeErrors\n            }, writeResult));\n            return true;\n        }\n        const writeConcernError = writeResult.getWriteConcernError();\n        if (writeConcernError) {\n            callback(new MongoBulkWriteError(writeConcernError, writeResult));\n            return true;\n        }\n    }\n}\nexports.BulkOperationBase = BulkOperationBase;\nObject.defineProperty(BulkOperationBase.prototype, 'length', {\n    enumerable: true,\n    get() {\n        return this.s.currentIndex;\n    }\n});\n/** helper function to assist with promiseOrCallback behavior */\nfunction handleEarlyError(err, callback) {\n    const Promise = promise_provider_1.PromiseProvider.get();\n    if (typeof callback === 'function') {\n        callback(err);\n        return;\n    }\n    return Promise.reject(err);\n}\nfunction shouldForceServerObjectId(bulkOperation) {\n    var _a, _b;\n    if (typeof bulkOperation.s.options.forceServerObjectId === 'boolean') {\n        return bulkOperation.s.options.forceServerObjectId;\n    }\n    if (typeof ((_a = bulkOperation.s.collection.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId) === 'boolean') {\n        return (_b = bulkOperation.s.collection.s.db.options) === null || _b === void 0 ? void 0 : _b.forceServerObjectId;\n    }\n    return false;\n}\nfunction isInsertBatch(batch) {\n    return batch.batchType === exports.BatchType.INSERT;\n}\nfunction isUpdateBatch(batch) {\n    return batch.batchType === exports.BatchType.UPDATE;\n}\nfunction isDeleteBatch(batch) {\n    return batch.batchType === exports.BatchType.DELETE;\n}\nfunction buildCurrentOp(bulkOp) {\n    let { currentOp } = bulkOp.s;\n    bulkOp.s.currentOp = undefined;\n    if (!currentOp)\n        currentOp = {};\n    return currentOp;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}