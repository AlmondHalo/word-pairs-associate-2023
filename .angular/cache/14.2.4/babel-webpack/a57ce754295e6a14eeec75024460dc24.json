{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\n\nconst utils_1 = require(\"../utils\");\n\nconst bson_1 = require(\"../bson\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst error_1 = require(\"../error\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst stream_1 = require(\"stream\");\n\nconst read_concern_1 = require(\"../read_concern\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\n\n\nconst kId = Symbol('id');\n/** @internal */\n\nconst kDocuments = Symbol('documents');\n/** @internal */\n\nconst kServer = Symbol('server');\n/** @internal */\n\nconst kNamespace = Symbol('namespace');\n/** @internal */\n\nconst kTopology = Symbol('topology');\n/** @internal */\n\nconst kSession = Symbol('session');\n/** @internal */\n\nconst kOptions = Symbol('options');\n/** @internal */\n\nconst kTransform = Symbol('transform');\n/** @internal */\n\nconst kInitialized = Symbol('initialized');\n/** @internal */\n\nconst kClosed = Symbol('closed');\n/** @internal */\n\nconst kKilled = Symbol('killed');\n/** @public */\n\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\n\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(topology, namespace, options = {}) {\n    super();\n    this[kTopology] = topology;\n    this[kNamespace] = namespace;\n    this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n\n    this[kInitialized] = false;\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kOptions] = {\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary,\n      ...bson_1.pluckBSONSerializeOptions(options)\n    };\n    const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n\n    if (readConcern) {\n      this[kOptions].readConcern = readConcern;\n    }\n\n    if (typeof options.batchSize === 'number') {\n      this[kOptions].batchSize = options.batchSize;\n    }\n\n    if (options.comment != null) {\n      this[kOptions].comment = options.comment;\n    }\n\n    if (typeof options.maxTimeMS === 'number') {\n      this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n\n    if (options.session instanceof sessions_1.ClientSession) {\n      this[kSession] = options.session;\n    }\n  }\n\n  get id() {\n    return this[kId];\n  }\n  /** @internal */\n\n\n  get topology() {\n    return this[kTopology];\n  }\n  /** @internal */\n\n\n  get server() {\n    return this[kServer];\n  }\n\n  get namespace() {\n    return this[kNamespace];\n  }\n\n  get readPreference() {\n    return this[kOptions].readPreference;\n  }\n\n  get readConcern() {\n    return this[kOptions].readConcern;\n  }\n  /** @internal */\n\n\n  get session() {\n    return this[kSession];\n  }\n\n  set session(clientSession) {\n    this[kSession] = clientSession;\n  }\n  /** @internal */\n\n\n  get cursorOptions() {\n    return this[kOptions];\n  }\n\n  get closed() {\n    return this[kClosed];\n  }\n\n  get killed() {\n    return this[kKilled];\n  }\n\n  get loadBalanced() {\n    return this[kTopology].loadBalanced;\n  }\n  /** Returns current buffered documents length */\n\n\n  bufferedCount() {\n    return this[kDocuments].length;\n  }\n  /** Returns current buffered documents */\n\n\n  readBufferedDocuments(number) {\n    return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);\n  }\n\n  [Symbol.asyncIterator]() {\n    return {\n      next: () => this.next().then(value => value != null ? {\n        value,\n        done: false\n      } : {\n        value: undefined,\n        done: true\n      })\n    };\n  }\n\n  stream(options) {\n    if (options === null || options === void 0 ? void 0 : options.transform) {\n      const transform = options.transform;\n      const readable = makeCursorStream(this);\n      return readable.pipe(new stream_1.Transform({\n        objectMode: true,\n        highWaterMark: 1,\n\n        transform(chunk, _, callback) {\n          try {\n            const transformed = transform(chunk);\n            callback(undefined, transformed);\n          } catch (err) {\n            callback(err);\n          }\n        }\n\n      }));\n    }\n\n    return makeCursorStream(this);\n  }\n\n  hasNext(callback) {\n    return utils_1.maybePromise(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(undefined, false);\n      }\n\n      if (this[kDocuments].length) {\n        return done(undefined, true);\n      }\n\n      next(this, true, (err, doc) => {\n        if (err) return done(err);\n\n        if (doc) {\n          this[kDocuments].unshift(doc);\n          done(undefined, true);\n          return;\n        }\n\n        done(undefined, false);\n      });\n    });\n  }\n\n  next(callback) {\n    return utils_1.maybePromise(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoCursorExhaustedError());\n      }\n\n      next(this, true, done);\n    });\n  }\n\n  tryNext(callback) {\n    return utils_1.maybePromise(callback, done => {\n      if (this[kId] === bson_1.Long.ZERO) {\n        return done(new error_1.MongoCursorExhaustedError());\n      }\n\n      next(this, false, done);\n    });\n  }\n\n  forEach(iterator, callback) {\n    if (typeof iterator !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n    }\n\n    return utils_1.maybePromise(callback, done => {\n      const transform = this[kTransform];\n\n      const fetchDocs = () => {\n        next(this, true, (err, doc) => {\n          if (err || doc == null) return done(err);\n          let result; // NOTE: no need to transform because `next` will do this automatically\n\n          try {\n            result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n          } catch (error) {\n            return done(error);\n          }\n\n          if (result === false) return done(); // these do need to be transformed since they are copying the rest of the batch\n\n          const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n\n          for (let i = 0; i < internalDocs.length; ++i) {\n            try {\n              result = iterator(transform ? transform(internalDocs[i]) : internalDocs[i] // TODO(NODE-3283): Improve transform typing\n              );\n            } catch (error) {\n              return done(error);\n            }\n\n            if (result === false) return done();\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n\n  close(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    const needsToEmitClosed = !this[kClosed];\n    this[kClosed] = true;\n    return utils_1.maybePromise(callback, done => cleanupCursor(this, {\n      needsToEmitClosed\n    }, done));\n  }\n\n  toArray(callback) {\n    return utils_1.maybePromise(callback, done => {\n      const docs = [];\n      const transform = this[kTransform];\n\n      const fetchDocs = () => {\n        // NOTE: if we add a `nextBatch` then we should use it here\n        next(this, true, (err, doc) => {\n          if (err) return done(err);\n          if (doc == null) return done(undefined, docs); // NOTE: no need to transform because `next` will do this automatically\n\n          docs.push(doc); // these do need to be transformed since they are copying the rest of the batch\n\n          const internalDocs = transform ? this[kDocuments].splice(0, this[kDocuments].length).map(transform) : this[kDocuments].splice(0, this[kDocuments].length); // TODO(NODE-3283): Improve transform typing\n\n          if (internalDocs) {\n            docs.push(...internalDocs);\n          }\n\n          fetchDocs();\n        });\n      };\n\n      fetchDocs();\n    });\n  }\n  /**\n   * Add a cursor flag to the cursor\n   *\n   * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n   * @param value - The flag boolean value.\n   */\n\n\n  addCursorFlag(flag, value) {\n    assertUninitialized(this);\n\n    if (!exports.CURSOR_FLAGS.includes(flag)) {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n    }\n\n    if (typeof value !== 'boolean') {\n      throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n    }\n\n    this[kOptions][flag] = value;\n    return this;\n  }\n  /**\n   * Map all documents using the provided function\n   * If there is a transform set on the cursor, that will be called first and the result passed to\n   * this function's transform.\n   *\n   * @remarks\n   * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n   * it **does not** return a new instance of a cursor. This means when calling map,\n   * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n   * Take note of the following example:\n   *\n   * @example\n   * ```typescript\n   * const cursor: FindCursor<Document> = coll.find();\n   * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n   * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n   * ```\n   * @param transform - The mapping transformation method.\n   */\n\n\n  map(transform) {\n    assertUninitialized(this);\n    const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n\n    if (oldTransform) {\n      this[kTransform] = doc => {\n        return transform(oldTransform(doc));\n      };\n    } else {\n      this[kTransform] = transform;\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadPreference(readPreference) {\n    assertUninitialized(this);\n\n    if (readPreference instanceof read_preference_1.ReadPreference) {\n      this[kOptions].readPreference = readPreference;\n    } else if (typeof readPreference === 'string') {\n      this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n    } else {\n      throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n    }\n\n    return this;\n  }\n  /**\n   * Set the ReadPreference for the cursor.\n   *\n   * @param readPreference - The new read preference for the cursor.\n   */\n\n\n  withReadConcern(readConcern) {\n    assertUninitialized(this);\n    const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n      readConcern\n    });\n\n    if (resolvedReadConcern) {\n      this[kOptions].readConcern = resolvedReadConcern;\n    }\n\n    return this;\n  }\n  /**\n   * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n   *\n   * @param value - Number of milliseconds to wait before aborting the query.\n   */\n\n\n  maxTimeMS(value) {\n    assertUninitialized(this);\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n    }\n\n    this[kOptions].maxTimeMS = value;\n    return this;\n  }\n  /**\n   * Set the batch size for the cursor.\n   *\n   * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n   */\n\n\n  batchSize(value) {\n    assertUninitialized(this);\n\n    if (this[kOptions].tailable) {\n      throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n    }\n\n    if (typeof value !== 'number') {\n      throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n    }\n\n    this[kOptions].batchSize = value;\n    return this;\n  }\n  /**\n   * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n   * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n   * if the resultant data has already been retrieved by this cursor.\n   */\n\n\n  rewind() {\n    if (!this[kInitialized]) {\n      return;\n    }\n\n    this[kId] = undefined;\n    this[kDocuments] = [];\n    this[kClosed] = false;\n    this[kKilled] = false;\n    this[kInitialized] = false;\n    const session = this[kSession];\n\n    if (session) {\n      // We only want to end this session if we created it, and it hasn't ended yet\n      if (session.explicit === false && !session.hasEnded) {\n        session.endSession();\n      }\n\n      this[kSession] = undefined;\n    }\n  }\n  /** @internal */\n\n\n  _getMore(batchSize, callback) {\n    const cursorId = this[kId];\n    const cursorNs = this[kNamespace];\n    const server = this[kServer];\n\n    if (cursorId == null) {\n      callback(new error_1.MongoRuntimeError('Unable to iterate cursor with no id'));\n      return;\n    }\n\n    if (server == null) {\n      callback(new error_1.MongoRuntimeError('Unable to iterate cursor without selected server'));\n      return;\n    }\n\n    server.getMore(cursorNs, cursorId, { ...this[kOptions],\n      session: this[kSession],\n      batchSize\n    }, callback);\n  }\n\n}\n\nexports.AbstractCursor = AbstractCursor;\n/** @event */\n\nAbstractCursor.CLOSE = 'close';\n\nfunction nextDocument(cursor) {\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n    return null;\n  }\n\n  const doc = cursor[kDocuments].shift();\n\n  if (doc) {\n    const transform = cursor[kTransform];\n\n    if (transform) {\n      return transform(doc);\n    }\n\n    return doc;\n  }\n\n  return null;\n}\n\nfunction next(cursor, blocking, callback) {\n  const cursorId = cursor[kId];\n\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    if (cursor[kSession] == null && cursor[kTopology].hasSessionSupport()) {\n      cursor[kSession] = cursor[kTopology].startSession({\n        owner: cursor,\n        explicit: false\n      });\n    }\n\n    cursor._initialize(cursor[kSession], (err, state) => {\n      if (state) {\n        const response = state.response;\n        cursor[kServer] = state.server;\n        cursor[kSession] = state.session;\n\n        if (response.cursor) {\n          cursor[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n\n          if (response.cursor.ns) {\n            cursor[kNamespace] = utils_1.ns(response.cursor.ns);\n          }\n\n          cursor[kDocuments] = response.cursor.firstBatch;\n        } else {\n          // NOTE: This is for support of older servers (<3.2) which do not use commands\n          cursor[kId] = typeof response.cursorId === 'number' ? bson_1.Long.fromNumber(response.cursorId) : response.cursorId;\n          cursor[kDocuments] = response.documents;\n        } // When server responses return without a cursor document, we close this cursor\n        // and return the raw server response. This is often the case for explain commands\n        // for example\n\n\n        if (cursor[kId] == null) {\n          cursor[kId] = bson_1.Long.ZERO; // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n\n          cursor[kDocuments] = [state.response];\n        }\n      } // the cursor is now initialized, even if an error occurred or it is dead\n\n\n      cursor[kInitialized] = true;\n\n      if (err || cursorIsDead(cursor)) {\n        return cleanupCursor(cursor, {\n          error: err\n        }, () => callback(err, nextDocument(cursor)));\n      }\n\n      next(cursor, blocking, callback);\n    });\n\n    return;\n  }\n\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n  } // otherwise need to call getMore\n\n\n  const batchSize = cursor[kOptions].batchSize || 1000;\n\n  cursor._getMore(batchSize, (err, response) => {\n    if (response) {\n      const cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n      cursor[kDocuments] = response.cursor.nextBatch;\n      cursor[kId] = cursorId;\n    }\n\n    if (err || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, {\n        error: err\n      }, () => callback(err, nextDocument(cursor)));\n    }\n\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n\n    next(cursor, blocking, callback);\n  });\n}\n\nfunction cursorIsDead(cursor) {\n  const cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\n\nfunction cleanupCursor(cursor, options, callback) {\n  var _a;\n\n  const cursorId = cursor[kId];\n  const cursorNs = cursor[kNamespace];\n  const server = cursor[kServer];\n  const session = cursor[kSession];\n  const error = options === null || options === void 0 ? void 0 : options.error;\n  const needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;\n\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, callback);\n      }\n\n      if (!session.inTransaction()) {\n        sessions_1.maybeClearPinnedConnection(session, {\n          error\n        });\n      }\n    }\n\n    return callback();\n  }\n\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error\n        }, () => {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n      }\n\n      if (!session.inTransaction()) {\n        sessions_1.maybeClearPinnedConnection(session, {\n          error\n        });\n      }\n    }\n\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n\n  cursor[kKilled] = true;\n  server.killCursors(cursorNs, [cursorId], { ...bson_1.pluckBSONSerializeOptions(cursor[kOptions]),\n    session\n  }, () => completeCleanup());\n}\n/** @internal */\n\n\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\n\nexports.assertUninitialized = assertUninitialized;\n\nfunction makeCursorStream(cursor) {\n  const readable = new stream_1.Readable({\n    objectMode: true,\n    autoDestroy: false,\n    highWaterMark: 1\n  });\n  let initialized = false;\n  let reading = false;\n  let needToClose = true; // NOTE: we must close the cursor if we never read from it, use `_construct` in future node versions\n\n  readable._read = function () {\n    if (initialized === false) {\n      needToClose = false;\n      initialized = true;\n    }\n\n    if (!reading) {\n      reading = true;\n      readNext();\n    }\n  };\n\n  readable._destroy = function (error, cb) {\n    if (needToClose) {\n      cursor.close(err => process.nextTick(cb, err || error));\n    } else {\n      cb(error);\n    }\n  };\n\n  function readNext() {\n    needToClose = false;\n    next(cursor, true, (err, result) => {\n      needToClose = err ? !cursor.closed : result != null;\n\n      if (err) {\n        // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n        //       desired behavior is that a stream ends cleanly when a user explicitly closes\n        //       a client during iteration. Alternatively, we could do the \"right\" thing and\n        //       propagate the error message by removing this special case.\n        if (err.message.match(/server is closed/)) {\n          cursor.close();\n          return readable.push(null);\n        } // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n        //       to be \"operation interrupted\", where a cursor has been closed but there is an\n        //       active getMore in-flight. This used to check if the cursor was killed but once\n        //       that changed to happen in cleanup legitimate errors would not destroy the\n        //       stream. There are change streams test specifically test these cases.\n\n\n        if (err.message.match(/interrupted/)) {\n          return readable.push(null);\n        }\n\n        return readable.destroy(err);\n      }\n\n      if (result == null) {\n        readable.push(null);\n      } else if (readable.destroyed) {\n        cursor.close();\n      } else {\n        if (readable.push(result)) {\n          return readNext();\n        }\n\n        reading = false;\n      }\n    });\n  }\n\n  return readable;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","assertUninitialized","AbstractCursor","CURSOR_FLAGS","utils_1","require","bson_1","sessions_1","error_1","read_preference_1","stream_1","read_concern_1","mongo_types_1","kId","Symbol","kDocuments","kServer","kNamespace","kTopology","kSession","kOptions","kTransform","kInitialized","kClosed","kKilled","TypedEventEmitter","constructor","topology","namespace","options","readPreference","ReadPreference","primary","pluckBSONSerializeOptions","readConcern","ReadConcern","fromOptions","batchSize","comment","maxTimeMS","session","ClientSession","id","server","clientSession","cursorOptions","closed","killed","loadBalanced","bufferedCount","length","readBufferedDocuments","number","splice","asyncIterator","next","then","done","undefined","stream","transform","readable","makeCursorStream","pipe","Transform","objectMode","highWaterMark","chunk","_","callback","transformed","err","hasNext","maybePromise","Long","ZERO","doc","unshift","MongoCursorExhaustedError","tryNext","forEach","iterator","MongoInvalidArgumentError","fetchDocs","result","error","internalDocs","i","close","needsToEmitClosed","cleanupCursor","toArray","docs","push","map","addCursorFlag","flag","includes","oldTransform","withReadPreference","fromString","withReadConcern","resolvedReadConcern","tailable","MongoTailableCursorError","rewind","explicit","hasEnded","endSession","_getMore","cursorId","cursorNs","MongoRuntimeError","getMore","CLOSE","nextDocument","cursor","shift","blocking","hasSessionSupport","startSession","owner","_initialize","state","response","fromNumber","ns","firstBatch","documents","cursorIsDead","nextBatch","isZero","_a","MongoNetworkError","completeCleanup","emit","inTransaction","maybeClearPinnedConnection","killCursors","MongoCursorInUseError","Readable","autoDestroy","initialized","reading","needToClose","_read","readNext","_destroy","cb","process","nextTick","message","match","destroy","destroyed"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/cursor/abstract_cursor.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.assertUninitialized = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nconst utils_1 = require(\"../utils\");\nconst bson_1 = require(\"../bson\");\nconst sessions_1 = require(\"../sessions\");\nconst error_1 = require(\"../error\");\nconst read_preference_1 = require(\"../read_preference\");\nconst stream_1 = require(\"stream\");\nconst read_concern_1 = require(\"../read_concern\");\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\nconst kId = Symbol('id');\n/** @internal */\nconst kDocuments = Symbol('documents');\n/** @internal */\nconst kServer = Symbol('server');\n/** @internal */\nconst kNamespace = Symbol('namespace');\n/** @internal */\nconst kTopology = Symbol('topology');\n/** @internal */\nconst kSession = Symbol('session');\n/** @internal */\nconst kOptions = Symbol('options');\n/** @internal */\nconst kTransform = Symbol('transform');\n/** @internal */\nconst kInitialized = Symbol('initialized');\n/** @internal */\nconst kClosed = Symbol('closed');\n/** @internal */\nconst kKilled = Symbol('killed');\n/** @public */\nexports.CURSOR_FLAGS = [\n    'tailable',\n    'oplogReplay',\n    'noCursorTimeout',\n    'awaitData',\n    'exhaust',\n    'partial'\n];\n/** @public */\nclass AbstractCursor extends mongo_types_1.TypedEventEmitter {\n    /** @internal */\n    constructor(topology, namespace, options = {}) {\n        super();\n        this[kTopology] = topology;\n        this[kNamespace] = namespace;\n        this[kDocuments] = []; // TODO: https://github.com/microsoft/TypeScript/issues/36230\n        this[kInitialized] = false;\n        this[kClosed] = false;\n        this[kKilled] = false;\n        this[kOptions] = {\n            readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference\n                ? options.readPreference\n                : read_preference_1.ReadPreference.primary,\n            ...bson_1.pluckBSONSerializeOptions(options)\n        };\n        const readConcern = read_concern_1.ReadConcern.fromOptions(options);\n        if (readConcern) {\n            this[kOptions].readConcern = readConcern;\n        }\n        if (typeof options.batchSize === 'number') {\n            this[kOptions].batchSize = options.batchSize;\n        }\n        if (options.comment != null) {\n            this[kOptions].comment = options.comment;\n        }\n        if (typeof options.maxTimeMS === 'number') {\n            this[kOptions].maxTimeMS = options.maxTimeMS;\n        }\n        if (options.session instanceof sessions_1.ClientSession) {\n            this[kSession] = options.session;\n        }\n    }\n    get id() {\n        return this[kId];\n    }\n    /** @internal */\n    get topology() {\n        return this[kTopology];\n    }\n    /** @internal */\n    get server() {\n        return this[kServer];\n    }\n    get namespace() {\n        return this[kNamespace];\n    }\n    get readPreference() {\n        return this[kOptions].readPreference;\n    }\n    get readConcern() {\n        return this[kOptions].readConcern;\n    }\n    /** @internal */\n    get session() {\n        return this[kSession];\n    }\n    set session(clientSession) {\n        this[kSession] = clientSession;\n    }\n    /** @internal */\n    get cursorOptions() {\n        return this[kOptions];\n    }\n    get closed() {\n        return this[kClosed];\n    }\n    get killed() {\n        return this[kKilled];\n    }\n    get loadBalanced() {\n        return this[kTopology].loadBalanced;\n    }\n    /** Returns current buffered documents length */\n    bufferedCount() {\n        return this[kDocuments].length;\n    }\n    /** Returns current buffered documents */\n    readBufferedDocuments(number) {\n        return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);\n    }\n    [Symbol.asyncIterator]() {\n        return {\n            next: () => this.next().then(value => value != null ? { value, done: false } : { value: undefined, done: true })\n        };\n    }\n    stream(options) {\n        if (options === null || options === void 0 ? void 0 : options.transform) {\n            const transform = options.transform;\n            const readable = makeCursorStream(this);\n            return readable.pipe(new stream_1.Transform({\n                objectMode: true,\n                highWaterMark: 1,\n                transform(chunk, _, callback) {\n                    try {\n                        const transformed = transform(chunk);\n                        callback(undefined, transformed);\n                    }\n                    catch (err) {\n                        callback(err);\n                    }\n                }\n            }));\n        }\n        return makeCursorStream(this);\n    }\n    hasNext(callback) {\n        return utils_1.maybePromise(callback, done => {\n            if (this[kId] === bson_1.Long.ZERO) {\n                return done(undefined, false);\n            }\n            if (this[kDocuments].length) {\n                return done(undefined, true);\n            }\n            next(this, true, (err, doc) => {\n                if (err)\n                    return done(err);\n                if (doc) {\n                    this[kDocuments].unshift(doc);\n                    done(undefined, true);\n                    return;\n                }\n                done(undefined, false);\n            });\n        });\n    }\n    next(callback) {\n        return utils_1.maybePromise(callback, done => {\n            if (this[kId] === bson_1.Long.ZERO) {\n                return done(new error_1.MongoCursorExhaustedError());\n            }\n            next(this, true, done);\n        });\n    }\n    tryNext(callback) {\n        return utils_1.maybePromise(callback, done => {\n            if (this[kId] === bson_1.Long.ZERO) {\n                return done(new error_1.MongoCursorExhaustedError());\n            }\n            next(this, false, done);\n        });\n    }\n    forEach(iterator, callback) {\n        if (typeof iterator !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n        }\n        return utils_1.maybePromise(callback, done => {\n            const transform = this[kTransform];\n            const fetchDocs = () => {\n                next(this, true, (err, doc) => {\n                    if (err || doc == null)\n                        return done(err);\n                    let result;\n                    // NOTE: no need to transform because `next` will do this automatically\n                    try {\n                        result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n                    }\n                    catch (error) {\n                        return done(error);\n                    }\n                    if (result === false)\n                        return done();\n                    // these do need to be transformed since they are copying the rest of the batch\n                    const internalDocs = this[kDocuments].splice(0, this[kDocuments].length);\n                    for (let i = 0; i < internalDocs.length; ++i) {\n                        try {\n                            result = iterator((transform ? transform(internalDocs[i]) : internalDocs[i]) // TODO(NODE-3283): Improve transform typing\n                            );\n                        }\n                        catch (error) {\n                            return done(error);\n                        }\n                        if (result === false)\n                            return done();\n                    }\n                    fetchDocs();\n                });\n            };\n            fetchDocs();\n        });\n    }\n    close(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        const needsToEmitClosed = !this[kClosed];\n        this[kClosed] = true;\n        return utils_1.maybePromise(callback, done => cleanupCursor(this, { needsToEmitClosed }, done));\n    }\n    toArray(callback) {\n        return utils_1.maybePromise(callback, done => {\n            const docs = [];\n            const transform = this[kTransform];\n            const fetchDocs = () => {\n                // NOTE: if we add a `nextBatch` then we should use it here\n                next(this, true, (err, doc) => {\n                    if (err)\n                        return done(err);\n                    if (doc == null)\n                        return done(undefined, docs);\n                    // NOTE: no need to transform because `next` will do this automatically\n                    docs.push(doc);\n                    // these do need to be transformed since they are copying the rest of the batch\n                    const internalDocs = (transform\n                        ? this[kDocuments].splice(0, this[kDocuments].length).map(transform)\n                        : this[kDocuments].splice(0, this[kDocuments].length)); // TODO(NODE-3283): Improve transform typing\n                    if (internalDocs) {\n                        docs.push(...internalDocs);\n                    }\n                    fetchDocs();\n                });\n            };\n            fetchDocs();\n        });\n    }\n    /**\n     * Add a cursor flag to the cursor\n     *\n     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n     * @param value - The flag boolean value.\n     */\n    addCursorFlag(flag, value) {\n        assertUninitialized(this);\n        if (!exports.CURSOR_FLAGS.includes(flag)) {\n            throw new error_1.MongoInvalidArgumentError(`Flag ${flag} is not one of ${exports.CURSOR_FLAGS}`);\n        }\n        if (typeof value !== 'boolean') {\n            throw new error_1.MongoInvalidArgumentError(`Flag ${flag} must be a boolean value`);\n        }\n        this[kOptions][flag] = value;\n        return this;\n    }\n    /**\n     * Map all documents using the provided function\n     * If there is a transform set on the cursor, that will be called first and the result passed to\n     * this function's transform.\n     *\n     * @remarks\n     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n     * it **does not** return a new instance of a cursor. This means when calling map,\n     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n     * Take note of the following example:\n     *\n     * @example\n     * ```typescript\n     * const cursor: FindCursor<Document> = coll.find();\n     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n     * ```\n     * @param transform - The mapping transformation method.\n     */\n    map(transform) {\n        assertUninitialized(this);\n        const oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n        if (oldTransform) {\n            this[kTransform] = doc => {\n                return transform(oldTransform(doc));\n            };\n        }\n        else {\n            this[kTransform] = transform;\n        }\n        return this;\n    }\n    /**\n     * Set the ReadPreference for the cursor.\n     *\n     * @param readPreference - The new read preference for the cursor.\n     */\n    withReadPreference(readPreference) {\n        assertUninitialized(this);\n        if (readPreference instanceof read_preference_1.ReadPreference) {\n            this[kOptions].readPreference = readPreference;\n        }\n        else if (typeof readPreference === 'string') {\n            this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n        }\n        else {\n            throw new error_1.MongoInvalidArgumentError(`Invalid read preference: ${readPreference}`);\n        }\n        return this;\n    }\n    /**\n     * Set the ReadPreference for the cursor.\n     *\n     * @param readPreference - The new read preference for the cursor.\n     */\n    withReadConcern(readConcern) {\n        assertUninitialized(this);\n        const resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({ readConcern });\n        if (resolvedReadConcern) {\n            this[kOptions].readConcern = resolvedReadConcern;\n        }\n        return this;\n    }\n    /**\n     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n     *\n     * @param value - Number of milliseconds to wait before aborting the query.\n     */\n    maxTimeMS(value) {\n        assertUninitialized(this);\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n        }\n        this[kOptions].maxTimeMS = value;\n        return this;\n    }\n    /**\n     * Set the batch size for the cursor.\n     *\n     * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n     */\n    batchSize(value) {\n        assertUninitialized(this);\n        if (this[kOptions].tailable) {\n            throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n        }\n        if (typeof value !== 'number') {\n            throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n        }\n        this[kOptions].batchSize = value;\n        return this;\n    }\n    /**\n     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n     * if the resultant data has already been retrieved by this cursor.\n     */\n    rewind() {\n        if (!this[kInitialized]) {\n            return;\n        }\n        this[kId] = undefined;\n        this[kDocuments] = [];\n        this[kClosed] = false;\n        this[kKilled] = false;\n        this[kInitialized] = false;\n        const session = this[kSession];\n        if (session) {\n            // We only want to end this session if we created it, and it hasn't ended yet\n            if (session.explicit === false && !session.hasEnded) {\n                session.endSession();\n            }\n            this[kSession] = undefined;\n        }\n    }\n    /** @internal */\n    _getMore(batchSize, callback) {\n        const cursorId = this[kId];\n        const cursorNs = this[kNamespace];\n        const server = this[kServer];\n        if (cursorId == null) {\n            callback(new error_1.MongoRuntimeError('Unable to iterate cursor with no id'));\n            return;\n        }\n        if (server == null) {\n            callback(new error_1.MongoRuntimeError('Unable to iterate cursor without selected server'));\n            return;\n        }\n        server.getMore(cursorNs, cursorId, {\n            ...this[kOptions],\n            session: this[kSession],\n            batchSize\n        }, callback);\n    }\n}\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nfunction nextDocument(cursor) {\n    if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n        return null;\n    }\n    const doc = cursor[kDocuments].shift();\n    if (doc) {\n        const transform = cursor[kTransform];\n        if (transform) {\n            return transform(doc);\n        }\n        return doc;\n    }\n    return null;\n}\nfunction next(cursor, blocking, callback) {\n    const cursorId = cursor[kId];\n    if (cursor.closed) {\n        return callback(undefined, null);\n    }\n    if (cursor[kDocuments] && cursor[kDocuments].length) {\n        callback(undefined, nextDocument(cursor));\n        return;\n    }\n    if (cursorId == null) {\n        // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n        if (cursor[kSession] == null && cursor[kTopology].hasSessionSupport()) {\n            cursor[kSession] = cursor[kTopology].startSession({ owner: cursor, explicit: false });\n        }\n        cursor._initialize(cursor[kSession], (err, state) => {\n            if (state) {\n                const response = state.response;\n                cursor[kServer] = state.server;\n                cursor[kSession] = state.session;\n                if (response.cursor) {\n                    cursor[kId] =\n                        typeof response.cursor.id === 'number'\n                            ? bson_1.Long.fromNumber(response.cursor.id)\n                            : response.cursor.id;\n                    if (response.cursor.ns) {\n                        cursor[kNamespace] = utils_1.ns(response.cursor.ns);\n                    }\n                    cursor[kDocuments] = response.cursor.firstBatch;\n                }\n                else {\n                    // NOTE: This is for support of older servers (<3.2) which do not use commands\n                    cursor[kId] =\n                        typeof response.cursorId === 'number'\n                            ? bson_1.Long.fromNumber(response.cursorId)\n                            : response.cursorId;\n                    cursor[kDocuments] = response.documents;\n                }\n                // When server responses return without a cursor document, we close this cursor\n                // and return the raw server response. This is often the case for explain commands\n                // for example\n                if (cursor[kId] == null) {\n                    cursor[kId] = bson_1.Long.ZERO;\n                    // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n                    cursor[kDocuments] = [state.response];\n                }\n            }\n            // the cursor is now initialized, even if an error occurred or it is dead\n            cursor[kInitialized] = true;\n            if (err || cursorIsDead(cursor)) {\n                return cleanupCursor(cursor, { error: err }, () => callback(err, nextDocument(cursor)));\n            }\n            next(cursor, blocking, callback);\n        });\n        return;\n    }\n    if (cursorIsDead(cursor)) {\n        return cleanupCursor(cursor, undefined, () => callback(undefined, null));\n    }\n    // otherwise need to call getMore\n    const batchSize = cursor[kOptions].batchSize || 1000;\n    cursor._getMore(batchSize, (err, response) => {\n        if (response) {\n            const cursorId = typeof response.cursor.id === 'number'\n                ? bson_1.Long.fromNumber(response.cursor.id)\n                : response.cursor.id;\n            cursor[kDocuments] = response.cursor.nextBatch;\n            cursor[kId] = cursorId;\n        }\n        if (err || cursorIsDead(cursor)) {\n            return cleanupCursor(cursor, { error: err }, () => callback(err, nextDocument(cursor)));\n        }\n        if (cursor[kDocuments].length === 0 && blocking === false) {\n            return callback(undefined, null);\n        }\n        next(cursor, blocking, callback);\n    });\n}\nfunction cursorIsDead(cursor) {\n    const cursorId = cursor[kId];\n    return !!cursorId && cursorId.isZero();\n}\nfunction cleanupCursor(cursor, options, callback) {\n    var _a;\n    const cursorId = cursor[kId];\n    const cursorNs = cursor[kNamespace];\n    const server = cursor[kServer];\n    const session = cursor[kSession];\n    const error = options === null || options === void 0 ? void 0 : options.error;\n    const needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;\n    if (error) {\n        if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n            return completeCleanup();\n        }\n    }\n    if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n        if (needsToEmitClosed) {\n            cursor[kClosed] = true;\n            cursor[kId] = bson_1.Long.ZERO;\n            cursor.emit(AbstractCursor.CLOSE);\n        }\n        if (session) {\n            if (session.owner === cursor) {\n                return session.endSession({ error }, callback);\n            }\n            if (!session.inTransaction()) {\n                sessions_1.maybeClearPinnedConnection(session, { error });\n            }\n        }\n        return callback();\n    }\n    function completeCleanup() {\n        if (session) {\n            if (session.owner === cursor) {\n                return session.endSession({ error }, () => {\n                    cursor.emit(AbstractCursor.CLOSE);\n                    callback();\n                });\n            }\n            if (!session.inTransaction()) {\n                sessions_1.maybeClearPinnedConnection(session, { error });\n            }\n        }\n        cursor.emit(AbstractCursor.CLOSE);\n        return callback();\n    }\n    cursor[kKilled] = true;\n    server.killCursors(cursorNs, [cursorId], { ...bson_1.pluckBSONSerializeOptions(cursor[kOptions]), session }, () => completeCleanup());\n}\n/** @internal */\nfunction assertUninitialized(cursor) {\n    if (cursor[kInitialized]) {\n        throw new error_1.MongoCursorInUseError();\n    }\n}\nexports.assertUninitialized = assertUninitialized;\nfunction makeCursorStream(cursor) {\n    const readable = new stream_1.Readable({\n        objectMode: true,\n        autoDestroy: false,\n        highWaterMark: 1\n    });\n    let initialized = false;\n    let reading = false;\n    let needToClose = true; // NOTE: we must close the cursor if we never read from it, use `_construct` in future node versions\n    readable._read = function () {\n        if (initialized === false) {\n            needToClose = false;\n            initialized = true;\n        }\n        if (!reading) {\n            reading = true;\n            readNext();\n        }\n    };\n    readable._destroy = function (error, cb) {\n        if (needToClose) {\n            cursor.close(err => process.nextTick(cb, err || error));\n        }\n        else {\n            cb(error);\n        }\n    };\n    function readNext() {\n        needToClose = false;\n        next(cursor, true, (err, result) => {\n            needToClose = err ? !cursor.closed : result != null;\n            if (err) {\n                // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n                //       desired behavior is that a stream ends cleanly when a user explicitly closes\n                //       a client during iteration. Alternatively, we could do the \"right\" thing and\n                //       propagate the error message by removing this special case.\n                if (err.message.match(/server is closed/)) {\n                    cursor.close();\n                    return readable.push(null);\n                }\n                // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n                //       to be \"operation interrupted\", where a cursor has been closed but there is an\n                //       active getMore in-flight. This used to check if the cursor was killed but once\n                //       that changed to happen in cleanup legitimate errors would not destroy the\n                //       stream. There are change streams test specifically test these cases.\n                if (err.message.match(/interrupted/)) {\n                    return readable.push(null);\n                }\n                return readable.destroy(err);\n            }\n            if (result == null) {\n                readable.push(null);\n            }\n            else if (readable.destroyed) {\n                cursor.close();\n            }\n            else {\n                if (readable.push(result)) {\n                    return readNext();\n                }\n                reading = false;\n            }\n        });\n    }\n    return readable;\n}\n"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;EAAEC,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,mBAAR,GAA8BF,OAAO,CAACG,cAAR,GAAyBH,OAAO,CAACI,YAAR,GAAuB,KAAK,CAAnF;;AACA,MAAMC,OAAO,GAAGC,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,SAAD,CAAtB;;AACA,MAAME,UAAU,GAAGF,OAAO,CAAC,aAAD,CAA1B;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMI,iBAAiB,GAAGJ,OAAO,CAAC,oBAAD,CAAjC;;AACA,MAAMK,QAAQ,GAAGL,OAAO,CAAC,QAAD,CAAxB;;AACA,MAAMM,cAAc,GAAGN,OAAO,CAAC,iBAAD,CAA9B;;AACA,MAAMO,aAAa,GAAGP,OAAO,CAAC,gBAAD,CAA7B;AACA;;;AACA,MAAMQ,GAAG,GAAGC,MAAM,CAAC,IAAD,CAAlB;AACA;;AACA,MAAMC,UAAU,GAAGD,MAAM,CAAC,WAAD,CAAzB;AACA;;AACA,MAAME,OAAO,GAAGF,MAAM,CAAC,QAAD,CAAtB;AACA;;AACA,MAAMG,UAAU,GAAGH,MAAM,CAAC,WAAD,CAAzB;AACA;;AACA,MAAMI,SAAS,GAAGJ,MAAM,CAAC,UAAD,CAAxB;AACA;;AACA,MAAMK,QAAQ,GAAGL,MAAM,CAAC,SAAD,CAAvB;AACA;;AACA,MAAMM,QAAQ,GAAGN,MAAM,CAAC,SAAD,CAAvB;AACA;;AACA,MAAMO,UAAU,GAAGP,MAAM,CAAC,WAAD,CAAzB;AACA;;AACA,MAAMQ,YAAY,GAAGR,MAAM,CAAC,aAAD,CAA3B;AACA;;AACA,MAAMS,OAAO,GAAGT,MAAM,CAAC,QAAD,CAAtB;AACA;;AACA,MAAMU,OAAO,GAAGV,MAAM,CAAC,QAAD,CAAtB;AACA;;AACAf,OAAO,CAACI,YAAR,GAAuB,CACnB,UADmB,EAEnB,aAFmB,EAGnB,iBAHmB,EAInB,WAJmB,EAKnB,SALmB,EAMnB,SANmB,CAAvB;AAQA;;AACA,MAAMD,cAAN,SAA6BU,aAAa,CAACa,iBAA3C,CAA6D;EACzD;EACAC,WAAW,CAACC,QAAD,EAAWC,SAAX,EAAsBC,OAAO,GAAG,EAAhC,EAAoC;IAC3C;IACA,KAAKX,SAAL,IAAkBS,QAAlB;IACA,KAAKV,UAAL,IAAmBW,SAAnB;IACA,KAAKb,UAAL,IAAmB,EAAnB,CAJ2C,CAIpB;;IACvB,KAAKO,YAAL,IAAqB,KAArB;IACA,KAAKC,OAAL,IAAgB,KAAhB;IACA,KAAKC,OAAL,IAAgB,KAAhB;IACA,KAAKJ,QAAL,IAAiB;MACbU,cAAc,EAAED,OAAO,CAACC,cAAR,IAA0BD,OAAO,CAACC,cAAR,YAAkCrB,iBAAiB,CAACsB,cAA9E,GACVF,OAAO,CAACC,cADE,GAEVrB,iBAAiB,CAACsB,cAAlB,CAAiCC,OAH1B;MAIb,GAAG1B,MAAM,CAAC2B,yBAAP,CAAiCJ,OAAjC;IAJU,CAAjB;IAMA,MAAMK,WAAW,GAAGvB,cAAc,CAACwB,WAAf,CAA2BC,WAA3B,CAAuCP,OAAvC,CAApB;;IACA,IAAIK,WAAJ,EAAiB;MACb,KAAKd,QAAL,EAAec,WAAf,GAA6BA,WAA7B;IACH;;IACD,IAAI,OAAOL,OAAO,CAACQ,SAAf,KAA6B,QAAjC,EAA2C;MACvC,KAAKjB,QAAL,EAAeiB,SAAf,GAA2BR,OAAO,CAACQ,SAAnC;IACH;;IACD,IAAIR,OAAO,CAACS,OAAR,IAAmB,IAAvB,EAA6B;MACzB,KAAKlB,QAAL,EAAekB,OAAf,GAAyBT,OAAO,CAACS,OAAjC;IACH;;IACD,IAAI,OAAOT,OAAO,CAACU,SAAf,KAA6B,QAAjC,EAA2C;MACvC,KAAKnB,QAAL,EAAemB,SAAf,GAA2BV,OAAO,CAACU,SAAnC;IACH;;IACD,IAAIV,OAAO,CAACW,OAAR,YAA2BjC,UAAU,CAACkC,aAA1C,EAAyD;MACrD,KAAKtB,QAAL,IAAiBU,OAAO,CAACW,OAAzB;IACH;EACJ;;EACK,IAAFE,EAAE,GAAG;IACL,OAAO,KAAK7B,GAAL,CAAP;EACH;EACD;;;EACY,IAARc,QAAQ,GAAG;IACX,OAAO,KAAKT,SAAL,CAAP;EACH;EACD;;;EACU,IAANyB,MAAM,GAAG;IACT,OAAO,KAAK3B,OAAL,CAAP;EACH;;EACY,IAATY,SAAS,GAAG;IACZ,OAAO,KAAKX,UAAL,CAAP;EACH;;EACiB,IAAda,cAAc,GAAG;IACjB,OAAO,KAAKV,QAAL,EAAeU,cAAtB;EACH;;EACc,IAAXI,WAAW,GAAG;IACd,OAAO,KAAKd,QAAL,EAAec,WAAtB;EACH;EACD;;;EACW,IAAPM,OAAO,GAAG;IACV,OAAO,KAAKrB,QAAL,CAAP;EACH;;EACU,IAAPqB,OAAO,CAACI,aAAD,EAAgB;IACvB,KAAKzB,QAAL,IAAiByB,aAAjB;EACH;EACD;;;EACiB,IAAbC,aAAa,GAAG;IAChB,OAAO,KAAKzB,QAAL,CAAP;EACH;;EACS,IAAN0B,MAAM,GAAG;IACT,OAAO,KAAKvB,OAAL,CAAP;EACH;;EACS,IAANwB,MAAM,GAAG;IACT,OAAO,KAAKvB,OAAL,CAAP;EACH;;EACe,IAAZwB,YAAY,GAAG;IACf,OAAO,KAAK9B,SAAL,EAAgB8B,YAAvB;EACH;EACD;;;EACAC,aAAa,GAAG;IACZ,OAAO,KAAKlC,UAAL,EAAiBmC,MAAxB;EACH;EACD;;;EACAC,qBAAqB,CAACC,MAAD,EAAS;IAC1B,OAAO,KAAKrC,UAAL,EAAiBsC,MAAjB,CAAwB,CAAxB,EAA2BD,MAAM,KAAK,IAAX,IAAmBA,MAAM,KAAK,KAAK,CAAnC,GAAuCA,MAAvC,GAAgD,KAAKrC,UAAL,EAAiBmC,MAA5F,CAAP;EACH;;EACoB,CAApBpC,MAAM,CAACwC,aAAa,IAAI;IACrB,OAAO;MACHC,IAAI,EAAE,MAAM,KAAKA,IAAL,GAAYC,IAAZ,CAAiBxD,KAAK,IAAIA,KAAK,IAAI,IAAT,GAAgB;QAAEA,KAAF;QAASyD,IAAI,EAAE;MAAf,CAAhB,GAAyC;QAAEzD,KAAK,EAAE0D,SAAT;QAAoBD,IAAI,EAAE;MAA1B,CAAnE;IADT,CAAP;EAGH;;EACDE,MAAM,CAAC9B,OAAD,EAAU;IACZ,IAAIA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC+B,SAA9D,EAAyE;MACrE,MAAMA,SAAS,GAAG/B,OAAO,CAAC+B,SAA1B;MACA,MAAMC,QAAQ,GAAGC,gBAAgB,CAAC,IAAD,CAAjC;MACA,OAAOD,QAAQ,CAACE,IAAT,CAAc,IAAIrD,QAAQ,CAACsD,SAAb,CAAuB;QACxCC,UAAU,EAAE,IAD4B;QAExCC,aAAa,EAAE,CAFyB;;QAGxCN,SAAS,CAACO,KAAD,EAAQC,CAAR,EAAWC,QAAX,EAAqB;UAC1B,IAAI;YACA,MAAMC,WAAW,GAAGV,SAAS,CAACO,KAAD,CAA7B;YACAE,QAAQ,CAACX,SAAD,EAAYY,WAAZ,CAAR;UACH,CAHD,CAIA,OAAOC,GAAP,EAAY;YACRF,QAAQ,CAACE,GAAD,CAAR;UACH;QACJ;;MAXuC,CAAvB,CAAd,CAAP;IAaH;;IACD,OAAOT,gBAAgB,CAAC,IAAD,CAAvB;EACH;;EACDU,OAAO,CAACH,QAAD,EAAW;IACd,OAAOjE,OAAO,CAACqE,YAAR,CAAqBJ,QAArB,EAA+BZ,IAAI,IAAI;MAC1C,IAAI,KAAK5C,GAAL,MAAcP,MAAM,CAACoE,IAAP,CAAYC,IAA9B,EAAoC;QAChC,OAAOlB,IAAI,CAACC,SAAD,EAAY,KAAZ,CAAX;MACH;;MACD,IAAI,KAAK3C,UAAL,EAAiBmC,MAArB,EAA6B;QACzB,OAAOO,IAAI,CAACC,SAAD,EAAY,IAAZ,CAAX;MACH;;MACDH,IAAI,CAAC,IAAD,EAAO,IAAP,EAAa,CAACgB,GAAD,EAAMK,GAAN,KAAc;QAC3B,IAAIL,GAAJ,EACI,OAAOd,IAAI,CAACc,GAAD,CAAX;;QACJ,IAAIK,GAAJ,EAAS;UACL,KAAK7D,UAAL,EAAiB8D,OAAjB,CAAyBD,GAAzB;UACAnB,IAAI,CAACC,SAAD,EAAY,IAAZ,CAAJ;UACA;QACH;;QACDD,IAAI,CAACC,SAAD,EAAY,KAAZ,CAAJ;MACH,CATG,CAAJ;IAUH,CAjBM,CAAP;EAkBH;;EACDH,IAAI,CAACc,QAAD,EAAW;IACX,OAAOjE,OAAO,CAACqE,YAAR,CAAqBJ,QAArB,EAA+BZ,IAAI,IAAI;MAC1C,IAAI,KAAK5C,GAAL,MAAcP,MAAM,CAACoE,IAAP,CAAYC,IAA9B,EAAoC;QAChC,OAAOlB,IAAI,CAAC,IAAIjD,OAAO,CAACsE,yBAAZ,EAAD,CAAX;MACH;;MACDvB,IAAI,CAAC,IAAD,EAAO,IAAP,EAAaE,IAAb,CAAJ;IACH,CALM,CAAP;EAMH;;EACDsB,OAAO,CAACV,QAAD,EAAW;IACd,OAAOjE,OAAO,CAACqE,YAAR,CAAqBJ,QAArB,EAA+BZ,IAAI,IAAI;MAC1C,IAAI,KAAK5C,GAAL,MAAcP,MAAM,CAACoE,IAAP,CAAYC,IAA9B,EAAoC;QAChC,OAAOlB,IAAI,CAAC,IAAIjD,OAAO,CAACsE,yBAAZ,EAAD,CAAX;MACH;;MACDvB,IAAI,CAAC,IAAD,EAAO,KAAP,EAAcE,IAAd,CAAJ;IACH,CALM,CAAP;EAMH;;EACDuB,OAAO,CAACC,QAAD,EAAWZ,QAAX,EAAqB;IACxB,IAAI,OAAOY,QAAP,KAAoB,UAAxB,EAAoC;MAChC,MAAM,IAAIzE,OAAO,CAAC0E,yBAAZ,CAAsC,wCAAtC,CAAN;IACH;;IACD,OAAO9E,OAAO,CAACqE,YAAR,CAAqBJ,QAArB,EAA+BZ,IAAI,IAAI;MAC1C,MAAMG,SAAS,GAAG,KAAKvC,UAAL,CAAlB;;MACA,MAAM8D,SAAS,GAAG,MAAM;QACpB5B,IAAI,CAAC,IAAD,EAAO,IAAP,EAAa,CAACgB,GAAD,EAAMK,GAAN,KAAc;UAC3B,IAAIL,GAAG,IAAIK,GAAG,IAAI,IAAlB,EACI,OAAOnB,IAAI,CAACc,GAAD,CAAX;UACJ,IAAIa,MAAJ,CAH2B,CAI3B;;UACA,IAAI;YACAA,MAAM,GAAGH,QAAQ,CAACL,GAAD,CAAjB,CADA,CACwB;UAC3B,CAFD,CAGA,OAAOS,KAAP,EAAc;YACV,OAAO5B,IAAI,CAAC4B,KAAD,CAAX;UACH;;UACD,IAAID,MAAM,KAAK,KAAf,EACI,OAAO3B,IAAI,EAAX,CAZuB,CAa3B;;UACA,MAAM6B,YAAY,GAAG,KAAKvE,UAAL,EAAiBsC,MAAjB,CAAwB,CAAxB,EAA2B,KAAKtC,UAAL,EAAiBmC,MAA5C,CAArB;;UACA,KAAK,IAAIqC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,YAAY,CAACpC,MAAjC,EAAyC,EAAEqC,CAA3C,EAA8C;YAC1C,IAAI;cACAH,MAAM,GAAGH,QAAQ,CAAErB,SAAS,GAAGA,SAAS,CAAC0B,YAAY,CAACC,CAAD,CAAb,CAAZ,GAAgCD,YAAY,CAACC,CAAD,CAAvD,CAA4D;cAA5D,CAAjB;YAEH,CAHD,CAIA,OAAOF,KAAP,EAAc;cACV,OAAO5B,IAAI,CAAC4B,KAAD,CAAX;YACH;;YACD,IAAID,MAAM,KAAK,KAAf,EACI,OAAO3B,IAAI,EAAX;UACP;;UACD0B,SAAS;QACZ,CA3BG,CAAJ;MA4BH,CA7BD;;MA8BAA,SAAS;IACZ,CAjCM,CAAP;EAkCH;;EACDK,KAAK,CAAC3D,OAAD,EAAUwC,QAAV,EAAoB;IACrB,IAAI,OAAOxC,OAAP,KAAmB,UAAvB,EACKwC,QAAQ,GAAGxC,OAAZ,EAAuBA,OAAO,GAAG,EAAjC;IACJA,OAAO,GAAGA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyCA,OAAzC,GAAmD,EAA7D;IACA,MAAM4D,iBAAiB,GAAG,CAAC,KAAKlE,OAAL,CAA3B;IACA,KAAKA,OAAL,IAAgB,IAAhB;IACA,OAAOnB,OAAO,CAACqE,YAAR,CAAqBJ,QAArB,EAA+BZ,IAAI,IAAIiC,aAAa,CAAC,IAAD,EAAO;MAAED;IAAF,CAAP,EAA8BhC,IAA9B,CAApD,CAAP;EACH;;EACDkC,OAAO,CAACtB,QAAD,EAAW;IACd,OAAOjE,OAAO,CAACqE,YAAR,CAAqBJ,QAArB,EAA+BZ,IAAI,IAAI;MAC1C,MAAMmC,IAAI,GAAG,EAAb;MACA,MAAMhC,SAAS,GAAG,KAAKvC,UAAL,CAAlB;;MACA,MAAM8D,SAAS,GAAG,MAAM;QACpB;QACA5B,IAAI,CAAC,IAAD,EAAO,IAAP,EAAa,CAACgB,GAAD,EAAMK,GAAN,KAAc;UAC3B,IAAIL,GAAJ,EACI,OAAOd,IAAI,CAACc,GAAD,CAAX;UACJ,IAAIK,GAAG,IAAI,IAAX,EACI,OAAOnB,IAAI,CAACC,SAAD,EAAYkC,IAAZ,CAAX,CAJuB,CAK3B;;UACAA,IAAI,CAACC,IAAL,CAAUjB,GAAV,EAN2B,CAO3B;;UACA,MAAMU,YAAY,GAAI1B,SAAS,GACzB,KAAK7C,UAAL,EAAiBsC,MAAjB,CAAwB,CAAxB,EAA2B,KAAKtC,UAAL,EAAiBmC,MAA5C,EAAoD4C,GAApD,CAAwDlC,SAAxD,CADyB,GAEzB,KAAK7C,UAAL,EAAiBsC,MAAjB,CAAwB,CAAxB,EAA2B,KAAKtC,UAAL,EAAiBmC,MAA5C,CAFN,CAR2B,CAUiC;;UAC5D,IAAIoC,YAAJ,EAAkB;YACdM,IAAI,CAACC,IAAL,CAAU,GAAGP,YAAb;UACH;;UACDH,SAAS;QACZ,CAfG,CAAJ;MAgBH,CAlBD;;MAmBAA,SAAS;IACZ,CAvBM,CAAP;EAwBH;EACD;AACJ;AACA;AACA;AACA;AACA;;;EACIY,aAAa,CAACC,IAAD,EAAOhG,KAAP,EAAc;IACvBC,mBAAmB,CAAC,IAAD,CAAnB;;IACA,IAAI,CAACF,OAAO,CAACI,YAAR,CAAqB8F,QAArB,CAA8BD,IAA9B,CAAL,EAA0C;MACtC,MAAM,IAAIxF,OAAO,CAAC0E,yBAAZ,CAAuC,QAAOc,IAAK,kBAAiBjG,OAAO,CAACI,YAAa,EAAzF,CAAN;IACH;;IACD,IAAI,OAAOH,KAAP,KAAiB,SAArB,EAAgC;MAC5B,MAAM,IAAIQ,OAAO,CAAC0E,yBAAZ,CAAuC,QAAOc,IAAK,0BAAnD,CAAN;IACH;;IACD,KAAK5E,QAAL,EAAe4E,IAAf,IAAuBhG,KAAvB;IACA,OAAO,IAAP;EACH;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACI8F,GAAG,CAAClC,SAAD,EAAY;IACX3D,mBAAmB,CAAC,IAAD,CAAnB;IACA,MAAMiG,YAAY,GAAG,KAAK7E,UAAL,CAArB,CAFW,CAE4B;;IACvC,IAAI6E,YAAJ,EAAkB;MACd,KAAK7E,UAAL,IAAmBuD,GAAG,IAAI;QACtB,OAAOhB,SAAS,CAACsC,YAAY,CAACtB,GAAD,CAAb,CAAhB;MACH,CAFD;IAGH,CAJD,MAKK;MACD,KAAKvD,UAAL,IAAmBuC,SAAnB;IACH;;IACD,OAAO,IAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACIuC,kBAAkB,CAACrE,cAAD,EAAiB;IAC/B7B,mBAAmB,CAAC,IAAD,CAAnB;;IACA,IAAI6B,cAAc,YAAYrB,iBAAiB,CAACsB,cAAhD,EAAgE;MAC5D,KAAKX,QAAL,EAAeU,cAAf,GAAgCA,cAAhC;IACH,CAFD,MAGK,IAAI,OAAOA,cAAP,KAA0B,QAA9B,EAAwC;MACzC,KAAKV,QAAL,EAAeU,cAAf,GAAgCrB,iBAAiB,CAACsB,cAAlB,CAAiCqE,UAAjC,CAA4CtE,cAA5C,CAAhC;IACH,CAFI,MAGA;MACD,MAAM,IAAItB,OAAO,CAAC0E,yBAAZ,CAAuC,4BAA2BpD,cAAe,EAAjF,CAAN;IACH;;IACD,OAAO,IAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACIuE,eAAe,CAACnE,WAAD,EAAc;IACzBjC,mBAAmB,CAAC,IAAD,CAAnB;IACA,MAAMqG,mBAAmB,GAAG3F,cAAc,CAACwB,WAAf,CAA2BC,WAA3B,CAAuC;MAAEF;IAAF,CAAvC,CAA5B;;IACA,IAAIoE,mBAAJ,EAAyB;MACrB,KAAKlF,QAAL,EAAec,WAAf,GAA6BoE,mBAA7B;IACH;;IACD,OAAO,IAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACI/D,SAAS,CAACvC,KAAD,EAAQ;IACbC,mBAAmB,CAAC,IAAD,CAAnB;;IACA,IAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;MAC3B,MAAM,IAAIQ,OAAO,CAAC0E,yBAAZ,CAAsC,yCAAtC,CAAN;IACH;;IACD,KAAK9D,QAAL,EAAemB,SAAf,GAA2BvC,KAA3B;IACA,OAAO,IAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACIqC,SAAS,CAACrC,KAAD,EAAQ;IACbC,mBAAmB,CAAC,IAAD,CAAnB;;IACA,IAAI,KAAKmB,QAAL,EAAemF,QAAnB,EAA6B;MACzB,MAAM,IAAI/F,OAAO,CAACgG,wBAAZ,CAAqC,4CAArC,CAAN;IACH;;IACD,IAAI,OAAOxG,KAAP,KAAiB,QAArB,EAA+B;MAC3B,MAAM,IAAIQ,OAAO,CAAC0E,yBAAZ,CAAsC,2CAAtC,CAAN;IACH;;IACD,KAAK9D,QAAL,EAAeiB,SAAf,GAA2BrC,KAA3B;IACA,OAAO,IAAP;EACH;EACD;AACJ;AACA;AACA;AACA;;;EACIyG,MAAM,GAAG;IACL,IAAI,CAAC,KAAKnF,YAAL,CAAL,EAAyB;MACrB;IACH;;IACD,KAAKT,GAAL,IAAY6C,SAAZ;IACA,KAAK3C,UAAL,IAAmB,EAAnB;IACA,KAAKQ,OAAL,IAAgB,KAAhB;IACA,KAAKC,OAAL,IAAgB,KAAhB;IACA,KAAKF,YAAL,IAAqB,KAArB;IACA,MAAMkB,OAAO,GAAG,KAAKrB,QAAL,CAAhB;;IACA,IAAIqB,OAAJ,EAAa;MACT;MACA,IAAIA,OAAO,CAACkE,QAAR,KAAqB,KAArB,IAA8B,CAAClE,OAAO,CAACmE,QAA3C,EAAqD;QACjDnE,OAAO,CAACoE,UAAR;MACH;;MACD,KAAKzF,QAAL,IAAiBuC,SAAjB;IACH;EACJ;EACD;;;EACAmD,QAAQ,CAACxE,SAAD,EAAYgC,QAAZ,EAAsB;IAC1B,MAAMyC,QAAQ,GAAG,KAAKjG,GAAL,CAAjB;IACA,MAAMkG,QAAQ,GAAG,KAAK9F,UAAL,CAAjB;IACA,MAAM0B,MAAM,GAAG,KAAK3B,OAAL,CAAf;;IACA,IAAI8F,QAAQ,IAAI,IAAhB,EAAsB;MAClBzC,QAAQ,CAAC,IAAI7D,OAAO,CAACwG,iBAAZ,CAA8B,qCAA9B,CAAD,CAAR;MACA;IACH;;IACD,IAAIrE,MAAM,IAAI,IAAd,EAAoB;MAChB0B,QAAQ,CAAC,IAAI7D,OAAO,CAACwG,iBAAZ,CAA8B,kDAA9B,CAAD,CAAR;MACA;IACH;;IACDrE,MAAM,CAACsE,OAAP,CAAeF,QAAf,EAAyBD,QAAzB,EAAmC,EAC/B,GAAG,KAAK1F,QAAL,CAD4B;MAE/BoB,OAAO,EAAE,KAAKrB,QAAL,CAFsB;MAG/BkB;IAH+B,CAAnC,EAIGgC,QAJH;EAKH;;AA7WwD;;AA+W7DtE,OAAO,CAACG,cAAR,GAAyBA,cAAzB;AACA;;AACAA,cAAc,CAACgH,KAAf,GAAuB,OAAvB;;AACA,SAASC,YAAT,CAAsBC,MAAtB,EAA8B;EAC1B,IAAIA,MAAM,CAACrG,UAAD,CAAN,IAAsB,IAAtB,IAA8B,CAACqG,MAAM,CAACrG,UAAD,CAAN,CAAmBmC,MAAtD,EAA8D;IAC1D,OAAO,IAAP;EACH;;EACD,MAAM0B,GAAG,GAAGwC,MAAM,CAACrG,UAAD,CAAN,CAAmBsG,KAAnB,EAAZ;;EACA,IAAIzC,GAAJ,EAAS;IACL,MAAMhB,SAAS,GAAGwD,MAAM,CAAC/F,UAAD,CAAxB;;IACA,IAAIuC,SAAJ,EAAe;MACX,OAAOA,SAAS,CAACgB,GAAD,CAAhB;IACH;;IACD,OAAOA,GAAP;EACH;;EACD,OAAO,IAAP;AACH;;AACD,SAASrB,IAAT,CAAc6D,MAAd,EAAsBE,QAAtB,EAAgCjD,QAAhC,EAA0C;EACtC,MAAMyC,QAAQ,GAAGM,MAAM,CAACvG,GAAD,CAAvB;;EACA,IAAIuG,MAAM,CAACtE,MAAX,EAAmB;IACf,OAAOuB,QAAQ,CAACX,SAAD,EAAY,IAAZ,CAAf;EACH;;EACD,IAAI0D,MAAM,CAACrG,UAAD,CAAN,IAAsBqG,MAAM,CAACrG,UAAD,CAAN,CAAmBmC,MAA7C,EAAqD;IACjDmB,QAAQ,CAACX,SAAD,EAAYyD,YAAY,CAACC,MAAD,CAAxB,CAAR;IACA;EACH;;EACD,IAAIN,QAAQ,IAAI,IAAhB,EAAsB;IAClB;IACA,IAAIM,MAAM,CAACjG,QAAD,CAAN,IAAoB,IAApB,IAA4BiG,MAAM,CAAClG,SAAD,CAAN,CAAkBqG,iBAAlB,EAAhC,EAAuE;MACnEH,MAAM,CAACjG,QAAD,CAAN,GAAmBiG,MAAM,CAAClG,SAAD,CAAN,CAAkBsG,YAAlB,CAA+B;QAAEC,KAAK,EAAEL,MAAT;QAAiBV,QAAQ,EAAE;MAA3B,CAA/B,CAAnB;IACH;;IACDU,MAAM,CAACM,WAAP,CAAmBN,MAAM,CAACjG,QAAD,CAAzB,EAAqC,CAACoD,GAAD,EAAMoD,KAAN,KAAgB;MACjD,IAAIA,KAAJ,EAAW;QACP,MAAMC,QAAQ,GAAGD,KAAK,CAACC,QAAvB;QACAR,MAAM,CAACpG,OAAD,CAAN,GAAkB2G,KAAK,CAAChF,MAAxB;QACAyE,MAAM,CAACjG,QAAD,CAAN,GAAmBwG,KAAK,CAACnF,OAAzB;;QACA,IAAIoF,QAAQ,CAACR,MAAb,EAAqB;UACjBA,MAAM,CAACvG,GAAD,CAAN,GACI,OAAO+G,QAAQ,CAACR,MAAT,CAAgB1E,EAAvB,KAA8B,QAA9B,GACMpC,MAAM,CAACoE,IAAP,CAAYmD,UAAZ,CAAuBD,QAAQ,CAACR,MAAT,CAAgB1E,EAAvC,CADN,GAEMkF,QAAQ,CAACR,MAAT,CAAgB1E,EAH1B;;UAIA,IAAIkF,QAAQ,CAACR,MAAT,CAAgBU,EAApB,EAAwB;YACpBV,MAAM,CAACnG,UAAD,CAAN,GAAqBb,OAAO,CAAC0H,EAAR,CAAWF,QAAQ,CAACR,MAAT,CAAgBU,EAA3B,CAArB;UACH;;UACDV,MAAM,CAACrG,UAAD,CAAN,GAAqB6G,QAAQ,CAACR,MAAT,CAAgBW,UAArC;QACH,CATD,MAUK;UACD;UACAX,MAAM,CAACvG,GAAD,CAAN,GACI,OAAO+G,QAAQ,CAACd,QAAhB,KAA6B,QAA7B,GACMxG,MAAM,CAACoE,IAAP,CAAYmD,UAAZ,CAAuBD,QAAQ,CAACd,QAAhC,CADN,GAEMc,QAAQ,CAACd,QAHnB;UAIAM,MAAM,CAACrG,UAAD,CAAN,GAAqB6G,QAAQ,CAACI,SAA9B;QACH,CArBM,CAsBP;QACA;QACA;;;QACA,IAAIZ,MAAM,CAACvG,GAAD,CAAN,IAAe,IAAnB,EAAyB;UACrBuG,MAAM,CAACvG,GAAD,CAAN,GAAcP,MAAM,CAACoE,IAAP,CAAYC,IAA1B,CADqB,CAErB;;UACAyC,MAAM,CAACrG,UAAD,CAAN,GAAqB,CAAC4G,KAAK,CAACC,QAAP,CAArB;QACH;MACJ,CA/BgD,CAgCjD;;;MACAR,MAAM,CAAC9F,YAAD,CAAN,GAAuB,IAAvB;;MACA,IAAIiD,GAAG,IAAI0D,YAAY,CAACb,MAAD,CAAvB,EAAiC;QAC7B,OAAO1B,aAAa,CAAC0B,MAAD,EAAS;UAAE/B,KAAK,EAAEd;QAAT,CAAT,EAAyB,MAAMF,QAAQ,CAACE,GAAD,EAAM4C,YAAY,CAACC,MAAD,CAAlB,CAAvC,CAApB;MACH;;MACD7D,IAAI,CAAC6D,MAAD,EAASE,QAAT,EAAmBjD,QAAnB,CAAJ;IACH,CAtCD;;IAuCA;EACH;;EACD,IAAI4D,YAAY,CAACb,MAAD,CAAhB,EAA0B;IACtB,OAAO1B,aAAa,CAAC0B,MAAD,EAAS1D,SAAT,EAAoB,MAAMW,QAAQ,CAACX,SAAD,EAAY,IAAZ,CAAlC,CAApB;EACH,CAzDqC,CA0DtC;;;EACA,MAAMrB,SAAS,GAAG+E,MAAM,CAAChG,QAAD,CAAN,CAAiBiB,SAAjB,IAA8B,IAAhD;;EACA+E,MAAM,CAACP,QAAP,CAAgBxE,SAAhB,EAA2B,CAACkC,GAAD,EAAMqD,QAAN,KAAmB;IAC1C,IAAIA,QAAJ,EAAc;MACV,MAAMd,QAAQ,GAAG,OAAOc,QAAQ,CAACR,MAAT,CAAgB1E,EAAvB,KAA8B,QAA9B,GACXpC,MAAM,CAACoE,IAAP,CAAYmD,UAAZ,CAAuBD,QAAQ,CAACR,MAAT,CAAgB1E,EAAvC,CADW,GAEXkF,QAAQ,CAACR,MAAT,CAAgB1E,EAFtB;MAGA0E,MAAM,CAACrG,UAAD,CAAN,GAAqB6G,QAAQ,CAACR,MAAT,CAAgBc,SAArC;MACAd,MAAM,CAACvG,GAAD,CAAN,GAAciG,QAAd;IACH;;IACD,IAAIvC,GAAG,IAAI0D,YAAY,CAACb,MAAD,CAAvB,EAAiC;MAC7B,OAAO1B,aAAa,CAAC0B,MAAD,EAAS;QAAE/B,KAAK,EAAEd;MAAT,CAAT,EAAyB,MAAMF,QAAQ,CAACE,GAAD,EAAM4C,YAAY,CAACC,MAAD,CAAlB,CAAvC,CAApB;IACH;;IACD,IAAIA,MAAM,CAACrG,UAAD,CAAN,CAAmBmC,MAAnB,KAA8B,CAA9B,IAAmCoE,QAAQ,KAAK,KAApD,EAA2D;MACvD,OAAOjD,QAAQ,CAACX,SAAD,EAAY,IAAZ,CAAf;IACH;;IACDH,IAAI,CAAC6D,MAAD,EAASE,QAAT,EAAmBjD,QAAnB,CAAJ;EACH,CAfD;AAgBH;;AACD,SAAS4D,YAAT,CAAsBb,MAAtB,EAA8B;EAC1B,MAAMN,QAAQ,GAAGM,MAAM,CAACvG,GAAD,CAAvB;EACA,OAAO,CAAC,CAACiG,QAAF,IAAcA,QAAQ,CAACqB,MAAT,EAArB;AACH;;AACD,SAASzC,aAAT,CAAuB0B,MAAvB,EAA+BvF,OAA/B,EAAwCwC,QAAxC,EAAkD;EAC9C,IAAI+D,EAAJ;;EACA,MAAMtB,QAAQ,GAAGM,MAAM,CAACvG,GAAD,CAAvB;EACA,MAAMkG,QAAQ,GAAGK,MAAM,CAACnG,UAAD,CAAvB;EACA,MAAM0B,MAAM,GAAGyE,MAAM,CAACpG,OAAD,CAArB;EACA,MAAMwB,OAAO,GAAG4E,MAAM,CAACjG,QAAD,CAAtB;EACA,MAAMkE,KAAK,GAAGxD,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACwD,KAAxE;EACA,MAAMI,iBAAiB,GAAG,CAAC2C,EAAE,GAAGvG,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAAC4D,iBAAhE,MAAuF,IAAvF,IAA+F2C,EAAE,KAAK,KAAK,CAA3G,GAA+GA,EAA/G,GAAoHhB,MAAM,CAACrG,UAAD,CAAN,CAAmBmC,MAAnB,KAA8B,CAA5K;;EACA,IAAImC,KAAJ,EAAW;IACP,IAAI+B,MAAM,CAACpE,YAAP,IAAuBqC,KAAK,YAAY7E,OAAO,CAAC6H,iBAApD,EAAuE;MACnE,OAAOC,eAAe,EAAtB;IACH;EACJ;;EACD,IAAIxB,QAAQ,IAAI,IAAZ,IAAoBnE,MAAM,IAAI,IAA9B,IAAsCmE,QAAQ,CAACqB,MAAT,EAAtC,IAA2DpB,QAAQ,IAAI,IAA3E,EAAiF;IAC7E,IAAItB,iBAAJ,EAAuB;MACnB2B,MAAM,CAAC7F,OAAD,CAAN,GAAkB,IAAlB;MACA6F,MAAM,CAACvG,GAAD,CAAN,GAAcP,MAAM,CAACoE,IAAP,CAAYC,IAA1B;MACAyC,MAAM,CAACmB,IAAP,CAAYrI,cAAc,CAACgH,KAA3B;IACH;;IACD,IAAI1E,OAAJ,EAAa;MACT,IAAIA,OAAO,CAACiF,KAAR,KAAkBL,MAAtB,EAA8B;QAC1B,OAAO5E,OAAO,CAACoE,UAAR,CAAmB;UAAEvB;QAAF,CAAnB,EAA8BhB,QAA9B,CAAP;MACH;;MACD,IAAI,CAAC7B,OAAO,CAACgG,aAAR,EAAL,EAA8B;QAC1BjI,UAAU,CAACkI,0BAAX,CAAsCjG,OAAtC,EAA+C;UAAE6C;QAAF,CAA/C;MACH;IACJ;;IACD,OAAOhB,QAAQ,EAAf;EACH;;EACD,SAASiE,eAAT,GAA2B;IACvB,IAAI9F,OAAJ,EAAa;MACT,IAAIA,OAAO,CAACiF,KAAR,KAAkBL,MAAtB,EAA8B;QAC1B,OAAO5E,OAAO,CAACoE,UAAR,CAAmB;UAAEvB;QAAF,CAAnB,EAA8B,MAAM;UACvC+B,MAAM,CAACmB,IAAP,CAAYrI,cAAc,CAACgH,KAA3B;UACA7C,QAAQ;QACX,CAHM,CAAP;MAIH;;MACD,IAAI,CAAC7B,OAAO,CAACgG,aAAR,EAAL,EAA8B;QAC1BjI,UAAU,CAACkI,0BAAX,CAAsCjG,OAAtC,EAA+C;UAAE6C;QAAF,CAA/C;MACH;IACJ;;IACD+B,MAAM,CAACmB,IAAP,CAAYrI,cAAc,CAACgH,KAA3B;IACA,OAAO7C,QAAQ,EAAf;EACH;;EACD+C,MAAM,CAAC5F,OAAD,CAAN,GAAkB,IAAlB;EACAmB,MAAM,CAAC+F,WAAP,CAAmB3B,QAAnB,EAA6B,CAACD,QAAD,CAA7B,EAAyC,EAAE,GAAGxG,MAAM,CAAC2B,yBAAP,CAAiCmF,MAAM,CAAChG,QAAD,CAAvC,CAAL;IAAyDoB;EAAzD,CAAzC,EAA6G,MAAM8F,eAAe,EAAlI;AACH;AACD;;;AACA,SAASrI,mBAAT,CAA6BmH,MAA7B,EAAqC;EACjC,IAAIA,MAAM,CAAC9F,YAAD,CAAV,EAA0B;IACtB,MAAM,IAAId,OAAO,CAACmI,qBAAZ,EAAN;EACH;AACJ;;AACD5I,OAAO,CAACE,mBAAR,GAA8BA,mBAA9B;;AACA,SAAS6D,gBAAT,CAA0BsD,MAA1B,EAAkC;EAC9B,MAAMvD,QAAQ,GAAG,IAAInD,QAAQ,CAACkI,QAAb,CAAsB;IACnC3E,UAAU,EAAE,IADuB;IAEnC4E,WAAW,EAAE,KAFsB;IAGnC3E,aAAa,EAAE;EAHoB,CAAtB,CAAjB;EAKA,IAAI4E,WAAW,GAAG,KAAlB;EACA,IAAIC,OAAO,GAAG,KAAd;EACA,IAAIC,WAAW,GAAG,IAAlB,CAR8B,CAQN;;EACxBnF,QAAQ,CAACoF,KAAT,GAAiB,YAAY;IACzB,IAAIH,WAAW,KAAK,KAApB,EAA2B;MACvBE,WAAW,GAAG,KAAd;MACAF,WAAW,GAAG,IAAd;IACH;;IACD,IAAI,CAACC,OAAL,EAAc;MACVA,OAAO,GAAG,IAAV;MACAG,QAAQ;IACX;EACJ,CATD;;EAUArF,QAAQ,CAACsF,QAAT,GAAoB,UAAU9D,KAAV,EAAiB+D,EAAjB,EAAqB;IACrC,IAAIJ,WAAJ,EAAiB;MACb5B,MAAM,CAAC5B,KAAP,CAAajB,GAAG,IAAI8E,OAAO,CAACC,QAAR,CAAiBF,EAAjB,EAAqB7E,GAAG,IAAIc,KAA5B,CAApB;IACH,CAFD,MAGK;MACD+D,EAAE,CAAC/D,KAAD,CAAF;IACH;EACJ,CAPD;;EAQA,SAAS6D,QAAT,GAAoB;IAChBF,WAAW,GAAG,KAAd;IACAzF,IAAI,CAAC6D,MAAD,EAAS,IAAT,EAAe,CAAC7C,GAAD,EAAMa,MAAN,KAAiB;MAChC4D,WAAW,GAAGzE,GAAG,GAAG,CAAC6C,MAAM,CAACtE,MAAX,GAAoBsC,MAAM,IAAI,IAA/C;;MACA,IAAIb,GAAJ,EAAS;QACL;QACA;QACA;QACA;QACA,IAAIA,GAAG,CAACgF,OAAJ,CAAYC,KAAZ,CAAkB,kBAAlB,CAAJ,EAA2C;UACvCpC,MAAM,CAAC5B,KAAP;UACA,OAAO3B,QAAQ,CAACgC,IAAT,CAAc,IAAd,CAAP;QACH,CARI,CASL;QACA;QACA;QACA;QACA;;;QACA,IAAItB,GAAG,CAACgF,OAAJ,CAAYC,KAAZ,CAAkB,aAAlB,CAAJ,EAAsC;UAClC,OAAO3F,QAAQ,CAACgC,IAAT,CAAc,IAAd,CAAP;QACH;;QACD,OAAOhC,QAAQ,CAAC4F,OAAT,CAAiBlF,GAAjB,CAAP;MACH;;MACD,IAAIa,MAAM,IAAI,IAAd,EAAoB;QAChBvB,QAAQ,CAACgC,IAAT,CAAc,IAAd;MACH,CAFD,MAGK,IAAIhC,QAAQ,CAAC6F,SAAb,EAAwB;QACzBtC,MAAM,CAAC5B,KAAP;MACH,CAFI,MAGA;QACD,IAAI3B,QAAQ,CAACgC,IAAT,CAAcT,MAAd,CAAJ,EAA2B;UACvB,OAAO8D,QAAQ,EAAf;QACH;;QACDH,OAAO,GAAG,KAAV;MACH;IACJ,CAjCG,CAAJ;EAkCH;;EACD,OAAOlF,QAAP;AACH"},"metadata":{},"sourceType":"script"}