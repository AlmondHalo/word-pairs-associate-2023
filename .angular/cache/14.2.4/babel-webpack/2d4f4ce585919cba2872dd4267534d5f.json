{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.collectionNamespace = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.executeLegacyOperation = exports.filterOptions = exports.mergeOptions = exports.decorateCommand = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.getSingleProperty = exports.MAX_JS_INT = void 0;\nexports.parsePackageVersion = exports.supportsRetryableWrites = void 0;\n\nconst os = require(\"os\");\n\nconst crypto = require(\"crypto\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst error_1 = require(\"./error\");\n\nconst write_concern_1 = require(\"./write_concern\");\n\nconst common_1 = require(\"./sdam/common\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst bson_1 = require(\"./bson\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst url_1 = require(\"url\");\n\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\n\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Add a readonly enumerable property.\n * @internal\n */\n\nfunction getSingleProperty(obj, name, value) {\n  Object.defineProperty(obj, name, {\n    enumerable: true,\n\n    get() {\n      return value;\n    }\n\n  });\n}\n\nexports.getSingleProperty = getSingleProperty;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\n\nfunction checkCollectionName(collectionName) {\n  if ('string' !== typeof collectionName) {\n    throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n  }\n\n  if (!collectionName || collectionName.indexOf('..') !== -1) {\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n  }\n\n  if (collectionName.indexOf('$') !== -1 && collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n  }\n\n  if (collectionName.match(/^\\.|\\.$/) != null) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n  } // Validate that we are not passing 0x00 in the collection name\n\n\n  if (collectionName.indexOf('\\x00') !== -1) {\n    // TODO(NODE-3483): Use MongoNamespace static method\n    throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n  }\n}\n\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\n\nfunction normalizeHintField(hint) {\n  let finalHint = undefined;\n\n  if (typeof hint === 'string') {\n    finalHint = hint;\n  } else if (Array.isArray(hint)) {\n    finalHint = {};\n    hint.forEach(param => {\n      finalHint[param] = 1;\n    });\n  } else if (hint != null && typeof hint === 'object') {\n    finalHint = {};\n\n    for (const name in hint) {\n      finalHint[name] = hint[name];\n    }\n  }\n\n  return finalHint;\n}\n\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\n\nfunction parseIndexOptions(indexSpec) {\n  const fieldHash = {};\n  const indexes = [];\n  let keys; // Get all the fields accordingly\n\n  if ('string' === typeof indexSpec) {\n    // 'type'\n    indexes.push(indexSpec + '_' + 1);\n    fieldHash[indexSpec] = 1;\n  } else if (Array.isArray(indexSpec)) {\n    indexSpec.forEach(f => {\n      if ('string' === typeof f) {\n        // [{location:'2d'}, 'type']\n        indexes.push(f + '_' + 1);\n        fieldHash[f] = 1;\n      } else if (Array.isArray(f)) {\n        // [['location', '2d'],['type', 1]]\n        indexes.push(f[0] + '_' + (f[1] || 1));\n        fieldHash[f[0]] = f[1] || 1;\n      } else if (isObject(f)) {\n        // [{location:'2d'}, {type:1}]\n        keys = Object.keys(f);\n        keys.forEach(k => {\n          indexes.push(k + '_' + f[k]);\n          fieldHash[k] = f[k];\n        });\n      } else {// undefined (ignore)\n      }\n    });\n  } else if (isObject(indexSpec)) {\n    // {location:'2d', type:1}\n    keys = Object.keys(indexSpec);\n    Object.entries(indexSpec).forEach(([key, value]) => {\n      indexes.push(key + '_' + value);\n      fieldHash[key] = value;\n    });\n  }\n\n  return {\n    name: indexes.join('_'),\n    keys: keys,\n    fieldHash: fieldHash\n  };\n}\n\nexports.parseIndexOptions = parseIndexOptions;\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\n\nfunction isObject(arg) {\n  return '[object Object]' === Object.prototype.toString.call(arg);\n}\n\nexports.isObject = isObject;\n/** @internal */\n\nfunction decorateCommand(command, options, exclude) {\n  for (const name in options) {\n    if (!exclude.includes(name)) {\n      command[name] = options[name];\n    }\n  }\n\n  return command;\n}\n\nexports.decorateCommand = decorateCommand;\n/** @internal */\n\nfunction mergeOptions(target, source) {\n  return { ...target,\n    ...source\n  };\n}\n\nexports.mergeOptions = mergeOptions;\n/** @internal */\n\nfunction filterOptions(options, names) {\n  const filterOptions = {};\n\n  for (const name in options) {\n    if (names.includes(name)) {\n      filterOptions[name] = options[name];\n    }\n  } // Filtered options\n\n\n  return filterOptions;\n}\n\nexports.filterOptions = filterOptions;\n/**\n * Executes the given operation with provided arguments.\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @internal\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param args - Arguments to apply the provided operation\n * @param options - Options that modify the behavior of the method\n */\n\nfunction executeLegacyOperation(topology, operation, args, options) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n\n  if (!Array.isArray(args)) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('This method requires an array of arguments to apply');\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  let callback = args[args.length - 1]; // The driver sessions spec mandates that we implicitly create sessions for operations\n  // that are not explicitly provided with a session.\n\n  let session;\n  let opOptions;\n  let owner;\n\n  if (!options.skipSessions && topology.hasSessionSupport()) {\n    opOptions = args[args.length - 2];\n\n    if (opOptions == null || opOptions.session == null) {\n      owner = Symbol();\n      session = topology.startSession({\n        owner\n      });\n      const optionsIndex = args.length - 2;\n      args[optionsIndex] = Object.assign({}, args[optionsIndex], {\n        session: session\n      });\n    } else if (opOptions.session && opOptions.session.hasEnded) {\n      throw new error_1.MongoExpiredSessionError();\n    }\n  }\n\n  function makeExecuteCallback(resolve, reject) {\n    return function (err, result) {\n      if (session && session.owner === owner && !(options === null || options === void 0 ? void 0 : options.returnsCursor)) {\n        session.endSession(() => {\n          delete opOptions.session;\n          if (err) return reject(err);\n          resolve(result);\n        });\n      } else {\n        if (err) return reject(err);\n        resolve(result);\n      }\n    };\n  } // Execute using callback\n\n\n  if (typeof callback === 'function') {\n    callback = args.pop();\n    const handler = makeExecuteCallback(result => callback(undefined, result), err => callback(err, null));\n    args.push(handler);\n\n    try {\n      return operation(...args);\n    } catch (e) {\n      handler(e);\n      throw e;\n    }\n  } // Return a Promise\n\n\n  if (args[args.length - 1] != null) {\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError('Final argument to `executeLegacyOperation` must be a callback');\n  }\n\n  return new Promise((resolve, reject) => {\n    const handler = makeExecuteCallback(resolve, reject);\n    args[args.length - 1] = handler;\n\n    try {\n      return operation(...args);\n    } catch (e) {\n      handler(e);\n    }\n  });\n}\n\nexports.executeLegacyOperation = executeLegacyOperation;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\n\nfunction applyRetryableWrites(target, db) {\n  var _a;\n\n  if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n    target.retryWrites = true;\n  }\n\n  return target;\n}\n\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\n\nfunction applyWriteConcern(target, sources, options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const db = sources.db;\n  const coll = sources.collection;\n\n  if (options.session && options.session.inTransaction()) {\n    // writeConcern is not allowed within a multi-statement transaction\n    if (target.writeConcern) {\n      delete target.writeConcern;\n    }\n\n    return target;\n  }\n\n  const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n\n  if (writeConcern) {\n    return Object.assign(target, {\n      writeConcern\n    });\n  }\n\n  if (coll && coll.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, coll.writeConcern)\n    });\n  }\n\n  if (db && db.writeConcern) {\n    return Object.assign(target, {\n      writeConcern: Object.assign({}, db.writeConcern)\n    });\n  }\n\n  return target;\n}\n\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\n\nfunction isPromiseLike(maybePromise) {\n  return !!maybePromise && typeof maybePromise.then === 'function';\n}\n\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\n\nfunction decorateWithCollation(command, target, options) {\n  const capabilities = getTopology(target).capabilities;\n\n  if (options.collation && typeof options.collation === 'object') {\n    if (capabilities && capabilities.commandsTakeCollation) {\n      command.collation = options.collation;\n    } else {\n      throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n    }\n  }\n}\n\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\n\nfunction decorateWithReadConcern(command, coll, options) {\n  if (options && options.session && options.session.inTransaction()) {\n    return;\n  }\n\n  const readConcern = Object.assign({}, command.readConcern || {});\n\n  if (coll.s.readConcern) {\n    Object.assign(readConcern, coll.s.readConcern);\n  }\n\n  if (Object.keys(readConcern).length > 0) {\n    Object.assign(command, {\n      readConcern: readConcern\n    });\n  }\n}\n\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\n\nfunction decorateWithExplain(command, explain) {\n  if (command.explain) {\n    return command;\n  }\n\n  return {\n    explain: command,\n    verbosity: explain.verbosity\n  };\n}\n\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @internal\n */\n\nfunction getTopology(provider) {\n  if (`topology` in provider && provider.topology) {\n    return provider.topology;\n  } else if ('client' in provider.s && provider.s.client.topology) {\n    return provider.s.client.topology;\n  } else if ('db' in provider.s && provider.s.db.s.client.topology) {\n    return provider.s.db.s.client.topology;\n  }\n\n  throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\n\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\n\nfunction defaultMsgHandler(name, option) {\n  return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\n\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\n\nfunction deprecateOptions(config, fn) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n  const optionsWarned = new Set();\n\n  function deprecated(...args) {\n    const options = args[config.optionsIndex]; // ensure options is a valid, non-empty object, otherwise short-circuit\n\n    if (!isObject(options) || Object.keys(options).length === 0) {\n      return fn.bind(this)(...args); // call the function, no change\n    } // interrupt the function call with a warning\n\n\n    for (const deprecatedOption of config.deprecatedOptions) {\n      if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n        optionsWarned.add(deprecatedOption);\n        const msg = msgHandler(config.name, deprecatedOption);\n        emitWarning(msg);\n\n        if (this && 'getLogger' in this) {\n          const logger = this.getLogger();\n\n          if (logger) {\n            logger.warn(msg);\n          }\n        }\n      }\n    }\n\n    return fn.bind(this)(...args);\n  } // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n\n\n  Object.setPrototypeOf(deprecated, fn);\n\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype, as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\n\nfunction ns(ns) {\n  return MongoDBNamespace.fromString(ns);\n}\n\nexports.ns = ns;\n/** @public */\n\nclass MongoDBNamespace {\n  /**\n   * Create a namespace object\n   *\n   * @param db - database name\n   * @param collection - collection name\n   */\n  constructor(db, collection) {\n    this.db = db;\n    this.collection = collection;\n  }\n\n  toString() {\n    return this.collection ? `${this.db}.${this.collection}` : this.db;\n  }\n\n  withCollection(collection) {\n    return new MongoDBNamespace(this.db, collection);\n  }\n\n  static fromString(namespace) {\n    if (!namespace) {\n      // TODO(NODE-3483): Replace with MongoNamespaceError\n      throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n    }\n\n    const [db, ...collection] = namespace.split('.');\n    return new MongoDBNamespace(db, collection.join('.'));\n  }\n\n}\n\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\n\nfunction* makeCounter(seed = 0) {\n  let count = seed;\n\n  while (true) {\n    const newCount = count;\n    count += 1;\n    yield newCount;\n  }\n}\n\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\n\nfunction maybePromise(callback, wrapper) {\n  const Promise = promise_provider_1.PromiseProvider.get();\n  let result;\n\n  if (typeof callback !== 'function') {\n    result = new Promise((resolve, reject) => {\n      callback = (err, res) => {\n        if (err) return reject(err);\n        resolve(res);\n      };\n    });\n  }\n\n  wrapper((err, res) => {\n    if (err != null) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err);\n      } catch (error) {\n        process.nextTick(() => {\n          throw error;\n        });\n      }\n\n      return;\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    callback(err, res);\n  });\n  return result;\n}\n\nexports.maybePromise = maybePromise;\n/** @internal */\n\nfunction databaseNamespace(ns) {\n  return ns.split('.')[0];\n}\n\nexports.databaseNamespace = databaseNamespace;\n/** @internal */\n\nfunction collectionNamespace(ns) {\n  return ns.split('.').slice(1).join('.');\n}\n\nexports.collectionNamespace = collectionNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\n\nfunction uuidV4() {\n  const result = crypto.randomBytes(16);\n  result[6] = result[6] & 0x0f | 0x40;\n  result[8] = result[8] & 0x3f | 0x80;\n  return result;\n}\n\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\n\nfunction maxWireVersion(topologyOrServer) {\n  if (topologyOrServer) {\n    if (topologyOrServer.loadBalanced) {\n      // Since we do not have a monitor, we assume the load balanced server is always\n      // pointed at the latest mongodb version. There is a risk that for on-prem\n      // deployments that don't upgrade immediately that this could alert to the\n      // application that a feature is avaiable that is actually not.\n      return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    }\n\n    if (topologyOrServer.ismaster) {\n      return topologyOrServer.ismaster.maxWireVersion;\n    }\n\n    if ('lastIsMaster' in topologyOrServer && typeof topologyOrServer.lastIsMaster === 'function') {\n      const lastIsMaster = topologyOrServer.lastIsMaster();\n\n      if (lastIsMaster) {\n        return lastIsMaster.maxWireVersion;\n      }\n    }\n\n    if (topologyOrServer.description && 'maxWireVersion' in topologyOrServer.description && topologyOrServer.description.maxWireVersion != null) {\n      return topologyOrServer.description.maxWireVersion;\n    }\n  }\n\n  return 0;\n}\n\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\n\nfunction collationNotSupported(server, cmd) {\n  return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\n\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\n\nfunction eachAsync(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = 0;\n\n  for (idx = 0; idx < arr.length; ++idx) {\n    awaiting++;\n    eachFn(arr[idx], eachCallback);\n  }\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n    }\n  }\n}\n\nexports.eachAsync = eachAsync;\n/** @internal */\n\nfunction eachAsyncSeries(arr, eachFn, callback) {\n  arr = arr || [];\n  let idx = 0;\n  let awaiting = arr.length;\n\n  if (awaiting === 0) {\n    callback();\n    return;\n  }\n\n  function eachCallback(err) {\n    idx++;\n    awaiting--;\n\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (idx === arr.length && awaiting <= 0) {\n      callback();\n      return;\n    }\n\n    eachFn(arr[idx], eachCallback);\n  }\n\n  eachFn(arr[idx], eachCallback);\n}\n\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\n\nfunction arrayStrictEqual(arr, arr2) {\n  if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n    return false;\n  }\n\n  return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\n\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\n\nfunction errorStrictEqual(lhs, rhs) {\n  if (lhs === rhs) {\n    return true;\n  }\n\n  if (!lhs || !rhs) {\n    return lhs === rhs;\n  }\n\n  if (lhs == null && rhs != null || lhs != null && rhs == null) {\n    return false;\n  }\n\n  if (lhs.constructor.name !== rhs.constructor.name) {\n    return false;\n  }\n\n  if (lhs.message !== rhs.message) {\n    return false;\n  }\n\n  return true;\n}\n\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\n\nfunction makeStateMachine(stateTable) {\n  return function stateTransition(target, newState) {\n    const legalStates = stateTable[target.s.state];\n\n    if (legalStates && legalStates.indexOf(newState) < 0) {\n      throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n    }\n\n    target.emit('stateChanged', target.s.state, newState);\n    target.s.state = newState;\n  };\n}\n\nexports.makeStateMachine = makeStateMachine; // eslint-disable-next-line @typescript-eslint/no-var-requires\n\nconst NODE_DRIVER_VERSION = require('../package.json').version;\n\nfunction makeClientMetadata(options) {\n  options = options !== null && options !== void 0 ? options : {};\n  const metadata = {\n    driver: {\n      name: 'nodejs',\n      version: NODE_DRIVER_VERSION\n    },\n    os: {\n      type: os.type(),\n      name: process.platform,\n      architecture: process.arch,\n      version: os.release()\n    },\n    platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n  }; // support optionally provided wrapping driver info\n\n  if (options.driverInfo) {\n    if (options.driverInfo.name) {\n      metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n    }\n\n    if (options.driverInfo.version) {\n      metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n    }\n\n    if (options.driverInfo.platform) {\n      metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n    }\n  }\n\n  if (options.appName) {\n    // MongoDB requires the appName not exceed a byte length of 128\n    const buffer = Buffer.from(options.appName);\n    metadata.application = {\n      name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n    };\n  }\n\n  return metadata;\n}\n\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\n\nfunction now() {\n  const hrtime = process.hrtime();\n  return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\n\nexports.now = now;\n/** @internal */\n\nfunction calculateDurationInMs(started) {\n  if (typeof started !== 'number') {\n    throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n  }\n\n  const elapsed = now() - started;\n  return elapsed < 0 ? 0 : elapsed;\n}\n\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\n\nfunction makeInterruptibleAsyncInterval(fn, options) {\n  let timerId;\n  let lastCallTime;\n  let lastWakeTime;\n  let stopped = false;\n  options = options !== null && options !== void 0 ? options : {};\n  const interval = options.interval || 1000;\n  const minInterval = options.minInterval || 500;\n  const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n  const clock = typeof options.clock === 'function' ? options.clock : now;\n\n  function wake() {\n    const currentTime = clock();\n    const timeSinceLastWake = currentTime - lastWakeTime;\n    const timeSinceLastCall = currentTime - lastCallTime;\n    const timeUntilNextCall = interval - timeSinceLastCall;\n    lastWakeTime = currentTime; // For the streaming protocol: there is nothing obviously stopping this\n    // interval from being woken up again while we are waiting \"infinitely\"\n    // for `fn` to be called again`. Since the function effectively\n    // never completes, the `timeUntilNextCall` will continue to grow\n    // negatively unbounded, so it will never trigger a reschedule here.\n    // debounce multiple calls to wake within the `minInterval`\n\n    if (timeSinceLastWake < minInterval) {\n      return;\n    } // reschedule a call as soon as possible, ensuring the call never happens\n    // faster than the `minInterval`\n\n\n    if (timeUntilNextCall > minInterval) {\n      reschedule(minInterval);\n    } // This is possible in virtualized environments like AWS Lambda where our\n    // clock is unreliable. In these cases the timer is \"running\" but never\n    // actually completes, so we want to execute immediately and then attempt\n    // to reschedule.\n\n\n    if (timeUntilNextCall < 0) {\n      executeAndReschedule();\n    }\n  }\n\n  function stop() {\n    stopped = true;\n\n    if (timerId) {\n      clearTimeout(timerId);\n      timerId = undefined;\n    }\n\n    lastCallTime = 0;\n    lastWakeTime = 0;\n  }\n\n  function reschedule(ms) {\n    if (stopped) return;\n\n    if (timerId) {\n      clearTimeout(timerId);\n    }\n\n    timerId = setTimeout(executeAndReschedule, ms || interval);\n  }\n\n  function executeAndReschedule() {\n    lastWakeTime = 0;\n    lastCallTime = clock();\n    fn(err => {\n      if (err) throw err;\n      reschedule(interval);\n    });\n  }\n\n  if (immediate) {\n    executeAndReschedule();\n  } else {\n    lastCallTime = clock();\n    reschedule(undefined);\n  }\n\n  return {\n    wake,\n    stop\n  };\n}\n\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\n\nfunction hasAtomicOperators(doc) {\n  if (Array.isArray(doc)) {\n    for (const document of doc) {\n      if (hasAtomicOperators(document)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  const keys = Object.keys(doc);\n  return keys.length > 0 && keys[0][0] === '$';\n}\n\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\n\nfunction resolveOptions(parent, options) {\n  var _a, _b, _c;\n\n  const result = Object.assign({}, options, bson_1.resolveBSONOptions(options, parent)); // Users cannot pass a readConcern/writeConcern to operations in a transaction\n\n  const session = options === null || options === void 0 ? void 0 : options.session;\n\n  if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n\n    if (readConcern) {\n      result.readConcern = readConcern;\n    }\n\n    const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n\n    if (writeConcern) {\n      result.writeConcern = writeConcern;\n    }\n  }\n\n  const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n\n  if (readPreference) {\n    result.readPreference = readPreference;\n  }\n\n  return result;\n}\n\nexports.resolveOptions = resolveOptions;\n\nfunction isSuperset(set, subset) {\n  set = Array.isArray(set) ? new Set(set) : set;\n  subset = Array.isArray(subset) ? new Set(subset) : subset;\n\n  for (const elem of subset) {\n    if (!set.has(elem)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isSuperset = isSuperset;\n\nfunction setDifference(setA, setB) {\n  const difference = new Set(setA);\n\n  for (const elem of setB) {\n    difference.delete(elem);\n  }\n\n  return difference;\n}\n\nexports.setDifference = setDifference;\n\nfunction isRecord(value, requiredKeys = undefined) {\n  const toString = Object.prototype.toString;\n  const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  const isObject = v => toString.call(v) === '[object Object]';\n\n  if (!isObject(value)) {\n    return false;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor && ctor.prototype) {\n    if (!isObject(ctor.prototype)) {\n      return false;\n    } // Check to see if some method exists from the Object exists\n\n\n    if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n      return false;\n    }\n  }\n\n  if (requiredKeys) {\n    const keys = Object.keys(value);\n    return isSuperset(keys, requiredKeys);\n  }\n\n  return true;\n}\n\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\n\nfunction deepCopy(value) {\n  if (value == null) {\n    return value;\n  } else if (Array.isArray(value)) {\n    return value.map(item => deepCopy(item));\n  } else if (isRecord(value)) {\n    const res = {};\n\n    for (const key in value) {\n      res[key] = deepCopy(value[key]);\n    }\n\n    return res;\n  }\n\n  const ctor = value.constructor;\n\n  if (ctor) {\n    switch (ctor.name.toLowerCase()) {\n      case 'date':\n        return new ctor(Number(value));\n\n      case 'map':\n        return new Map(value);\n\n      case 'set':\n        return new Set(value);\n\n      case 'buffer':\n        return Buffer.from(value);\n    }\n  }\n\n  return value;\n}\n\nexports.deepCopy = deepCopy;\n/** @internal */\n\nconst kBuffers = Symbol('buffers');\n/** @internal */\n\nconst kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\n\nclass BufferPool {\n  constructor() {\n    this[kBuffers] = [];\n    this[kLength] = 0;\n  }\n\n  get length() {\n    return this[kLength];\n  }\n  /** Adds a buffer to the internal buffer pool list */\n\n\n  append(buffer) {\n    this[kBuffers].push(buffer);\n    this[kLength] += buffer.length;\n  }\n  /** Returns the requested number of bytes without consuming them */\n\n\n  peek(size) {\n    return this.read(size, false);\n  }\n  /** Reads the requested number of bytes, optionally consuming them */\n\n\n  read(size, consume = true) {\n    if (typeof size !== 'number' || size < 0) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n    }\n\n    if (size > this[kLength]) {\n      return Buffer.alloc(0);\n    }\n\n    let result; // read the whole buffer\n\n    if (size === this.length) {\n      result = Buffer.concat(this[kBuffers]);\n\n      if (consume) {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n      }\n    } // size is within first buffer, no need to concat\n    else if (size <= this[kBuffers][0].length) {\n      result = this[kBuffers][0].slice(0, size);\n\n      if (consume) {\n        this[kBuffers][0] = this[kBuffers][0].slice(size);\n        this[kLength] -= size;\n      }\n    } // size is beyond first buffer, need to track and copy\n    else {\n      result = Buffer.allocUnsafe(size);\n      let idx;\n      let offset = 0;\n      let bytesToCopy = size;\n\n      for (idx = 0; idx < this[kBuffers].length; ++idx) {\n        let bytesCopied;\n\n        if (bytesToCopy > this[kBuffers][idx].length) {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n          offset += bytesCopied;\n        } else {\n          bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n\n          if (consume) {\n            this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n          }\n\n          offset += bytesCopied;\n          break;\n        }\n\n        bytesToCopy -= bytesCopied;\n      } // compact the internal buffer array\n\n\n      if (consume) {\n        this[kBuffers] = this[kBuffers].slice(idx);\n        this[kLength] -= size;\n      }\n    }\n\n    return result;\n  }\n\n}\n\nexports.BufferPool = BufferPool;\n/** @public */\n\nclass HostAddress {\n  constructor(hostString) {\n    const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n\n    const {\n      hostname,\n      port\n    } = new url_1.URL(`mongodb://${escapedHost}`);\n\n    if (hostname.endsWith('.sock')) {\n      // heuristically determine if we're working with a domain socket\n      this.socketPath = decodeURIComponent(hostname);\n    } else if (typeof hostname === 'string') {\n      this.isIPv6 = false;\n      let normalized = decodeURIComponent(hostname).toLowerCase();\n\n      if (normalized.startsWith('[') && normalized.endsWith(']')) {\n        this.isIPv6 = true;\n        normalized = normalized.substring(1, hostname.length - 1);\n      }\n\n      this.host = normalized.toLowerCase();\n\n      if (typeof port === 'number') {\n        this.port = port;\n      } else if (typeof port === 'string' && port !== '') {\n        this.port = Number.parseInt(port, 10);\n      } else {\n        this.port = 27017;\n      }\n\n      if (this.port === 0) {\n        throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n      }\n    } else {\n      throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n    }\n\n    Object.freeze(this);\n  }\n  /**\n   * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n   */\n\n\n  toString(ipv6Brackets = false) {\n    if (typeof this.host === 'string') {\n      if (this.isIPv6 && ipv6Brackets) {\n        return `[${this.host}]:${this.port}`;\n      }\n\n      return `${this.host}:${this.port}`;\n    }\n\n    return `${this.socketPath}`;\n  }\n\n  static fromString(s) {\n    return new HostAddress(s);\n  }\n\n}\n\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n  // We prefer not to rely on ObjectId having a createPk method\n  createPk() {\n    return new bson_1.ObjectId();\n  }\n\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\n\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\n\nfunction emitWarning(message) {\n  return process.emitWarning(message, {\n    code: exports.MONGODB_WARNING_CODE\n  });\n}\n\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\n\nfunction emitWarningOnce(message) {\n  if (!emittedWarnings.has(message)) {\n    emittedWarnings.add(message);\n    return emitWarning(message);\n  }\n}\n\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\n\nfunction enumToString(en) {\n  return Object.values(en).join(', ');\n}\n\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\n\nfunction supportsRetryableWrites(server) {\n  return !!server.loadBalanced || server.description.maxWireVersion >= 6 && !!server.description.logicalSessionTimeoutMinutes && server.description.type !== common_1.ServerType.Standalone;\n}\n\nexports.supportsRetryableWrites = supportsRetryableWrites;\n\nfunction parsePackageVersion({\n  version\n}) {\n  const [major, minor, patch] = version.split('.').map(n => Number.parseInt(n, 10));\n  return {\n    major,\n    minor,\n    patch\n  };\n}\n\nexports.parsePackageVersion = parsePackageVersion;","map":{"version":3,"names":["Object","defineProperty","exports","value","enumToString","emitWarningOnce","emitWarning","MONGODB_WARNING_CODE","DEFAULT_PK_FACTORY","HostAddress","BufferPool","deepCopy","isRecord","setDifference","isSuperset","resolveOptions","hasAtomicOperators","makeInterruptibleAsyncInterval","calculateDurationInMs","now","makeClientMetadata","makeStateMachine","errorStrictEqual","arrayStrictEqual","eachAsyncSeries","eachAsync","collationNotSupported","maxWireVersion","uuidV4","collectionNamespace","databaseNamespace","maybePromise","makeCounter","MongoDBNamespace","ns","deprecateOptions","defaultMsgHandler","getTopology","decorateWithExplain","decorateWithReadConcern","decorateWithCollation","isPromiseLike","applyWriteConcern","applyRetryableWrites","executeLegacyOperation","filterOptions","mergeOptions","decorateCommand","isObject","parseIndexOptions","normalizeHintField","checkCollectionName","getSingleProperty","MAX_JS_INT","parsePackageVersion","supportsRetryableWrites","os","require","crypto","promise_provider_1","error_1","write_concern_1","common_1","read_concern_1","bson_1","read_preference_1","url_1","constants_1","Number","MAX_SAFE_INTEGER","obj","name","enumerable","get","collectionName","MongoInvalidArgumentError","indexOf","match","hint","finalHint","undefined","Array","isArray","forEach","param","indexSpec","fieldHash","indexes","keys","push","f","k","entries","key","join","arg","prototype","toString","call","command","options","exclude","includes","target","source","names","topology","operation","args","Promise","PromiseProvider","MongoRuntimeError","callback","length","session","opOptions","owner","skipSessions","hasSessionSupport","Symbol","startSession","optionsIndex","assign","hasEnded","MongoExpiredSessionError","makeExecuteCallback","resolve","reject","err","result","returnsCursor","endSession","pop","handler","e","db","_a","s","retryWrites","sources","coll","collection","inTransaction","writeConcern","WriteConcern","fromOptions","then","capabilities","collation","commandsTakeCollation","MongoCompatibilityError","readConcern","explain","verbosity","provider","client","MongoNotConnectedError","option","config","fn","process","noDeprecation","msgHandler","optionsWarned","Set","deprecated","bind","deprecatedOption","deprecatedOptions","has","add","msg","logger","getLogger","warn","setPrototypeOf","fromString","constructor","withCollection","namespace","split","seed","count","newCount","wrapper","res","error","nextTick","slice","randomBytes","topologyOrServer","loadBalanced","MAX_SUPPORTED_WIRE_VERSION","ismaster","lastIsMaster","description","server","cmd","arr","eachFn","idx","awaiting","eachCallback","arr2","every","elt","lhs","rhs","message","stateTable","stateTransition","newState","legalStates","state","emit","NODE_DRIVER_VERSION","version","metadata","driver","type","platform","architecture","arch","release","endianness","driverInfo","appName","buffer","Buffer","from","application","byteLength","hrtime","Math","floor","started","elapsed","timerId","lastCallTime","lastWakeTime","stopped","interval","minInterval","immediate","clock","wake","currentTime","timeSinceLastWake","timeSinceLastCall","timeUntilNextCall","reschedule","executeAndReschedule","stop","clearTimeout","ms","setTimeout","doc","document","parent","_b","_c","resolveBSONOptions","ReadConcern","readPreference","ReadPreference","set","subset","elem","setA","setB","difference","delete","requiredKeys","hasOwnProperty","v","ctor","map","item","toLowerCase","Map","kBuffers","kLength","append","peek","size","read","consume","alloc","concat","allocUnsafe","offset","bytesToCopy","bytesCopied","copy","hostString","escapedHost","hostname","port","URL","endsWith","socketPath","decodeURIComponent","isIPv6","normalized","startsWith","substring","host","parseInt","MongoParseError","freeze","ipv6Brackets","createPk","ObjectId","code","emittedWarnings","en","values","logicalSessionTimeoutMinutes","ServerType","Standalone","major","minor","patch","n"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.enumToString = exports.emitWarningOnce = exports.emitWarning = exports.MONGODB_WARNING_CODE = exports.DEFAULT_PK_FACTORY = exports.HostAddress = exports.BufferPool = exports.deepCopy = exports.isRecord = exports.setDifference = exports.isSuperset = exports.resolveOptions = exports.hasAtomicOperators = exports.makeInterruptibleAsyncInterval = exports.calculateDurationInMs = exports.now = exports.makeClientMetadata = exports.makeStateMachine = exports.errorStrictEqual = exports.arrayStrictEqual = exports.eachAsyncSeries = exports.eachAsync = exports.collationNotSupported = exports.maxWireVersion = exports.uuidV4 = exports.collectionNamespace = exports.databaseNamespace = exports.maybePromise = exports.makeCounter = exports.MongoDBNamespace = exports.ns = exports.deprecateOptions = exports.defaultMsgHandler = exports.getTopology = exports.decorateWithExplain = exports.decorateWithReadConcern = exports.decorateWithCollation = exports.isPromiseLike = exports.applyWriteConcern = exports.applyRetryableWrites = exports.executeLegacyOperation = exports.filterOptions = exports.mergeOptions = exports.decorateCommand = exports.isObject = exports.parseIndexOptions = exports.normalizeHintField = exports.checkCollectionName = exports.getSingleProperty = exports.MAX_JS_INT = void 0;\nexports.parsePackageVersion = exports.supportsRetryableWrites = void 0;\nconst os = require(\"os\");\nconst crypto = require(\"crypto\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst error_1 = require(\"./error\");\nconst write_concern_1 = require(\"./write_concern\");\nconst common_1 = require(\"./sdam/common\");\nconst read_concern_1 = require(\"./read_concern\");\nconst bson_1 = require(\"./bson\");\nconst read_preference_1 = require(\"./read_preference\");\nconst url_1 = require(\"url\");\nconst constants_1 = require(\"./cmap/wire_protocol/constants\");\nexports.MAX_JS_INT = Number.MAX_SAFE_INTEGER + 1;\n/**\n * Add a readonly enumerable property.\n * @internal\n */\nfunction getSingleProperty(obj, name, value) {\n    Object.defineProperty(obj, name, {\n        enumerable: true,\n        get() {\n            return value;\n        }\n    });\n}\nexports.getSingleProperty = getSingleProperty;\n/**\n * Throws if collectionName is not a valid mongodb collection namespace.\n * @internal\n */\nfunction checkCollectionName(collectionName) {\n    if ('string' !== typeof collectionName) {\n        throw new error_1.MongoInvalidArgumentError('Collection name must be a String');\n    }\n    if (!collectionName || collectionName.indexOf('..') !== -1) {\n        throw new error_1.MongoInvalidArgumentError('Collection names cannot be empty');\n    }\n    if (collectionName.indexOf('$') !== -1 &&\n        collectionName.match(/((^\\$cmd)|(oplog\\.\\$main))/) == null) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError(\"Collection names must not contain '$'\");\n    }\n    if (collectionName.match(/^\\.|\\.$/) != null) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError(\"Collection names must not start or end with '.'\");\n    }\n    // Validate that we are not passing 0x00 in the collection name\n    if (collectionName.indexOf('\\x00') !== -1) {\n        // TODO(NODE-3483): Use MongoNamespace static method\n        throw new error_1.MongoInvalidArgumentError('Collection names cannot contain a null character');\n    }\n}\nexports.checkCollectionName = checkCollectionName;\n/**\n * Ensure Hint field is in a shape we expect:\n * - object of index names mapping to 1 or -1\n * - just an index name\n * @internal\n */\nfunction normalizeHintField(hint) {\n    let finalHint = undefined;\n    if (typeof hint === 'string') {\n        finalHint = hint;\n    }\n    else if (Array.isArray(hint)) {\n        finalHint = {};\n        hint.forEach(param => {\n            finalHint[param] = 1;\n        });\n    }\n    else if (hint != null && typeof hint === 'object') {\n        finalHint = {};\n        for (const name in hint) {\n            finalHint[name] = hint[name];\n        }\n    }\n    return finalHint;\n}\nexports.normalizeHintField = normalizeHintField;\n/**\n * Create an index specifier based on\n * @internal\n */\nfunction parseIndexOptions(indexSpec) {\n    const fieldHash = {};\n    const indexes = [];\n    let keys;\n    // Get all the fields accordingly\n    if ('string' === typeof indexSpec) {\n        // 'type'\n        indexes.push(indexSpec + '_' + 1);\n        fieldHash[indexSpec] = 1;\n    }\n    else if (Array.isArray(indexSpec)) {\n        indexSpec.forEach((f) => {\n            if ('string' === typeof f) {\n                // [{location:'2d'}, 'type']\n                indexes.push(f + '_' + 1);\n                fieldHash[f] = 1;\n            }\n            else if (Array.isArray(f)) {\n                // [['location', '2d'],['type', 1]]\n                indexes.push(f[0] + '_' + (f[1] || 1));\n                fieldHash[f[0]] = f[1] || 1;\n            }\n            else if (isObject(f)) {\n                // [{location:'2d'}, {type:1}]\n                keys = Object.keys(f);\n                keys.forEach(k => {\n                    indexes.push(k + '_' + f[k]);\n                    fieldHash[k] = f[k];\n                });\n            }\n            else {\n                // undefined (ignore)\n            }\n        });\n    }\n    else if (isObject(indexSpec)) {\n        // {location:'2d', type:1}\n        keys = Object.keys(indexSpec);\n        Object.entries(indexSpec).forEach(([key, value]) => {\n            indexes.push(key + '_' + value);\n            fieldHash[key] = value;\n        });\n    }\n    return {\n        name: indexes.join('_'),\n        keys: keys,\n        fieldHash: fieldHash\n    };\n}\nexports.parseIndexOptions = parseIndexOptions;\n/**\n * Checks if arg is an Object:\n * - **NOTE**: the check is based on the `[Symbol.toStringTag]() === 'Object'`\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isObject(arg) {\n    return '[object Object]' === Object.prototype.toString.call(arg);\n}\nexports.isObject = isObject;\n/** @internal */\nfunction decorateCommand(command, options, exclude) {\n    for (const name in options) {\n        if (!exclude.includes(name)) {\n            command[name] = options[name];\n        }\n    }\n    return command;\n}\nexports.decorateCommand = decorateCommand;\n/** @internal */\nfunction mergeOptions(target, source) {\n    return { ...target, ...source };\n}\nexports.mergeOptions = mergeOptions;\n/** @internal */\nfunction filterOptions(options, names) {\n    const filterOptions = {};\n    for (const name in options) {\n        if (names.includes(name)) {\n            filterOptions[name] = options[name];\n        }\n    }\n    // Filtered options\n    return filterOptions;\n}\nexports.filterOptions = filterOptions;\n/**\n * Executes the given operation with provided arguments.\n *\n * @remarks\n * This method reduces large amounts of duplication in the entire codebase by providing\n * a single point for determining whether callbacks or promises should be used. Additionally\n * it allows for a single point of entry to provide features such as implicit sessions, which\n * are required by the Driver Sessions specification in the event that a ClientSession is\n * not provided\n *\n * @internal\n *\n * @param topology - The topology to execute this operation on\n * @param operation - The operation to execute\n * @param args - Arguments to apply the provided operation\n * @param options - Options that modify the behavior of the method\n */\nfunction executeLegacyOperation(topology, operation, args, options) {\n    const Promise = promise_provider_1.PromiseProvider.get();\n    if (!Array.isArray(args)) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('This method requires an array of arguments to apply');\n    }\n    options = options !== null && options !== void 0 ? options : {};\n    let callback = args[args.length - 1];\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    let session;\n    let opOptions;\n    let owner;\n    if (!options.skipSessions && topology.hasSessionSupport()) {\n        opOptions = args[args.length - 2];\n        if (opOptions == null || opOptions.session == null) {\n            owner = Symbol();\n            session = topology.startSession({ owner });\n            const optionsIndex = args.length - 2;\n            args[optionsIndex] = Object.assign({}, args[optionsIndex], { session: session });\n        }\n        else if (opOptions.session && opOptions.session.hasEnded) {\n            throw new error_1.MongoExpiredSessionError();\n        }\n    }\n    function makeExecuteCallback(resolve, reject) {\n        return function (err, result) {\n            if (session && session.owner === owner && !(options === null || options === void 0 ? void 0 : options.returnsCursor)) {\n                session.endSession(() => {\n                    delete opOptions.session;\n                    if (err)\n                        return reject(err);\n                    resolve(result);\n                });\n            }\n            else {\n                if (err)\n                    return reject(err);\n                resolve(result);\n            }\n        };\n    }\n    // Execute using callback\n    if (typeof callback === 'function') {\n        callback = args.pop();\n        const handler = makeExecuteCallback(result => callback(undefined, result), err => callback(err, null));\n        args.push(handler);\n        try {\n            return operation(...args);\n        }\n        catch (e) {\n            handler(e);\n            throw e;\n        }\n    }\n    // Return a Promise\n    if (args[args.length - 1] != null) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('Final argument to `executeLegacyOperation` must be a callback');\n    }\n    return new Promise((resolve, reject) => {\n        const handler = makeExecuteCallback(resolve, reject);\n        args[args.length - 1] = handler;\n        try {\n            return operation(...args);\n        }\n        catch (e) {\n            handler(e);\n        }\n    });\n}\nexports.executeLegacyOperation = executeLegacyOperation;\n/**\n * Applies retryWrites: true to a command if retryWrites is set on the command's database.\n * @internal\n *\n * @param target - The target command to which we will apply retryWrites.\n * @param db - The database from which we can inherit a retryWrites value.\n */\nfunction applyRetryableWrites(target, db) {\n    var _a;\n    if (db && ((_a = db.s.options) === null || _a === void 0 ? void 0 : _a.retryWrites)) {\n        target.retryWrites = true;\n    }\n    return target;\n}\nexports.applyRetryableWrites = applyRetryableWrites;\n/**\n * Applies a write concern to a command based on well defined inheritance rules, optionally\n * detecting support for the write concern in the first place.\n * @internal\n *\n * @param target - the target command we will be applying the write concern to\n * @param sources - sources where we can inherit default write concerns from\n * @param options - optional settings passed into a command for write concern overrides\n */\nfunction applyWriteConcern(target, sources, options) {\n    options = options !== null && options !== void 0 ? options : {};\n    const db = sources.db;\n    const coll = sources.collection;\n    if (options.session && options.session.inTransaction()) {\n        // writeConcern is not allowed within a multi-statement transaction\n        if (target.writeConcern) {\n            delete target.writeConcern;\n        }\n        return target;\n    }\n    const writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n    if (writeConcern) {\n        return Object.assign(target, { writeConcern });\n    }\n    if (coll && coll.writeConcern) {\n        return Object.assign(target, { writeConcern: Object.assign({}, coll.writeConcern) });\n    }\n    if (db && db.writeConcern) {\n        return Object.assign(target, { writeConcern: Object.assign({}, db.writeConcern) });\n    }\n    return target;\n}\nexports.applyWriteConcern = applyWriteConcern;\n/**\n * Checks if a given value is a Promise\n *\n * @typeParam T - The result type of maybePromise\n * @param maybePromise - An object that could be a promise\n * @returns true if the provided value is a Promise\n */\nfunction isPromiseLike(maybePromise) {\n    return !!maybePromise && typeof maybePromise.then === 'function';\n}\nexports.isPromiseLike = isPromiseLike;\n/**\n * Applies collation to a given command.\n * @internal\n *\n * @param command - the command on which to apply collation\n * @param target - target of command\n * @param options - options containing collation settings\n */\nfunction decorateWithCollation(command, target, options) {\n    const capabilities = getTopology(target).capabilities;\n    if (options.collation && typeof options.collation === 'object') {\n        if (capabilities && capabilities.commandsTakeCollation) {\n            command.collation = options.collation;\n        }\n        else {\n            throw new error_1.MongoCompatibilityError(`Current topology does not support collation`);\n        }\n    }\n}\nexports.decorateWithCollation = decorateWithCollation;\n/**\n * Applies a read concern to a given command.\n * @internal\n *\n * @param command - the command on which to apply the read concern\n * @param coll - the parent collection of the operation calling this method\n */\nfunction decorateWithReadConcern(command, coll, options) {\n    if (options && options.session && options.session.inTransaction()) {\n        return;\n    }\n    const readConcern = Object.assign({}, command.readConcern || {});\n    if (coll.s.readConcern) {\n        Object.assign(readConcern, coll.s.readConcern);\n    }\n    if (Object.keys(readConcern).length > 0) {\n        Object.assign(command, { readConcern: readConcern });\n    }\n}\nexports.decorateWithReadConcern = decorateWithReadConcern;\n/**\n * Applies an explain to a given command.\n * @internal\n *\n * @param command - the command on which to apply the explain\n * @param options - the options containing the explain verbosity\n */\nfunction decorateWithExplain(command, explain) {\n    if (command.explain) {\n        return command;\n    }\n    return { explain: command, verbosity: explain.verbosity };\n}\nexports.decorateWithExplain = decorateWithExplain;\n/**\n * A helper function to get the topology from a given provider. Throws\n * if the topology cannot be found.\n * @internal\n */\nfunction getTopology(provider) {\n    if (`topology` in provider && provider.topology) {\n        return provider.topology;\n    }\n    else if ('client' in provider.s && provider.s.client.topology) {\n        return provider.s.client.topology;\n    }\n    else if ('db' in provider.s && provider.s.db.s.client.topology) {\n        return provider.s.db.s.client.topology;\n    }\n    throw new error_1.MongoNotConnectedError('MongoClient must be connected to perform this operation');\n}\nexports.getTopology = getTopology;\n/**\n * Default message handler for generating deprecation warnings.\n * @internal\n *\n * @param name - function name\n * @param option - option name\n * @returns warning message\n */\nfunction defaultMsgHandler(name, option) {\n    return `${name} option [${option}] is deprecated and will be removed in a later version.`;\n}\nexports.defaultMsgHandler = defaultMsgHandler;\n/**\n * Deprecates a given function's options.\n * @internal\n *\n * @param this - the bound class if this is a method\n * @param config - configuration for deprecation\n * @param fn - the target function of deprecation\n * @returns modified function that warns once per deprecated option, and executes original function\n */\nfunction deprecateOptions(config, fn) {\n    if (process.noDeprecation === true) {\n        return fn;\n    }\n    const msgHandler = config.msgHandler ? config.msgHandler : defaultMsgHandler;\n    const optionsWarned = new Set();\n    function deprecated(...args) {\n        const options = args[config.optionsIndex];\n        // ensure options is a valid, non-empty object, otherwise short-circuit\n        if (!isObject(options) || Object.keys(options).length === 0) {\n            return fn.bind(this)(...args); // call the function, no change\n        }\n        // interrupt the function call with a warning\n        for (const deprecatedOption of config.deprecatedOptions) {\n            if (deprecatedOption in options && !optionsWarned.has(deprecatedOption)) {\n                optionsWarned.add(deprecatedOption);\n                const msg = msgHandler(config.name, deprecatedOption);\n                emitWarning(msg);\n                if (this && 'getLogger' in this) {\n                    const logger = this.getLogger();\n                    if (logger) {\n                        logger.warn(msg);\n                    }\n                }\n            }\n        }\n        return fn.bind(this)(...args);\n    }\n    // These lines copied from https://github.com/nodejs/node/blob/25e5ae41688676a5fd29b2e2e7602168eee4ceb5/lib/internal/util.js#L73-L80\n    // The wrapper will keep the same prototype as fn to maintain prototype chain\n    Object.setPrototypeOf(deprecated, fn);\n    if (fn.prototype) {\n        // Setting this (rather than using Object.setPrototype, as above) ensures\n        // that calling the unwrapped constructor gives an instanceof the wrapped\n        // constructor.\n        deprecated.prototype = fn.prototype;\n    }\n    return deprecated;\n}\nexports.deprecateOptions = deprecateOptions;\n/** @internal */\nfunction ns(ns) {\n    return MongoDBNamespace.fromString(ns);\n}\nexports.ns = ns;\n/** @public */\nclass MongoDBNamespace {\n    /**\n     * Create a namespace object\n     *\n     * @param db - database name\n     * @param collection - collection name\n     */\n    constructor(db, collection) {\n        this.db = db;\n        this.collection = collection;\n    }\n    toString() {\n        return this.collection ? `${this.db}.${this.collection}` : this.db;\n    }\n    withCollection(collection) {\n        return new MongoDBNamespace(this.db, collection);\n    }\n    static fromString(namespace) {\n        if (!namespace) {\n            // TODO(NODE-3483): Replace with MongoNamespaceError\n            throw new error_1.MongoRuntimeError(`Cannot parse namespace from \"${namespace}\"`);\n        }\n        const [db, ...collection] = namespace.split('.');\n        return new MongoDBNamespace(db, collection.join('.'));\n    }\n}\nexports.MongoDBNamespace = MongoDBNamespace;\n/** @internal */\nfunction* makeCounter(seed = 0) {\n    let count = seed;\n    while (true) {\n        const newCount = count;\n        count += 1;\n        yield newCount;\n    }\n}\nexports.makeCounter = makeCounter;\n/**\n * Helper function for either accepting a callback, or returning a promise\n * @internal\n *\n * @param callback - The last function argument in exposed method, controls if a Promise is returned\n * @param wrapper - A function that wraps the callback\n * @returns Returns void if a callback is supplied, else returns a Promise.\n */\nfunction maybePromise(callback, wrapper) {\n    const Promise = promise_provider_1.PromiseProvider.get();\n    let result;\n    if (typeof callback !== 'function') {\n        result = new Promise((resolve, reject) => {\n            callback = (err, res) => {\n                if (err)\n                    return reject(err);\n                resolve(res);\n            };\n        });\n    }\n    wrapper((err, res) => {\n        if (err != null) {\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                callback(err);\n            }\n            catch (error) {\n                process.nextTick(() => {\n                    throw error;\n                });\n            }\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        callback(err, res);\n    });\n    return result;\n}\nexports.maybePromise = maybePromise;\n/** @internal */\nfunction databaseNamespace(ns) {\n    return ns.split('.')[0];\n}\nexports.databaseNamespace = databaseNamespace;\n/** @internal */\nfunction collectionNamespace(ns) {\n    return ns.split('.').slice(1).join('.');\n}\nexports.collectionNamespace = collectionNamespace;\n/**\n * Synchronously Generate a UUIDv4\n * @internal\n */\nfunction uuidV4() {\n    const result = crypto.randomBytes(16);\n    result[6] = (result[6] & 0x0f) | 0x40;\n    result[8] = (result[8] & 0x3f) | 0x80;\n    return result;\n}\nexports.uuidV4 = uuidV4;\n/**\n * A helper function for determining `maxWireVersion` between legacy and new topology instances\n * @internal\n */\nfunction maxWireVersion(topologyOrServer) {\n    if (topologyOrServer) {\n        if (topologyOrServer.loadBalanced) {\n            // Since we do not have a monitor, we assume the load balanced server is always\n            // pointed at the latest mongodb version. There is a risk that for on-prem\n            // deployments that don't upgrade immediately that this could alert to the\n            // application that a feature is avaiable that is actually not.\n            return constants_1.MAX_SUPPORTED_WIRE_VERSION;\n        }\n        if (topologyOrServer.ismaster) {\n            return topologyOrServer.ismaster.maxWireVersion;\n        }\n        if ('lastIsMaster' in topologyOrServer && typeof topologyOrServer.lastIsMaster === 'function') {\n            const lastIsMaster = topologyOrServer.lastIsMaster();\n            if (lastIsMaster) {\n                return lastIsMaster.maxWireVersion;\n            }\n        }\n        if (topologyOrServer.description &&\n            'maxWireVersion' in topologyOrServer.description &&\n            topologyOrServer.description.maxWireVersion != null) {\n            return topologyOrServer.description.maxWireVersion;\n        }\n    }\n    return 0;\n}\nexports.maxWireVersion = maxWireVersion;\n/**\n * Checks that collation is supported by server.\n * @internal\n *\n * @param server - to check against\n * @param cmd - object where collation may be specified\n */\nfunction collationNotSupported(server, cmd) {\n    return cmd && cmd.collation && maxWireVersion(server) < 5;\n}\nexports.collationNotSupported = collationNotSupported;\n/**\n * Applies the function `eachFn` to each item in `arr`, in parallel.\n * @internal\n *\n * @param arr - An array of items to asynchronously iterate over\n * @param eachFn - A function to call on each item of the array. The callback signature is `(item, callback)`, where the callback indicates iteration is complete.\n * @param callback - The callback called after every item has been iterated\n */\nfunction eachAsync(arr, eachFn, callback) {\n    arr = arr || [];\n    let idx = 0;\n    let awaiting = 0;\n    for (idx = 0; idx < arr.length; ++idx) {\n        awaiting++;\n        eachFn(arr[idx], eachCallback);\n    }\n    if (awaiting === 0) {\n        callback();\n        return;\n    }\n    function eachCallback(err) {\n        awaiting--;\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (idx === arr.length && awaiting <= 0) {\n            callback();\n        }\n    }\n}\nexports.eachAsync = eachAsync;\n/** @internal */\nfunction eachAsyncSeries(arr, eachFn, callback) {\n    arr = arr || [];\n    let idx = 0;\n    let awaiting = arr.length;\n    if (awaiting === 0) {\n        callback();\n        return;\n    }\n    function eachCallback(err) {\n        idx++;\n        awaiting--;\n        if (err) {\n            callback(err);\n            return;\n        }\n        if (idx === arr.length && awaiting <= 0) {\n            callback();\n            return;\n        }\n        eachFn(arr[idx], eachCallback);\n    }\n    eachFn(arr[idx], eachCallback);\n}\nexports.eachAsyncSeries = eachAsyncSeries;\n/** @internal */\nfunction arrayStrictEqual(arr, arr2) {\n    if (!Array.isArray(arr) || !Array.isArray(arr2)) {\n        return false;\n    }\n    return arr.length === arr2.length && arr.every((elt, idx) => elt === arr2[idx]);\n}\nexports.arrayStrictEqual = arrayStrictEqual;\n/** @internal */\nfunction errorStrictEqual(lhs, rhs) {\n    if (lhs === rhs) {\n        return true;\n    }\n    if (!lhs || !rhs) {\n        return lhs === rhs;\n    }\n    if ((lhs == null && rhs != null) || (lhs != null && rhs == null)) {\n        return false;\n    }\n    if (lhs.constructor.name !== rhs.constructor.name) {\n        return false;\n    }\n    if (lhs.message !== rhs.message) {\n        return false;\n    }\n    return true;\n}\nexports.errorStrictEqual = errorStrictEqual;\n/** @internal */\nfunction makeStateMachine(stateTable) {\n    return function stateTransition(target, newState) {\n        const legalStates = stateTable[target.s.state];\n        if (legalStates && legalStates.indexOf(newState) < 0) {\n            throw new error_1.MongoRuntimeError(`illegal state transition from [${target.s.state}] => [${newState}], allowed: [${legalStates}]`);\n        }\n        target.emit('stateChanged', target.s.state, newState);\n        target.s.state = newState;\n    };\n}\nexports.makeStateMachine = makeStateMachine;\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst NODE_DRIVER_VERSION = require('../package.json').version;\nfunction makeClientMetadata(options) {\n    options = options !== null && options !== void 0 ? options : {};\n    const metadata = {\n        driver: {\n            name: 'nodejs',\n            version: NODE_DRIVER_VERSION\n        },\n        os: {\n            type: os.type(),\n            name: process.platform,\n            architecture: process.arch,\n            version: os.release()\n        },\n        platform: `Node.js ${process.version}, ${os.endianness()} (unified)`\n    };\n    // support optionally provided wrapping driver info\n    if (options.driverInfo) {\n        if (options.driverInfo.name) {\n            metadata.driver.name = `${metadata.driver.name}|${options.driverInfo.name}`;\n        }\n        if (options.driverInfo.version) {\n            metadata.version = `${metadata.driver.version}|${options.driverInfo.version}`;\n        }\n        if (options.driverInfo.platform) {\n            metadata.platform = `${metadata.platform}|${options.driverInfo.platform}`;\n        }\n    }\n    if (options.appName) {\n        // MongoDB requires the appName not exceed a byte length of 128\n        const buffer = Buffer.from(options.appName);\n        metadata.application = {\n            name: buffer.byteLength > 128 ? buffer.slice(0, 128).toString('utf8') : options.appName\n        };\n    }\n    return metadata;\n}\nexports.makeClientMetadata = makeClientMetadata;\n/** @internal */\nfunction now() {\n    const hrtime = process.hrtime();\n    return Math.floor(hrtime[0] * 1000 + hrtime[1] / 1000000);\n}\nexports.now = now;\n/** @internal */\nfunction calculateDurationInMs(started) {\n    if (typeof started !== 'number') {\n        throw new error_1.MongoInvalidArgumentError('Numeric value required to calculate duration');\n    }\n    const elapsed = now() - started;\n    return elapsed < 0 ? 0 : elapsed;\n}\nexports.calculateDurationInMs = calculateDurationInMs;\n/**\n * Creates an interval timer which is able to be woken up sooner than\n * the interval. The timer will also debounce multiple calls to wake\n * ensuring that the function is only ever called once within a minimum\n * interval window.\n * @internal\n *\n * @param fn - An async function to run on an interval, must accept a `callback` as its only parameter\n */\nfunction makeInterruptibleAsyncInterval(fn, options) {\n    let timerId;\n    let lastCallTime;\n    let lastWakeTime;\n    let stopped = false;\n    options = options !== null && options !== void 0 ? options : {};\n    const interval = options.interval || 1000;\n    const minInterval = options.minInterval || 500;\n    const immediate = typeof options.immediate === 'boolean' ? options.immediate : false;\n    const clock = typeof options.clock === 'function' ? options.clock : now;\n    function wake() {\n        const currentTime = clock();\n        const timeSinceLastWake = currentTime - lastWakeTime;\n        const timeSinceLastCall = currentTime - lastCallTime;\n        const timeUntilNextCall = interval - timeSinceLastCall;\n        lastWakeTime = currentTime;\n        // For the streaming protocol: there is nothing obviously stopping this\n        // interval from being woken up again while we are waiting \"infinitely\"\n        // for `fn` to be called again`. Since the function effectively\n        // never completes, the `timeUntilNextCall` will continue to grow\n        // negatively unbounded, so it will never trigger a reschedule here.\n        // debounce multiple calls to wake within the `minInterval`\n        if (timeSinceLastWake < minInterval) {\n            return;\n        }\n        // reschedule a call as soon as possible, ensuring the call never happens\n        // faster than the `minInterval`\n        if (timeUntilNextCall > minInterval) {\n            reschedule(minInterval);\n        }\n        // This is possible in virtualized environments like AWS Lambda where our\n        // clock is unreliable. In these cases the timer is \"running\" but never\n        // actually completes, so we want to execute immediately and then attempt\n        // to reschedule.\n        if (timeUntilNextCall < 0) {\n            executeAndReschedule();\n        }\n    }\n    function stop() {\n        stopped = true;\n        if (timerId) {\n            clearTimeout(timerId);\n            timerId = undefined;\n        }\n        lastCallTime = 0;\n        lastWakeTime = 0;\n    }\n    function reschedule(ms) {\n        if (stopped)\n            return;\n        if (timerId) {\n            clearTimeout(timerId);\n        }\n        timerId = setTimeout(executeAndReschedule, ms || interval);\n    }\n    function executeAndReschedule() {\n        lastWakeTime = 0;\n        lastCallTime = clock();\n        fn(err => {\n            if (err)\n                throw err;\n            reschedule(interval);\n        });\n    }\n    if (immediate) {\n        executeAndReschedule();\n    }\n    else {\n        lastCallTime = clock();\n        reschedule(undefined);\n    }\n    return { wake, stop };\n}\nexports.makeInterruptibleAsyncInterval = makeInterruptibleAsyncInterval;\n/** @internal */\nfunction hasAtomicOperators(doc) {\n    if (Array.isArray(doc)) {\n        for (const document of doc) {\n            if (hasAtomicOperators(document)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    const keys = Object.keys(doc);\n    return keys.length > 0 && keys[0][0] === '$';\n}\nexports.hasAtomicOperators = hasAtomicOperators;\n/**\n * Merge inherited properties from parent into options, prioritizing values from options,\n * then values from parent.\n * @internal\n */\nfunction resolveOptions(parent, options) {\n    var _a, _b, _c;\n    const result = Object.assign({}, options, bson_1.resolveBSONOptions(options, parent));\n    // Users cannot pass a readConcern/writeConcern to operations in a transaction\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    if (!(session === null || session === void 0 ? void 0 : session.inTransaction())) {\n        const readConcern = (_a = read_concern_1.ReadConcern.fromOptions(options)) !== null && _a !== void 0 ? _a : parent === null || parent === void 0 ? void 0 : parent.readConcern;\n        if (readConcern) {\n            result.readConcern = readConcern;\n        }\n        const writeConcern = (_b = write_concern_1.WriteConcern.fromOptions(options)) !== null && _b !== void 0 ? _b : parent === null || parent === void 0 ? void 0 : parent.writeConcern;\n        if (writeConcern) {\n            result.writeConcern = writeConcern;\n        }\n    }\n    const readPreference = (_c = read_preference_1.ReadPreference.fromOptions(options)) !== null && _c !== void 0 ? _c : parent === null || parent === void 0 ? void 0 : parent.readPreference;\n    if (readPreference) {\n        result.readPreference = readPreference;\n    }\n    return result;\n}\nexports.resolveOptions = resolveOptions;\nfunction isSuperset(set, subset) {\n    set = Array.isArray(set) ? new Set(set) : set;\n    subset = Array.isArray(subset) ? new Set(subset) : subset;\n    for (const elem of subset) {\n        if (!set.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isSuperset = isSuperset;\nfunction setDifference(setA, setB) {\n    const difference = new Set(setA);\n    for (const elem of setB) {\n        difference.delete(elem);\n    }\n    return difference;\n}\nexports.setDifference = setDifference;\nfunction isRecord(value, requiredKeys = undefined) {\n    const toString = Object.prototype.toString;\n    const hasOwnProperty = Object.prototype.hasOwnProperty;\n    const isObject = (v) => toString.call(v) === '[object Object]';\n    if (!isObject(value)) {\n        return false;\n    }\n    const ctor = value.constructor;\n    if (ctor && ctor.prototype) {\n        if (!isObject(ctor.prototype)) {\n            return false;\n        }\n        // Check to see if some method exists from the Object exists\n        if (!hasOwnProperty.call(ctor.prototype, 'isPrototypeOf')) {\n            return false;\n        }\n    }\n    if (requiredKeys) {\n        const keys = Object.keys(value);\n        return isSuperset(keys, requiredKeys);\n    }\n    return true;\n}\nexports.isRecord = isRecord;\n/**\n * Make a deep copy of an object\n *\n * NOTE: This is not meant to be the perfect implementation of a deep copy,\n * but instead something that is good enough for the purposes of\n * command monitoring.\n */\nfunction deepCopy(value) {\n    if (value == null) {\n        return value;\n    }\n    else if (Array.isArray(value)) {\n        return value.map(item => deepCopy(item));\n    }\n    else if (isRecord(value)) {\n        const res = {};\n        for (const key in value) {\n            res[key] = deepCopy(value[key]);\n        }\n        return res;\n    }\n    const ctor = value.constructor;\n    if (ctor) {\n        switch (ctor.name.toLowerCase()) {\n            case 'date':\n                return new ctor(Number(value));\n            case 'map':\n                return new Map(value);\n            case 'set':\n                return new Set(value);\n            case 'buffer':\n                return Buffer.from(value);\n        }\n    }\n    return value;\n}\nexports.deepCopy = deepCopy;\n/** @internal */\nconst kBuffers = Symbol('buffers');\n/** @internal */\nconst kLength = Symbol('length');\n/**\n * A pool of Buffers which allow you to read them as if they were one\n * @internal\n */\nclass BufferPool {\n    constructor() {\n        this[kBuffers] = [];\n        this[kLength] = 0;\n    }\n    get length() {\n        return this[kLength];\n    }\n    /** Adds a buffer to the internal buffer pool list */\n    append(buffer) {\n        this[kBuffers].push(buffer);\n        this[kLength] += buffer.length;\n    }\n    /** Returns the requested number of bytes without consuming them */\n    peek(size) {\n        return this.read(size, false);\n    }\n    /** Reads the requested number of bytes, optionally consuming them */\n    read(size, consume = true) {\n        if (typeof size !== 'number' || size < 0) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"size\" must be a non-negative number');\n        }\n        if (size > this[kLength]) {\n            return Buffer.alloc(0);\n        }\n        let result;\n        // read the whole buffer\n        if (size === this.length) {\n            result = Buffer.concat(this[kBuffers]);\n            if (consume) {\n                this[kBuffers] = [];\n                this[kLength] = 0;\n            }\n        }\n        // size is within first buffer, no need to concat\n        else if (size <= this[kBuffers][0].length) {\n            result = this[kBuffers][0].slice(0, size);\n            if (consume) {\n                this[kBuffers][0] = this[kBuffers][0].slice(size);\n                this[kLength] -= size;\n            }\n        }\n        // size is beyond first buffer, need to track and copy\n        else {\n            result = Buffer.allocUnsafe(size);\n            let idx;\n            let offset = 0;\n            let bytesToCopy = size;\n            for (idx = 0; idx < this[kBuffers].length; ++idx) {\n                let bytesCopied;\n                if (bytesToCopy > this[kBuffers][idx].length) {\n                    bytesCopied = this[kBuffers][idx].copy(result, offset, 0);\n                    offset += bytesCopied;\n                }\n                else {\n                    bytesCopied = this[kBuffers][idx].copy(result, offset, 0, bytesToCopy);\n                    if (consume) {\n                        this[kBuffers][idx] = this[kBuffers][idx].slice(bytesCopied);\n                    }\n                    offset += bytesCopied;\n                    break;\n                }\n                bytesToCopy -= bytesCopied;\n            }\n            // compact the internal buffer array\n            if (consume) {\n                this[kBuffers] = this[kBuffers].slice(idx);\n                this[kLength] -= size;\n            }\n        }\n        return result;\n    }\n}\nexports.BufferPool = BufferPool;\n/** @public */\nclass HostAddress {\n    constructor(hostString) {\n        const escapedHost = hostString.split(' ').join('%20'); // escape spaces, for socket path hosts\n        const { hostname, port } = new url_1.URL(`mongodb://${escapedHost}`);\n        if (hostname.endsWith('.sock')) {\n            // heuristically determine if we're working with a domain socket\n            this.socketPath = decodeURIComponent(hostname);\n        }\n        else if (typeof hostname === 'string') {\n            this.isIPv6 = false;\n            let normalized = decodeURIComponent(hostname).toLowerCase();\n            if (normalized.startsWith('[') && normalized.endsWith(']')) {\n                this.isIPv6 = true;\n                normalized = normalized.substring(1, hostname.length - 1);\n            }\n            this.host = normalized.toLowerCase();\n            if (typeof port === 'number') {\n                this.port = port;\n            }\n            else if (typeof port === 'string' && port !== '') {\n                this.port = Number.parseInt(port, 10);\n            }\n            else {\n                this.port = 27017;\n            }\n            if (this.port === 0) {\n                throw new error_1.MongoParseError('Invalid port (zero) with hostname');\n            }\n        }\n        else {\n            throw new error_1.MongoInvalidArgumentError('Either socketPath or host must be defined.');\n        }\n        Object.freeze(this);\n    }\n    /**\n     * @param ipv6Brackets - optionally request ipv6 bracket notation required for connection strings\n     */\n    toString(ipv6Brackets = false) {\n        if (typeof this.host === 'string') {\n            if (this.isIPv6 && ipv6Brackets) {\n                return `[${this.host}]:${this.port}`;\n            }\n            return `${this.host}:${this.port}`;\n        }\n        return `${this.socketPath}`;\n    }\n    static fromString(s) {\n        return new HostAddress(s);\n    }\n}\nexports.HostAddress = HostAddress;\nexports.DEFAULT_PK_FACTORY = {\n    // We prefer not to rely on ObjectId having a createPk method\n    createPk() {\n        return new bson_1.ObjectId();\n    }\n};\n/**\n * When the driver used emitWarning the code will be equal to this.\n * @public\n *\n * @example\n * ```js\n * process.on('warning', (warning) => {\n *  if (warning.code === MONGODB_WARNING_CODE) console.error('Ah an important warning! :)')\n * })\n * ```\n */\nexports.MONGODB_WARNING_CODE = 'MONGODB DRIVER';\n/** @internal */\nfunction emitWarning(message) {\n    return process.emitWarning(message, { code: exports.MONGODB_WARNING_CODE });\n}\nexports.emitWarning = emitWarning;\nconst emittedWarnings = new Set();\n/**\n * Will emit a warning once for the duration of the application.\n * Uses the message to identify if it has already been emitted\n * so using string interpolation can cause multiple emits\n * @internal\n */\nfunction emitWarningOnce(message) {\n    if (!emittedWarnings.has(message)) {\n        emittedWarnings.add(message);\n        return emitWarning(message);\n    }\n}\nexports.emitWarningOnce = emitWarningOnce;\n/**\n * Takes a JS object and joins the values into a string separated by ', '\n */\nfunction enumToString(en) {\n    return Object.values(en).join(', ');\n}\nexports.enumToString = enumToString;\n/**\n * Determine if a server supports retryable writes.\n *\n * @internal\n */\nfunction supportsRetryableWrites(server) {\n    return (!!server.loadBalanced ||\n        (server.description.maxWireVersion >= 6 &&\n            !!server.description.logicalSessionTimeoutMinutes &&\n            server.description.type !== common_1.ServerType.Standalone));\n}\nexports.supportsRetryableWrites = supportsRetryableWrites;\nfunction parsePackageVersion({ version }) {\n    const [major, minor, patch] = version.split('.').map((n) => Number.parseInt(n, 10));\n    return { major, minor, patch };\n}\nexports.parsePackageVersion = parsePackageVersion;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}