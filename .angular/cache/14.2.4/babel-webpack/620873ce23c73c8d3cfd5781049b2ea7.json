{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.prepareDocs = exports.indexInformation = void 0;\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nfunction indexInformation(db, name, _optionsOrCallback, _callback) {\n  let options = _optionsOrCallback;\n  let callback = _callback;\n\n  if ('function' === typeof _optionsOrCallback) {\n    callback = _optionsOrCallback;\n    options = {};\n  } // If we specified full information\n\n\n  const full = options.full == null ? false : options.full; // Did the user destroy the topology\n\n  if (utils_1.getTopology(db).isDestroyed()) return callback(new error_1.MongoTopologyClosedError()); // Process all the results from the index command and collection\n\n  function processResults(indexes) {\n    // Contains all the information\n    const info = {}; // Process all the indexes\n\n    for (let i = 0; i < indexes.length; i++) {\n      const index = indexes[i]; // Let's unpack the object\n\n      info[index.name] = [];\n\n      for (const name in index.key) {\n        info[index.name].push([name, index.key[name]]);\n      }\n    }\n\n    return info;\n  } // Get the list of indexes of the specified collection\n\n\n  db.collection(name).listIndexes(options).toArray((err, indexes) => {\n    if (err) return callback(err);\n    if (!Array.isArray(indexes)) return callback(undefined, []);\n    if (full) return callback(undefined, indexes);\n    callback(undefined, processResults(indexes));\n  });\n}\n\nexports.indexInformation = indexInformation;\n\nfunction prepareDocs(coll, docs, options) {\n  var _a;\n\n  const forceServerObjectId = typeof options.forceServerObjectId === 'boolean' ? options.forceServerObjectId : (_a = coll.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId; // no need to modify the docs if server sets the ObjectId\n\n  if (forceServerObjectId === true) {\n    return docs;\n  }\n\n  return docs.map(doc => {\n    if (doc._id == null) {\n      doc._id = coll.s.pkFactory.createPk();\n    }\n\n    return doc;\n  });\n}\n\nexports.prepareDocs = prepareDocs;","map":{"version":3,"names":["Object","defineProperty","exports","value","prepareDocs","indexInformation","error_1","require","utils_1","db","name","_optionsOrCallback","_callback","options","callback","full","getTopology","isDestroyed","MongoTopologyClosedError","processResults","indexes","info","i","length","index","key","push","collection","listIndexes","toArray","err","Array","isArray","undefined","coll","docs","_a","forceServerObjectId","s","map","doc","_id","pkFactory","createPk"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/operations/common_functions.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareDocs = exports.indexInformation = void 0;\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nfunction indexInformation(db, name, _optionsOrCallback, _callback) {\n    let options = _optionsOrCallback;\n    let callback = _callback;\n    if ('function' === typeof _optionsOrCallback) {\n        callback = _optionsOrCallback;\n        options = {};\n    }\n    // If we specified full information\n    const full = options.full == null ? false : options.full;\n    // Did the user destroy the topology\n    if (utils_1.getTopology(db).isDestroyed())\n        return callback(new error_1.MongoTopologyClosedError());\n    // Process all the results from the index command and collection\n    function processResults(indexes) {\n        // Contains all the information\n        const info = {};\n        // Process all the indexes\n        for (let i = 0; i < indexes.length; i++) {\n            const index = indexes[i];\n            // Let's unpack the object\n            info[index.name] = [];\n            for (const name in index.key) {\n                info[index.name].push([name, index.key[name]]);\n            }\n        }\n        return info;\n    }\n    // Get the list of indexes of the specified collection\n    db.collection(name)\n        .listIndexes(options)\n        .toArray((err, indexes) => {\n        if (err)\n            return callback(err);\n        if (!Array.isArray(indexes))\n            return callback(undefined, []);\n        if (full)\n            return callback(undefined, indexes);\n        callback(undefined, processResults(indexes));\n    });\n}\nexports.indexInformation = indexInformation;\nfunction prepareDocs(coll, docs, options) {\n    var _a;\n    const forceServerObjectId = typeof options.forceServerObjectId === 'boolean'\n        ? options.forceServerObjectId\n        : (_a = coll.s.db.options) === null || _a === void 0 ? void 0 : _a.forceServerObjectId;\n    // no need to modify the docs if server sets the ObjectId\n    if (forceServerObjectId === true) {\n        return docs;\n    }\n    return docs.map(doc => {\n        if (doc._id == null) {\n            doc._id = coll.s.pkFactory.createPk();\n        }\n        return doc;\n    });\n}\nexports.prepareDocs = prepareDocs;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}