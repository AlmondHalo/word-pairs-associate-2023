{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TopologyDescription = void 0;\n\nconst server_description_1 = require(\"./server_description\");\n\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\n\nconst common_1 = require(\"./common\");\n\nconst error_1 = require(\"../error\"); // constants related to compatibility checks\n\n\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([common_1.ServerType.RSSecondary, common_1.ServerType.RSArbiter, common_1.ServerType.RSOther]);\n/**\n * Representation of a deployment of servers\n * @public\n */\n\nclass TopologyDescription {\n  /**\n   * Create a TopologyDescription\n   */\n  constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n    var _a, _b;\n\n    options = options !== null && options !== void 0 ? options : {}; // TODO: consider assigning all these values to a temporary value `s` which\n    //       we use `Object.freeze` on, ensuring the internal state of this type\n    //       is immutable.\n\n    this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n    this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n    this.stale = false;\n    this.compatible = true;\n    this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n    this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 0;\n\n    if (setName) {\n      this.setName = setName;\n    }\n\n    if (maxSetVersion) {\n      this.maxSetVersion = maxSetVersion;\n    }\n\n    if (maxElectionId) {\n      this.maxElectionId = maxElectionId;\n    }\n\n    if (commonWireVersion) {\n      this.commonWireVersion = commonWireVersion;\n    } // determine server compatibility\n\n\n    for (const serverDescription of this.servers.values()) {\n      // Load balancer mode is always compatible.\n      if (serverDescription.type === common_1.ServerType.Unknown || serverDescription.type === common_1.ServerType.LoadBalancer) {\n        continue;\n      }\n\n      if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n      }\n\n      if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n        this.compatible = false;\n        this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n        break;\n      }\n    } // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n    // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n    // value among ServerDescriptions of all data-bearing server types. If any have a null\n    // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n    // set to null.\n\n\n    this.logicalSessionTimeoutMinutes = undefined;\n\n    for (const [, server] of this.servers) {\n      if (server.isReadable) {\n        if (server.logicalSessionTimeoutMinutes == null) {\n          // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n          this.logicalSessionTimeoutMinutes = undefined;\n          break;\n        }\n\n        if (this.logicalSessionTimeoutMinutes == null) {\n          // First server with a non null logicalSessionsTimeout\n          this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n          continue;\n        } // Always select the smaller of the:\n        // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n\n\n        this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n      }\n    }\n  }\n  /**\n   * Returns a new TopologyDescription based on the SrvPollingEvent\n   * @internal\n   */\n\n\n  updateFromSrvPollingEvent(ev) {\n    const newAddresses = ev.addresses();\n    const serverDescriptions = new Map(this.servers);\n\n    for (const address of this.servers.keys()) {\n      if (newAddresses.has(address)) {\n        newAddresses.delete(address);\n      } else {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n      return this;\n    }\n\n    for (const [address, host] of newAddresses) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(host));\n    }\n\n    return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n  /**\n   * Returns a copy of this description updated with a given ServerDescription\n   * @internal\n   */\n\n\n  update(serverDescription) {\n    const address = serverDescription.address; // potentially mutated values\n\n    let {\n      type: topologyType,\n      setName,\n      maxSetVersion,\n      maxElectionId,\n      commonWireVersion\n    } = this;\n\n    if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n      serverDescription = new server_description_1.ServerDescription(address, undefined);\n    }\n\n    const serverType = serverDescription.type;\n    const serverDescriptions = new Map(this.servers); // update common wire version\n\n    if (serverDescription.maxWireVersion !== 0) {\n      if (commonWireVersion == null) {\n        commonWireVersion = serverDescription.maxWireVersion;\n      } else {\n        commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n      }\n    } // update the actual server description\n\n\n    serverDescriptions.set(address, serverDescription);\n\n    if (topologyType === common_1.TopologyType.Single) {\n      // once we are defined as single, that never changes\n      return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n        heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n        localThresholdMS: this.localThresholdMS\n      });\n    }\n\n    if (topologyType === common_1.TopologyType.Unknown) {\n      if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n        serverDescriptions.delete(address);\n      } else {\n        topologyType = topologyTypeForServerType(serverType);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.Sharded) {\n      if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n      }\n\n      if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n        topologyType = result[0];\n        setName = result[1];\n      }\n    }\n\n    if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n      if (MONGOS_OR_STANDALONE.has(serverType)) {\n        serverDescriptions.delete(address);\n        topologyType = checkHasPrimary(serverDescriptions);\n      } else if (serverType === common_1.ServerType.RSPrimary) {\n        const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n        topologyType = result[0];\n        setName = result[1];\n        maxSetVersion = result[2];\n        maxElectionId = result[3];\n      } else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n        topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n      } else {\n        topologyType = checkHasPrimary(serverDescriptions);\n      }\n    }\n\n    return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, {\n      heartbeatFrequencyMS: this.heartbeatFrequencyMS,\n      localThresholdMS: this.localThresholdMS\n    });\n  }\n\n  get error() {\n    const descriptionsWithError = Array.from(this.servers.values()).filter(sd => sd.error);\n\n    if (descriptionsWithError.length > 0) {\n      return descriptionsWithError[0].error;\n    }\n  }\n  /**\n   * Determines if the topology description has any known servers\n   */\n\n\n  get hasKnownServers() {\n    return Array.from(this.servers.values()).some(sd => sd.type !== common_1.ServerType.Unknown);\n  }\n  /**\n   * Determines if this topology description has a data-bearing server available.\n   */\n\n\n  get hasDataBearingServers() {\n    return Array.from(this.servers.values()).some(sd => sd.isDataBearing);\n  }\n  /**\n   * Determines if the topology has a definition for the provided address\n   * @internal\n   */\n\n\n  hasServer(address) {\n    return this.servers.has(address);\n  }\n\n}\n\nexports.TopologyDescription = TopologyDescription;\n\nfunction topologyTypeForServerType(serverType) {\n  switch (serverType) {\n    case common_1.ServerType.Standalone:\n      return common_1.TopologyType.Single;\n\n    case common_1.ServerType.Mongos:\n      return common_1.TopologyType.Sharded;\n\n    case common_1.ServerType.RSPrimary:\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n\n    case common_1.ServerType.RSOther:\n    case common_1.ServerType.RSSecondary:\n      return common_1.TopologyType.ReplicaSetNoPrimary;\n\n    default:\n      return common_1.TopologyType.Unknown;\n  }\n} // TODO: improve these docs when ObjectId is properly typed\n\n\nfunction compareObjectId(oid1, oid2) {\n  if (oid1 == null) {\n    return -1;\n  }\n\n  if (oid2 == null) {\n    return 1;\n  }\n\n  if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n    const oid1Buffer = oid1.id;\n    const oid2Buffer = oid2.id;\n    return oid1Buffer.compare(oid2Buffer);\n  }\n\n  const oid1String = oid1.toString();\n  const oid2String = oid2.toString();\n  return oid1String.localeCompare(oid2String);\n}\n\nfunction updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n  }\n\n  const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n\n  if (serverDescription.setVersion && electionId) {\n    if (maxSetVersion && maxElectionId) {\n      if (maxSetVersion > serverDescription.setVersion || compareObjectId(maxElectionId, electionId) > 0) {\n        // this primary is stale, we must remove it\n        serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n      }\n    }\n\n    maxElectionId = serverDescription.electionId;\n  }\n\n  if (serverDescription.setVersion != null && (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n    maxSetVersion = serverDescription.setVersion;\n  } // We've heard from the primary. Is it the same primary as before?\n\n\n  for (const [address, server] of serverDescriptions) {\n    if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n      // Reset old primary's type to Unknown.\n      serverDescriptions.set(address, new server_description_1.ServerDescription(server.address)); // There can only be one primary\n\n      break;\n    }\n  } // Discover new hosts from this primary's response.\n\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  }); // Remove hosts not in the response.\n\n  const currentAddresses = Array.from(serverDescriptions.keys());\n  const responseAddresses = serverDescription.allHosts;\n  currentAddresses.filter(addr => responseAddresses.indexOf(addr) === -1).forEach(address => {\n    serverDescriptions.delete(address);\n  });\n  return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\n\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  if (setName == null) {\n    // TODO(NODE-3483): should be an appropriate runtime error\n    throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n  }\n\n  if (setName !== serverDescription.setName || serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return checkHasPrimary(serverDescriptions);\n}\n\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n  const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n  setName = setName || serverDescription.setName;\n\n  if (setName !== serverDescription.setName) {\n    serverDescriptions.delete(serverDescription.address);\n    return [topologyType, setName];\n  }\n\n  serverDescription.allHosts.forEach(address => {\n    if (!serverDescriptions.has(address)) {\n      serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n    }\n  });\n\n  if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n    serverDescriptions.delete(serverDescription.address);\n  }\n\n  return [topologyType, setName];\n}\n\nfunction checkHasPrimary(serverDescriptions) {\n  for (const serverDescription of serverDescriptions.values()) {\n    if (serverDescription.type === common_1.ServerType.RSPrimary) {\n      return common_1.TopologyType.ReplicaSetWithPrimary;\n    }\n  }\n\n  return common_1.TopologyType.ReplicaSetNoPrimary;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TopologyDescription","server_description_1","require","WIRE_CONSTANTS","common_1","error_1","MIN_SUPPORTED_SERVER_VERSION","MAX_SUPPORTED_SERVER_VERSION","MIN_SUPPORTED_WIRE_VERSION","MAX_SUPPORTED_WIRE_VERSION","MONGOS_OR_UNKNOWN","Set","ServerType","Mongos","Unknown","MONGOS_OR_STANDALONE","Standalone","NON_PRIMARY_RS_MEMBERS","RSSecondary","RSArbiter","RSOther","constructor","topologyType","serverDescriptions","setName","maxSetVersion","maxElectionId","commonWireVersion","options","_a","_b","type","TopologyType","servers","Map","stale","compatible","heartbeatFrequencyMS","localThresholdMS","serverDescription","values","LoadBalancer","minWireVersion","compatibilityError","address","maxWireVersion","logicalSessionTimeoutMinutes","undefined","server","isReadable","Math","min","updateFromSrvPollingEvent","ev","newAddresses","addresses","keys","has","delete","size","host","set","ServerDescription","update","serverType","Single","topologyTypeForServerType","Sharded","ReplicaSetNoPrimary","RSPrimary","result","updateRsFromPrimary","updateRsNoPrimaryFromMember","ReplicaSetWithPrimary","checkHasPrimary","updateRsWithPrimaryFromMember","error","descriptionsWithError","Array","from","filter","sd","length","hasKnownServers","some","hasDataBearingServers","isDataBearing","hasServer","compareObjectId","oid1","oid2","id","Buffer","oid1Buffer","oid2Buffer","compare","oid1String","toString","oid2String","localeCompare","electionId","setVersion","allHosts","forEach","currentAddresses","responseAddresses","addr","indexOf","MongoRuntimeError","me"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/sdam/topology_description.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TopologyDescription = void 0;\nconst server_description_1 = require(\"./server_description\");\nconst WIRE_CONSTANTS = require(\"../cmap/wire_protocol/constants\");\nconst common_1 = require(\"./common\");\nconst error_1 = require(\"../error\");\n// constants related to compatibility checks\nconst MIN_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_SERVER_VERSION;\nconst MAX_SUPPORTED_SERVER_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_SERVER_VERSION;\nconst MIN_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MIN_SUPPORTED_WIRE_VERSION;\nconst MAX_SUPPORTED_WIRE_VERSION = WIRE_CONSTANTS.MAX_SUPPORTED_WIRE_VERSION;\nconst MONGOS_OR_UNKNOWN = new Set([common_1.ServerType.Mongos, common_1.ServerType.Unknown]);\nconst MONGOS_OR_STANDALONE = new Set([common_1.ServerType.Mongos, common_1.ServerType.Standalone]);\nconst NON_PRIMARY_RS_MEMBERS = new Set([\n    common_1.ServerType.RSSecondary,\n    common_1.ServerType.RSArbiter,\n    common_1.ServerType.RSOther\n]);\n/**\n * Representation of a deployment of servers\n * @public\n */\nclass TopologyDescription {\n    /**\n     * Create a TopologyDescription\n     */\n    constructor(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, options) {\n        var _a, _b;\n        options = options !== null && options !== void 0 ? options : {};\n        // TODO: consider assigning all these values to a temporary value `s` which\n        //       we use `Object.freeze` on, ensuring the internal state of this type\n        //       is immutable.\n        this.type = topologyType !== null && topologyType !== void 0 ? topologyType : common_1.TopologyType.Unknown;\n        this.servers = serverDescriptions !== null && serverDescriptions !== void 0 ? serverDescriptions : new Map();\n        this.stale = false;\n        this.compatible = true;\n        this.heartbeatFrequencyMS = (_a = options.heartbeatFrequencyMS) !== null && _a !== void 0 ? _a : 0;\n        this.localThresholdMS = (_b = options.localThresholdMS) !== null && _b !== void 0 ? _b : 0;\n        if (setName) {\n            this.setName = setName;\n        }\n        if (maxSetVersion) {\n            this.maxSetVersion = maxSetVersion;\n        }\n        if (maxElectionId) {\n            this.maxElectionId = maxElectionId;\n        }\n        if (commonWireVersion) {\n            this.commonWireVersion = commonWireVersion;\n        }\n        // determine server compatibility\n        for (const serverDescription of this.servers.values()) {\n            // Load balancer mode is always compatible.\n            if (serverDescription.type === common_1.ServerType.Unknown ||\n                serverDescription.type === common_1.ServerType.LoadBalancer) {\n                continue;\n            }\n            if (serverDescription.minWireVersion > MAX_SUPPORTED_WIRE_VERSION) {\n                this.compatible = false;\n                this.compatibilityError = `Server at ${serverDescription.address} requires wire version ${serverDescription.minWireVersion}, but this version of the driver only supports up to ${MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${MAX_SUPPORTED_SERVER_VERSION})`;\n            }\n            if (serverDescription.maxWireVersion < MIN_SUPPORTED_WIRE_VERSION) {\n                this.compatible = false;\n                this.compatibilityError = `Server at ${serverDescription.address} reports wire version ${serverDescription.maxWireVersion}, but this version of the driver requires at least ${MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${MIN_SUPPORTED_SERVER_VERSION}).`;\n                break;\n            }\n        }\n        // Whenever a client updates the TopologyDescription from an ismaster response, it MUST set\n        // TopologyDescription.logicalSessionTimeoutMinutes to the smallest logicalSessionTimeoutMinutes\n        // value among ServerDescriptions of all data-bearing server types. If any have a null\n        // logicalSessionTimeoutMinutes, then TopologyDescription.logicalSessionTimeoutMinutes MUST be\n        // set to null.\n        this.logicalSessionTimeoutMinutes = undefined;\n        for (const [, server] of this.servers) {\n            if (server.isReadable) {\n                if (server.logicalSessionTimeoutMinutes == null) {\n                    // If any of the servers have a null logicalSessionsTimeout, then the whole topology does\n                    this.logicalSessionTimeoutMinutes = undefined;\n                    break;\n                }\n                if (this.logicalSessionTimeoutMinutes == null) {\n                    // First server with a non null logicalSessionsTimeout\n                    this.logicalSessionTimeoutMinutes = server.logicalSessionTimeoutMinutes;\n                    continue;\n                }\n                // Always select the smaller of the:\n                // current server logicalSessionsTimeout and the topologies logicalSessionsTimeout\n                this.logicalSessionTimeoutMinutes = Math.min(this.logicalSessionTimeoutMinutes, server.logicalSessionTimeoutMinutes);\n            }\n        }\n    }\n    /**\n     * Returns a new TopologyDescription based on the SrvPollingEvent\n     * @internal\n     */\n    updateFromSrvPollingEvent(ev) {\n        const newAddresses = ev.addresses();\n        const serverDescriptions = new Map(this.servers);\n        for (const address of this.servers.keys()) {\n            if (newAddresses.has(address)) {\n                newAddresses.delete(address);\n            }\n            else {\n                serverDescriptions.delete(address);\n            }\n        }\n        if (serverDescriptions.size === this.servers.size && newAddresses.size === 0) {\n            return this;\n        }\n        for (const [address, host] of newAddresses) {\n            serverDescriptions.set(address, new server_description_1.ServerDescription(host));\n        }\n        return new TopologyDescription(this.type, serverDescriptions, this.setName, this.maxSetVersion, this.maxElectionId, this.commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n    }\n    /**\n     * Returns a copy of this description updated with a given ServerDescription\n     * @internal\n     */\n    update(serverDescription) {\n        const address = serverDescription.address;\n        // potentially mutated values\n        let { type: topologyType, setName, maxSetVersion, maxElectionId, commonWireVersion } = this;\n        if (serverDescription.setName && setName && serverDescription.setName !== setName) {\n            serverDescription = new server_description_1.ServerDescription(address, undefined);\n        }\n        const serverType = serverDescription.type;\n        const serverDescriptions = new Map(this.servers);\n        // update common wire version\n        if (serverDescription.maxWireVersion !== 0) {\n            if (commonWireVersion == null) {\n                commonWireVersion = serverDescription.maxWireVersion;\n            }\n            else {\n                commonWireVersion = Math.min(commonWireVersion, serverDescription.maxWireVersion);\n            }\n        }\n        // update the actual server description\n        serverDescriptions.set(address, serverDescription);\n        if (topologyType === common_1.TopologyType.Single) {\n            // once we are defined as single, that never changes\n            return new TopologyDescription(common_1.TopologyType.Single, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n        }\n        if (topologyType === common_1.TopologyType.Unknown) {\n            if (serverType === common_1.ServerType.Standalone && this.servers.size !== 1) {\n                serverDescriptions.delete(address);\n            }\n            else {\n                topologyType = topologyTypeForServerType(serverType);\n            }\n        }\n        if (topologyType === common_1.TopologyType.Sharded) {\n            if (!MONGOS_OR_UNKNOWN.has(serverType)) {\n                serverDescriptions.delete(address);\n            }\n        }\n        if (topologyType === common_1.TopologyType.ReplicaSetNoPrimary) {\n            if (MONGOS_OR_STANDALONE.has(serverType)) {\n                serverDescriptions.delete(address);\n            }\n            if (serverType === common_1.ServerType.RSPrimary) {\n                const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n                topologyType = result[0];\n                setName = result[1];\n                maxSetVersion = result[2];\n                maxElectionId = result[3];\n            }\n            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n                const result = updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName);\n                topologyType = result[0];\n                setName = result[1];\n            }\n        }\n        if (topologyType === common_1.TopologyType.ReplicaSetWithPrimary) {\n            if (MONGOS_OR_STANDALONE.has(serverType)) {\n                serverDescriptions.delete(address);\n                topologyType = checkHasPrimary(serverDescriptions);\n            }\n            else if (serverType === common_1.ServerType.RSPrimary) {\n                const result = updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId);\n                topologyType = result[0];\n                setName = result[1];\n                maxSetVersion = result[2];\n                maxElectionId = result[3];\n            }\n            else if (NON_PRIMARY_RS_MEMBERS.has(serverType)) {\n                topologyType = updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName);\n            }\n            else {\n                topologyType = checkHasPrimary(serverDescriptions);\n            }\n        }\n        return new TopologyDescription(topologyType, serverDescriptions, setName, maxSetVersion, maxElectionId, commonWireVersion, { heartbeatFrequencyMS: this.heartbeatFrequencyMS, localThresholdMS: this.localThresholdMS });\n    }\n    get error() {\n        const descriptionsWithError = Array.from(this.servers.values()).filter((sd) => sd.error);\n        if (descriptionsWithError.length > 0) {\n            return descriptionsWithError[0].error;\n        }\n    }\n    /**\n     * Determines if the topology description has any known servers\n     */\n    get hasKnownServers() {\n        return Array.from(this.servers.values()).some((sd) => sd.type !== common_1.ServerType.Unknown);\n    }\n    /**\n     * Determines if this topology description has a data-bearing server available.\n     */\n    get hasDataBearingServers() {\n        return Array.from(this.servers.values()).some((sd) => sd.isDataBearing);\n    }\n    /**\n     * Determines if the topology has a definition for the provided address\n     * @internal\n     */\n    hasServer(address) {\n        return this.servers.has(address);\n    }\n}\nexports.TopologyDescription = TopologyDescription;\nfunction topologyTypeForServerType(serverType) {\n    switch (serverType) {\n        case common_1.ServerType.Standalone:\n            return common_1.TopologyType.Single;\n        case common_1.ServerType.Mongos:\n            return common_1.TopologyType.Sharded;\n        case common_1.ServerType.RSPrimary:\n            return common_1.TopologyType.ReplicaSetWithPrimary;\n        case common_1.ServerType.RSOther:\n        case common_1.ServerType.RSSecondary:\n            return common_1.TopologyType.ReplicaSetNoPrimary;\n        default:\n            return common_1.TopologyType.Unknown;\n    }\n}\n// TODO: improve these docs when ObjectId is properly typed\nfunction compareObjectId(oid1, oid2) {\n    if (oid1 == null) {\n        return -1;\n    }\n    if (oid2 == null) {\n        return 1;\n    }\n    if (oid1.id instanceof Buffer && oid2.id instanceof Buffer) {\n        const oid1Buffer = oid1.id;\n        const oid2Buffer = oid2.id;\n        return oid1Buffer.compare(oid2Buffer);\n    }\n    const oid1String = oid1.toString();\n    const oid2String = oid2.toString();\n    return oid1String.localeCompare(oid2String);\n}\nfunction updateRsFromPrimary(serverDescriptions, serverDescription, setName, maxSetVersion, maxElectionId) {\n    setName = setName || serverDescription.setName;\n    if (setName !== serverDescription.setName) {\n        serverDescriptions.delete(serverDescription.address);\n        return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n    }\n    const electionId = serverDescription.electionId ? serverDescription.electionId : null;\n    if (serverDescription.setVersion && electionId) {\n        if (maxSetVersion && maxElectionId) {\n            if (maxSetVersion > serverDescription.setVersion ||\n                compareObjectId(maxElectionId, electionId) > 0) {\n                // this primary is stale, we must remove it\n                serverDescriptions.set(serverDescription.address, new server_description_1.ServerDescription(serverDescription.address));\n                return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n            }\n        }\n        maxElectionId = serverDescription.electionId;\n    }\n    if (serverDescription.setVersion != null &&\n        (maxSetVersion == null || serverDescription.setVersion > maxSetVersion)) {\n        maxSetVersion = serverDescription.setVersion;\n    }\n    // We've heard from the primary. Is it the same primary as before?\n    for (const [address, server] of serverDescriptions) {\n        if (server.type === common_1.ServerType.RSPrimary && server.address !== serverDescription.address) {\n            // Reset old primary's type to Unknown.\n            serverDescriptions.set(address, new server_description_1.ServerDescription(server.address));\n            // There can only be one primary\n            break;\n        }\n    }\n    // Discover new hosts from this primary's response.\n    serverDescription.allHosts.forEach((address) => {\n        if (!serverDescriptions.has(address)) {\n            serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n        }\n    });\n    // Remove hosts not in the response.\n    const currentAddresses = Array.from(serverDescriptions.keys());\n    const responseAddresses = serverDescription.allHosts;\n    currentAddresses\n        .filter((addr) => responseAddresses.indexOf(addr) === -1)\n        .forEach((address) => {\n        serverDescriptions.delete(address);\n    });\n    return [checkHasPrimary(serverDescriptions), setName, maxSetVersion, maxElectionId];\n}\nfunction updateRsWithPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n    if (setName == null) {\n        // TODO(NODE-3483): should be an appropriate runtime error\n        throw new error_1.MongoRuntimeError('Argument \"setName\" is required if connected to a replica set');\n    }\n    if (setName !== serverDescription.setName ||\n        (serverDescription.me && serverDescription.address !== serverDescription.me)) {\n        serverDescriptions.delete(serverDescription.address);\n    }\n    return checkHasPrimary(serverDescriptions);\n}\nfunction updateRsNoPrimaryFromMember(serverDescriptions, serverDescription, setName) {\n    const topologyType = common_1.TopologyType.ReplicaSetNoPrimary;\n    setName = setName || serverDescription.setName;\n    if (setName !== serverDescription.setName) {\n        serverDescriptions.delete(serverDescription.address);\n        return [topologyType, setName];\n    }\n    serverDescription.allHosts.forEach((address) => {\n        if (!serverDescriptions.has(address)) {\n            serverDescriptions.set(address, new server_description_1.ServerDescription(address));\n        }\n    });\n    if (serverDescription.me && serverDescription.address !== serverDescription.me) {\n        serverDescriptions.delete(serverDescription.address);\n    }\n    return [topologyType, setName];\n}\nfunction checkHasPrimary(serverDescriptions) {\n    for (const serverDescription of serverDescriptions.values()) {\n        if (serverDescription.type === common_1.ServerType.RSPrimary) {\n            return common_1.TopologyType.ReplicaSetWithPrimary;\n        }\n    }\n    return common_1.TopologyType.ReplicaSetNoPrimary;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}