{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SrvPoller = exports.SrvPollingEvent = void 0;\n\nconst dns = require(\"dns\");\n\nconst logger_1 = require(\"../logger\");\n\nconst utils_1 = require(\"../utils\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n\nconst error_1 = require(\"../error\");\n/**\n * Determines whether a provided address matches the provided parent domain in order\n * to avoid certain attack vectors.\n *\n * @param srvAddress - The address to check against a domain\n * @param parentDomain - The domain to check the provided address against\n * @returns Whether the provided address matches the parent domain\n */\n\n\nfunction matchesParentDomain(srvAddress, parentDomain) {\n  const regex = /^.*?\\./;\n  const srv = `.${srvAddress.replace(regex, '')}`;\n  const parent = `.${parentDomain.replace(regex, '')}`;\n  return srv.endsWith(parent);\n}\n/**\n * @internal\n * @category Event\n */\n\n\nclass SrvPollingEvent {\n  constructor(srvRecords) {\n    this.srvRecords = srvRecords;\n  }\n\n  addresses() {\n    return new Map(this.srvRecords.map(record => {\n      const host = new utils_1.HostAddress(`${record.name}:${record.port}`);\n      return [host.toString(), host];\n    }));\n  }\n\n}\n\nexports.SrvPollingEvent = SrvPollingEvent;\n/** @internal */\n\nclass SrvPoller extends mongo_types_1.TypedEventEmitter {\n  constructor(options) {\n    super();\n\n    if (!options || !options.srvHost) {\n      throw new error_1.MongoRuntimeError('Options for SrvPoller must exist and include srvHost');\n    }\n\n    this.srvHost = options.srvHost;\n    this.rescanSrvIntervalMS = 60000;\n    this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\n    this.logger = new logger_1.Logger('srvPoller', options);\n    this.haMode = false;\n    this.generation = 0;\n    this._timeout = undefined;\n  }\n\n  get srvAddress() {\n    return `_mongodb._tcp.${this.srvHost}`;\n  }\n\n  get intervalMS() {\n    return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;\n  }\n\n  start() {\n    if (!this._timeout) {\n      this.schedule();\n    }\n  }\n\n  stop() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n      this.generation += 1;\n      this._timeout = undefined;\n    }\n  }\n\n  schedule() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    this._timeout = setTimeout(() => this._poll(), this.intervalMS);\n  }\n\n  success(srvRecords) {\n    this.haMode = false;\n    this.schedule();\n    this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));\n  }\n\n  failure(message, obj) {\n    this.logger.warn(message, obj);\n    this.haMode = true;\n    this.schedule();\n  }\n\n  parentDomainMismatch(srvRecord) {\n    this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);\n  }\n\n  _poll() {\n    const generation = this.generation;\n    dns.resolveSrv(this.srvAddress, (err, srvRecords) => {\n      if (generation !== this.generation) {\n        return;\n      }\n\n      if (err) {\n        this.failure('DNS error', err);\n        return;\n      }\n\n      const finalAddresses = [];\n      srvRecords.forEach(record => {\n        if (matchesParentDomain(record.name, this.srvHost)) {\n          finalAddresses.push(record);\n        } else {\n          this.parentDomainMismatch(record);\n        }\n      });\n\n      if (!finalAddresses.length) {\n        this.failure('No valid addresses found at host');\n        return;\n      }\n\n      this.success(finalAddresses);\n    });\n  }\n\n}\n\nexports.SrvPoller = SrvPoller;\n/** @event */\n\nSrvPoller.SRV_RECORD_DISCOVERY = 'srvRecordDiscovery';","map":{"version":3,"names":["Object","defineProperty","exports","value","SrvPoller","SrvPollingEvent","dns","require","logger_1","utils_1","mongo_types_1","error_1","matchesParentDomain","srvAddress","parentDomain","regex","srv","replace","parent","endsWith","constructor","srvRecords","addresses","Map","map","record","host","HostAddress","name","port","toString","TypedEventEmitter","options","srvHost","MongoRuntimeError","rescanSrvIntervalMS","heartbeatFrequencyMS","logger","Logger","haMode","generation","_timeout","undefined","intervalMS","start","schedule","stop","clearTimeout","setTimeout","_poll","success","emit","SRV_RECORD_DISCOVERY","failure","message","obj","warn","parentDomainMismatch","srvRecord","resolveSrv","err","finalAddresses","forEach","push","length"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/sdam/srv_polling.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SrvPoller = exports.SrvPollingEvent = void 0;\nconst dns = require(\"dns\");\nconst logger_1 = require(\"../logger\");\nconst utils_1 = require(\"../utils\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst error_1 = require(\"../error\");\n/**\n * Determines whether a provided address matches the provided parent domain in order\n * to avoid certain attack vectors.\n *\n * @param srvAddress - The address to check against a domain\n * @param parentDomain - The domain to check the provided address against\n * @returns Whether the provided address matches the parent domain\n */\nfunction matchesParentDomain(srvAddress, parentDomain) {\n    const regex = /^.*?\\./;\n    const srv = `.${srvAddress.replace(regex, '')}`;\n    const parent = `.${parentDomain.replace(regex, '')}`;\n    return srv.endsWith(parent);\n}\n/**\n * @internal\n * @category Event\n */\nclass SrvPollingEvent {\n    constructor(srvRecords) {\n        this.srvRecords = srvRecords;\n    }\n    addresses() {\n        return new Map(this.srvRecords.map(record => {\n            const host = new utils_1.HostAddress(`${record.name}:${record.port}`);\n            return [host.toString(), host];\n        }));\n    }\n}\nexports.SrvPollingEvent = SrvPollingEvent;\n/** @internal */\nclass SrvPoller extends mongo_types_1.TypedEventEmitter {\n    constructor(options) {\n        super();\n        if (!options || !options.srvHost) {\n            throw new error_1.MongoRuntimeError('Options for SrvPoller must exist and include srvHost');\n        }\n        this.srvHost = options.srvHost;\n        this.rescanSrvIntervalMS = 60000;\n        this.heartbeatFrequencyMS = options.heartbeatFrequencyMS || 10000;\n        this.logger = new logger_1.Logger('srvPoller', options);\n        this.haMode = false;\n        this.generation = 0;\n        this._timeout = undefined;\n    }\n    get srvAddress() {\n        return `_mongodb._tcp.${this.srvHost}`;\n    }\n    get intervalMS() {\n        return this.haMode ? this.heartbeatFrequencyMS : this.rescanSrvIntervalMS;\n    }\n    start() {\n        if (!this._timeout) {\n            this.schedule();\n        }\n    }\n    stop() {\n        if (this._timeout) {\n            clearTimeout(this._timeout);\n            this.generation += 1;\n            this._timeout = undefined;\n        }\n    }\n    schedule() {\n        if (this._timeout) {\n            clearTimeout(this._timeout);\n        }\n        this._timeout = setTimeout(() => this._poll(), this.intervalMS);\n    }\n    success(srvRecords) {\n        this.haMode = false;\n        this.schedule();\n        this.emit(SrvPoller.SRV_RECORD_DISCOVERY, new SrvPollingEvent(srvRecords));\n    }\n    failure(message, obj) {\n        this.logger.warn(message, obj);\n        this.haMode = true;\n        this.schedule();\n    }\n    parentDomainMismatch(srvRecord) {\n        this.logger.warn(`parent domain mismatch on SRV record (${srvRecord.name}:${srvRecord.port})`, srvRecord);\n    }\n    _poll() {\n        const generation = this.generation;\n        dns.resolveSrv(this.srvAddress, (err, srvRecords) => {\n            if (generation !== this.generation) {\n                return;\n            }\n            if (err) {\n                this.failure('DNS error', err);\n                return;\n            }\n            const finalAddresses = [];\n            srvRecords.forEach((record) => {\n                if (matchesParentDomain(record.name, this.srvHost)) {\n                    finalAddresses.push(record);\n                }\n                else {\n                    this.parentDomainMismatch(record);\n                }\n            });\n            if (!finalAddresses.length) {\n                this.failure('No valid addresses found at host');\n                return;\n            }\n            this.success(finalAddresses);\n        });\n    }\n}\nexports.SrvPoller = SrvPoller;\n/** @event */\nSrvPoller.SRV_RECORD_DISCOVERY = 'srvRecordDiscovery';\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}