{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\n\nconst net = require(\"net\");\n\nconst tls = require(\"tls\");\n\nconst connection_1 = require(\"./connection\");\n\nconst error_1 = require(\"../error\");\n\nconst defaultAuthProviders_1 = require(\"./auth/defaultAuthProviders\");\n\nconst auth_provider_1 = require(\"./auth/auth_provider\");\n\nconst utils_1 = require(\"../utils\");\n\nconst constants_1 = require(\"./wire_protocol/constants\");\n\nconst bson_1 = require(\"../bson\");\n\nconst FAKE_MONGODB_SERVICE_ID = typeof process.env.FAKE_MONGODB_SERVICE_ID === 'string' && process.env.FAKE_MONGODB_SERVICE_ID.toLowerCase() === 'true';\n\nfunction connect(options, callback) {\n  makeConnection(options, (err, socket) => {\n    var _a;\n\n    if (err || !socket) {\n      return callback(err);\n    }\n\n    let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\n\nexports.connect = connect;\n\nfunction checkSupportedServer(ismaster, options) {\n  var _a;\n\n  const serverVersionHighEnough = ismaster && (typeof ismaster.maxWireVersion === 'number' || ismaster.maxWireVersion instanceof bson_1.Int32) && ismaster.maxWireVersion >= constants_1.MIN_SUPPORTED_WIRE_VERSION;\n  const serverVersionLowEnough = ismaster && (typeof ismaster.minWireVersion === 'number' || ismaster.minWireVersion instanceof bson_1.Int32) && ismaster.minWireVersion <= constants_1.MAX_SUPPORTED_WIRE_VERSION;\n\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n\n    const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(ismaster.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_1.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MAX_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n  }\n\n  const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(ismaster.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_1.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MIN_SUPPORTED_SERVER_VERSION})`;\n  return new error_1.MongoCompatibilityError(message);\n}\n\nfunction performInitialHandshake(conn, options, _callback) {\n  const callback = function (err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  const credentials = options.credentials;\n\n  if (credentials) {\n    if (!(credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT) && !defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n      return;\n    }\n  }\n\n  const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n\n    const handshakeOptions = Object.assign({}, options);\n\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n\n    const start = new Date().getTime();\n    conn.command(utils_1.ns('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n\n      if ('isWritablePrimary' in response) {\n        // Provide pre-hello-style response document.\n        response.ismaster = response.isWritablePrimary;\n      }\n\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n\n      const supportedServerErr = checkSupportedServer(response, options);\n\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n\n      if (options.loadBalanced) {\n        // TODO: Durran: Remove when server support exists. (NODE-3431)\n        if (FAKE_MONGODB_SERVICE_ID) {\n          response.serviceId = response.topologyVersion.processId;\n        }\n\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      } // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n\n\n      conn.ismaster = response;\n      conn.lastIsMasterMS = new Date().getTime() - start;\n\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        const resolvedCredentials = credentials.resolveAuthMechanism(response);\n        const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n        }\n\n        provider.auth(authContext, err => {\n          if (err) return callback(err);\n          callback(undefined, conn);\n        });\n        return;\n      }\n\n      callback(undefined, conn);\n    });\n  });\n}\n\nfunction prepareHandshakeDocument(authContext, callback) {\n  const options = authContext.options;\n  const compressors = options.compressors ? options.compressors : [];\n  const {\n    serverApi\n  } = authContext.connection;\n  const handshakeDoc = {\n    [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : 'ismaster']: true,\n    helloOk: true,\n    client: options.metadata || utils_1.makeClientMetadata(options),\n    compression: compressors,\n    loadBalanced: options.loadBalanced\n  };\n  const credentials = authContext.credentials;\n\n  if (credentials) {\n    if (credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n      const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n\n      if (!provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n      }\n\n      return provider.prepare(handshakeDoc, authContext, callback);\n    }\n\n    const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism);\n\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n    }\n\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n\n  callback(undefined, handshakeDoc);\n}\n/** @public */\n\n\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\n\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\n\nfunction parseConnectOptions(options) {\n  const hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  const result = {};\n\n  for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  }\n\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n  }\n}\n\nfunction parseSslOptions(options) {\n  const result = parseConnectOptions(options); // Merge in valid SSL options\n\n  for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n    if (options[name] != null) {\n      result[name] = options[name];\n    }\n  } // Set default sni servername to be the same as host\n\n\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n\n  return result;\n}\n\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\n\nfunction makeConnection(options, _callback) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n\n  const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n  const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n  const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n  const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n  const connectionTimeout = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n  const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n  const keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;\n  let socket;\n\n  const callback = function (err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n\n    _callback(err, ret);\n  };\n\n  if (useTLS) {\n    const tlsSocket = tls.connect(parseSslOptions(options));\n\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n\n    socket = tlsSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectionTimeout);\n  socket.setNoDelay(noDelay);\n  const connectEvent = useTLS ? 'secureConnect' : 'connect';\n  let cancellationHandler;\n\n  function errorHandler(eventName) {\n    return err => {\n      SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n\n  SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n\n  socket.once(connectEvent, connectHandler);\n}\n\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","LEGAL_TCP_SOCKET_OPTIONS","LEGAL_TLS_SOCKET_OPTIONS","connect","net","require","tls","connection_1","error_1","defaultAuthProviders_1","auth_provider_1","utils_1","constants_1","bson_1","FAKE_MONGODB_SERVICE_ID","process","env","toLowerCase","options","callback","makeConnection","err","socket","_a","ConnectionType","connectionType","Connection","autoEncrypter","CryptoConnection","performInitialHandshake","checkSupportedServer","ismaster","serverVersionHighEnough","maxWireVersion","Int32","MIN_SUPPORTED_WIRE_VERSION","serverVersionLowEnough","minWireVersion","MAX_SUPPORTED_WIRE_VERSION","message","hostAddress","JSON","stringify","MAX_SUPPORTED_SERVER_VERSION","MongoCompatibilityError","MIN_SUPPORTED_SERVER_VERSION","conn","_callback","ret","destroy","credentials","mechanism","AuthMechanism","MONGODB_DEFAULT","AUTH_PROVIDERS","get","MongoInvalidArgumentError","authContext","AuthContext","prepareHandshakeDocument","handshakeDoc","handshakeOptions","assign","connectTimeoutMS","socketTimeoutMS","start","Date","getTime","command","ns","response","ok","MongoServerError","isWritablePrimary","helloOk","supportedServerErr","loadBalanced","serviceId","topologyVersion","processId","lastIsMasterMS","arbiterOnly","resolvedCredentials","resolveAuthMechanism","provider","auth","undefined","compressors","serverApi","connection","version","client","metadata","makeClientMetadata","compression","username","saslSupportedMechs","source","MONGODB_SCRAM_SHA256","prepare","parseConnectOptions","result","name","socketPath","path","host","port","MongoRuntimeError","parseSslOptions","servername","isIP","SOCKET_ERROR_EVENT_LIST","SOCKET_ERROR_EVENTS","Set","_b","_c","_d","_e","_f","_g","_h","_j","useTLS","keepAlive","Reflect","noDelay","connectionTimeout","rejectUnauthorized","keepAliveInitialDelay","Math","round","tlsSocket","disableRenegotiation","createConnection","setKeepAlive","setTimeout","setNoDelay","connectEvent","cancellationHandler","errorHandler","eventName","forEach","event","removeAllListeners","cancellationToken","removeListener","connectHandler","connectionFailureError","authorizationError","once","type","MongoNetworkError","MongoNetworkTimeoutError"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/cmap/connect.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.connect = void 0;\nconst net = require(\"net\");\nconst tls = require(\"tls\");\nconst connection_1 = require(\"./connection\");\nconst error_1 = require(\"../error\");\nconst defaultAuthProviders_1 = require(\"./auth/defaultAuthProviders\");\nconst auth_provider_1 = require(\"./auth/auth_provider\");\nconst utils_1 = require(\"../utils\");\nconst constants_1 = require(\"./wire_protocol/constants\");\nconst bson_1 = require(\"../bson\");\nconst FAKE_MONGODB_SERVICE_ID = typeof process.env.FAKE_MONGODB_SERVICE_ID === 'string' &&\n    process.env.FAKE_MONGODB_SERVICE_ID.toLowerCase() === 'true';\nfunction connect(options, callback) {\n    makeConnection(options, (err, socket) => {\n        var _a;\n        if (err || !socket) {\n            return callback(err);\n        }\n        let ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n        if (options.autoEncrypter) {\n            ConnectionType = connection_1.CryptoConnection;\n        }\n        performInitialHandshake(new ConnectionType(socket, options), options, callback);\n    });\n}\nexports.connect = connect;\nfunction checkSupportedServer(ismaster, options) {\n    var _a;\n    const serverVersionHighEnough = ismaster &&\n        (typeof ismaster.maxWireVersion === 'number' || ismaster.maxWireVersion instanceof bson_1.Int32) &&\n        ismaster.maxWireVersion >= constants_1.MIN_SUPPORTED_WIRE_VERSION;\n    const serverVersionLowEnough = ismaster &&\n        (typeof ismaster.minWireVersion === 'number' || ismaster.minWireVersion instanceof bson_1.Int32) &&\n        ismaster.minWireVersion <= constants_1.MAX_SUPPORTED_WIRE_VERSION;\n    if (serverVersionHighEnough) {\n        if (serverVersionLowEnough) {\n            return null;\n        }\n        const message = `Server at ${options.hostAddress} reports minimum wire version ${JSON.stringify(ismaster.minWireVersion)}, but this version of the Node.js Driver requires at most ${constants_1.MAX_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MAX_SUPPORTED_SERVER_VERSION})`;\n        return new error_1.MongoCompatibilityError(message);\n    }\n    const message = `Server at ${options.hostAddress} reports maximum wire version ${(_a = JSON.stringify(ismaster.maxWireVersion)) !== null && _a !== void 0 ? _a : 0}, but this version of the Node.js Driver requires at least ${constants_1.MIN_SUPPORTED_WIRE_VERSION} (MongoDB ${constants_1.MIN_SUPPORTED_SERVER_VERSION})`;\n    return new error_1.MongoCompatibilityError(message);\n}\nfunction performInitialHandshake(conn, options, _callback) {\n    const callback = function (err, ret) {\n        if (err && conn) {\n            conn.destroy();\n        }\n        _callback(err, ret);\n    };\n    const credentials = options.credentials;\n    if (credentials) {\n        if (!(credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT) &&\n            !defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism)) {\n            callback(new error_1.MongoInvalidArgumentError(`AuthMechanism '${credentials.mechanism}' not supported`));\n            return;\n        }\n    }\n    const authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n    prepareHandshakeDocument(authContext, (err, handshakeDoc) => {\n        if (err || !handshakeDoc) {\n            return callback(err);\n        }\n        const handshakeOptions = Object.assign({}, options);\n        if (typeof options.connectTimeoutMS === 'number') {\n            // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n            handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n        }\n        const start = new Date().getTime();\n        conn.command(utils_1.ns('admin.$cmd'), handshakeDoc, handshakeOptions, (err, response) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n                callback(new error_1.MongoServerError(response));\n                return;\n            }\n            if ('isWritablePrimary' in response) {\n                // Provide pre-hello-style response document.\n                response.ismaster = response.isWritablePrimary;\n            }\n            if (response.helloOk) {\n                conn.helloOk = true;\n            }\n            const supportedServerErr = checkSupportedServer(response, options);\n            if (supportedServerErr) {\n                callback(supportedServerErr);\n                return;\n            }\n            if (options.loadBalanced) {\n                // TODO: Durran: Remove when server support exists. (NODE-3431)\n                if (FAKE_MONGODB_SERVICE_ID) {\n                    response.serviceId = response.topologyVersion.processId;\n                }\n                if (!response.serviceId) {\n                    return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' +\n                        'but the server does not support this mode.'));\n                }\n            }\n            // NOTE: This is metadata attached to the connection while porting away from\n            //       handshake being done in the `Server` class. Likely, it should be\n            //       relocated, or at very least restructured.\n            conn.ismaster = response;\n            conn.lastIsMasterMS = new Date().getTime() - start;\n            if (!response.arbiterOnly && credentials) {\n                // store the response on auth context\n                authContext.response = response;\n                const resolvedCredentials = credentials.resolveAuthMechanism(response);\n                const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n                if (!provider) {\n                    return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${resolvedCredentials.mechanism} defined.`));\n                }\n                provider.auth(authContext, err => {\n                    if (err)\n                        return callback(err);\n                    callback(undefined, conn);\n                });\n                return;\n            }\n            callback(undefined, conn);\n        });\n    });\n}\nfunction prepareHandshakeDocument(authContext, callback) {\n    const options = authContext.options;\n    const compressors = options.compressors ? options.compressors : [];\n    const { serverApi } = authContext.connection;\n    const handshakeDoc = {\n        [(serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : 'ismaster']: true,\n        helloOk: true,\n        client: options.metadata || utils_1.makeClientMetadata(options),\n        compression: compressors,\n        loadBalanced: options.loadBalanced\n    };\n    const credentials = authContext.credentials;\n    if (credentials) {\n        if (credentials.mechanism === defaultAuthProviders_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n            handshakeDoc.saslSupportedMechs = `${credentials.source}.${credentials.username}`;\n            const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n            if (!provider) {\n                // This auth mechanism is always present.\n                return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${defaultAuthProviders_1.AuthMechanism.MONGODB_SCRAM_SHA256} defined.`));\n            }\n            return provider.prepare(handshakeDoc, authContext, callback);\n        }\n        const provider = defaultAuthProviders_1.AUTH_PROVIDERS.get(credentials.mechanism);\n        if (!provider) {\n            return callback(new error_1.MongoInvalidArgumentError(`No AuthProvider for ${credentials.mechanism} defined.`));\n        }\n        return provider.prepare(handshakeDoc, authContext, callback);\n    }\n    callback(undefined, handshakeDoc);\n}\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = [\n    'ALPNProtocols',\n    'ca',\n    'cert',\n    'checkServerIdentity',\n    'ciphers',\n    'crl',\n    'ecdhCurve',\n    'key',\n    'minDHSize',\n    'passphrase',\n    'pfx',\n    'rejectUnauthorized',\n    'secureContext',\n    'secureProtocol',\n    'servername',\n    'session'\n];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = [\n    'family',\n    'hints',\n    'localAddress',\n    'localPort',\n    'lookup'\n];\nfunction parseConnectOptions(options) {\n    const hostAddress = options.hostAddress;\n    if (!hostAddress)\n        throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n    const result = {};\n    for (const name of exports.LEGAL_TCP_SOCKET_OPTIONS) {\n        if (options[name] != null) {\n            result[name] = options[name];\n        }\n    }\n    if (typeof hostAddress.socketPath === 'string') {\n        result.path = hostAddress.socketPath;\n        return result;\n    }\n    else if (typeof hostAddress.host === 'string') {\n        result.host = hostAddress.host;\n        result.port = hostAddress.port;\n        return result;\n    }\n    else {\n        // This should never happen since we set up HostAddresses\n        // But if we don't throw here the socket could hang until timeout\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError(`Unexpected HostAddress ${JSON.stringify(hostAddress)}`);\n    }\n}\nfunction parseSslOptions(options) {\n    const result = parseConnectOptions(options);\n    // Merge in valid SSL options\n    for (const name of exports.LEGAL_TLS_SOCKET_OPTIONS) {\n        if (options[name] != null) {\n            result[name] = options[name];\n        }\n    }\n    // Set default sni servername to be the same as host\n    if (result.servername == null && result.host && !net.isIP(result.host)) {\n        result.servername = result.host;\n    }\n    return result;\n}\nconst SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nconst SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n    const useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n    const keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n    const socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n    const noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n    const connectionTimeout = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n    const rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n    const keepAliveInitialDelay = (_j = (((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS\n        ? Math.round(socketTimeoutMS / 2)\n        : options.keepAliveInitialDelay)) !== null && _j !== void 0 ? _j : 120000;\n    let socket;\n    const callback = function (err, ret) {\n        if (err && socket) {\n            socket.destroy();\n        }\n        _callback(err, ret);\n    };\n    if (useTLS) {\n        const tlsSocket = tls.connect(parseSslOptions(options));\n        if (typeof tlsSocket.disableRenegotiation === 'function') {\n            tlsSocket.disableRenegotiation();\n        }\n        socket = tlsSocket;\n    }\n    else {\n        socket = net.createConnection(parseConnectOptions(options));\n    }\n    socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n    socket.setTimeout(connectionTimeout);\n    socket.setNoDelay(noDelay);\n    const connectEvent = useTLS ? 'secureConnect' : 'connect';\n    let cancellationHandler;\n    function errorHandler(eventName) {\n        return (err) => {\n            SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n            if (cancellationHandler && options.cancellationToken) {\n                options.cancellationToken.removeListener('cancel', cancellationHandler);\n            }\n            socket.removeListener(connectEvent, connectHandler);\n            callback(connectionFailureError(eventName, err));\n        };\n    }\n    function connectHandler() {\n        SOCKET_ERROR_EVENTS.forEach(event => socket.removeAllListeners(event));\n        if (cancellationHandler && options.cancellationToken) {\n            options.cancellationToken.removeListener('cancel', cancellationHandler);\n        }\n        if ('authorizationError' in socket) {\n            if (socket.authorizationError && rejectUnauthorized) {\n                return callback(socket.authorizationError);\n            }\n        }\n        socket.setTimeout(socketTimeoutMS);\n        callback(undefined, socket);\n    }\n    SOCKET_ERROR_EVENTS.forEach(event => socket.once(event, errorHandler(event)));\n    if (options.cancellationToken) {\n        cancellationHandler = errorHandler('cancel');\n        options.cancellationToken.once('cancel', cancellationHandler);\n    }\n    socket.once(connectEvent, connectHandler);\n}\nfunction connectionFailureError(type, err) {\n    switch (type) {\n        case 'error':\n            return new error_1.MongoNetworkError(err);\n        case 'timeout':\n            return new error_1.MongoNetworkTimeoutError('connection timed out');\n        case 'close':\n            return new error_1.MongoNetworkError('connection closed');\n        case 'cancel':\n            return new error_1.MongoNetworkError('connection establishment was cancelled');\n        default:\n            return new error_1.MongoNetworkError('unknown network error');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}