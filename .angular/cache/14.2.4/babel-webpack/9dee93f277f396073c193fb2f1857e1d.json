{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CMAP_EVENTS = exports.ConnectionPool = void 0;\n\nconst Denque = require(\"denque\");\n\nconst connection_1 = require(\"./connection\");\n\nconst logger_1 = require(\"../logger\");\n\nconst metrics_1 = require(\"./metrics\");\n\nconst connect_1 = require(\"./connect\");\n\nconst utils_1 = require(\"../utils\");\n\nconst error_1 = require(\"../error\");\n\nconst errors_1 = require(\"./errors\");\n\nconst connection_pool_events_1 = require(\"./connection_pool_events\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\n\n\nconst kLogger = Symbol('logger');\n/** @internal */\n\nconst kConnections = Symbol('connections');\n/** @internal */\n\nconst kPermits = Symbol('permits');\n/** @internal */\n\nconst kMinPoolSizeTimer = Symbol('minPoolSizeTimer');\n/** @internal */\n\nconst kGeneration = Symbol('generation');\n/** @internal */\n\nconst kServiceGenerations = Symbol('serviceGenerations');\n/** @internal */\n\nconst kConnectionCounter = Symbol('connectionCounter');\n/** @internal */\n\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\n\nconst kWaitQueue = Symbol('waitQueue');\n/** @internal */\n\nconst kCancelled = Symbol('cancelled');\n/** @internal */\n\nconst kMetrics = Symbol('metrics');\n/** @internal */\n\nconst kCheckedOut = Symbol('checkedOut');\n/** @internal */\n\nconst kProcessingWaitQueue = Symbol('processingWaitQueue');\n/**\n * A pool of connections which dynamically resizes, and emit events related to pool activity\n * @internal\n */\n\nclass ConnectionPool extends mongo_types_1.TypedEventEmitter {\n  /** @internal */\n  constructor(options) {\n    var _a, _b, _c, _d;\n\n    super();\n    this.closed = false;\n    this.options = Object.freeze({ ...options,\n      connectionType: connection_1.Connection,\n      maxPoolSize: (_a = options.maxPoolSize) !== null && _a !== void 0 ? _a : 100,\n      minPoolSize: (_b = options.minPoolSize) !== null && _b !== void 0 ? _b : 0,\n      maxIdleTimeMS: (_c = options.maxIdleTimeMS) !== null && _c !== void 0 ? _c : 0,\n      waitQueueTimeoutMS: (_d = options.waitQueueTimeoutMS) !== null && _d !== void 0 ? _d : 0,\n      autoEncrypter: options.autoEncrypter,\n      metadata: options.metadata\n    });\n\n    if (this.options.minPoolSize > this.options.maxPoolSize) {\n      throw new error_1.MongoInvalidArgumentError('Connection pool minimum size must not be greater than maximum pool size');\n    }\n\n    this[kLogger] = new logger_1.Logger('ConnectionPool');\n    this[kConnections] = new Denque();\n    this[kPermits] = this.options.maxPoolSize;\n    this[kMinPoolSizeTimer] = undefined;\n    this[kGeneration] = 0;\n    this[kServiceGenerations] = new Map();\n    this[kConnectionCounter] = utils_1.makeCounter(1);\n    this[kCancellationToken] = new mongo_types_1.CancellationToken();\n    this[kCancellationToken].setMaxListeners(Infinity);\n    this[kWaitQueue] = new Denque();\n    this[kMetrics] = new metrics_1.ConnectionPoolMetrics();\n    this[kCheckedOut] = 0;\n    this[kProcessingWaitQueue] = false;\n    process.nextTick(() => {\n      this.emit(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));\n      ensureMinPoolSize(this);\n    });\n  }\n  /** The address of the endpoint the pool is connected to */\n\n\n  get address() {\n    return this.options.hostAddress.toString();\n  }\n  /** An integer representing the SDAM generation of the pool */\n\n\n  get generation() {\n    return this[kGeneration];\n  }\n  /** An integer expressing how many total connections (active + in use) the pool currently has */\n\n\n  get totalConnectionCount() {\n    return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);\n  }\n  /** An integer expressing how many connections are currently available in the pool. */\n\n\n  get availableConnectionCount() {\n    return this[kConnections].length;\n  }\n\n  get waitQueueSize() {\n    return this[kWaitQueue].length;\n  }\n\n  get loadBalanced() {\n    return this.options.loadBalanced;\n  }\n\n  get serviceGenerations() {\n    return this[kServiceGenerations];\n  }\n\n  get currentCheckedOutCount() {\n    return this[kCheckedOut];\n  }\n  /**\n   * Get the metrics information for the pool when a wait queue timeout occurs.\n   */\n\n\n  waitQueueErrorMetrics() {\n    return this[kMetrics].info(this.options.maxPoolSize);\n  }\n  /**\n   * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it\n   * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or\n   * explicitly destroyed by the new owner.\n   */\n\n\n  checkOut(callback) {\n    this.emit(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));\n\n    if (this.closed) {\n      this.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'poolClosed'));\n      callback(new errors_1.PoolClosedError(this));\n      return;\n    }\n\n    const waitQueueMember = {\n      callback\n    };\n    const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;\n\n    if (waitQueueTimeoutMS) {\n      waitQueueMember.timer = setTimeout(() => {\n        waitQueueMember[kCancelled] = true;\n        waitQueueMember.timer = undefined;\n        this.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'timeout'));\n        waitQueueMember.callback(new errors_1.WaitQueueTimeoutError(this.loadBalanced ? this.waitQueueErrorMetrics() : 'Timed out while checking out a connection from connection pool', this.address));\n      }, waitQueueTimeoutMS);\n    }\n\n    this[kCheckedOut] = this[kCheckedOut] + 1;\n    this[kWaitQueue].push(waitQueueMember);\n    process.nextTick(processWaitQueue, this);\n  }\n  /**\n   * Check a connection into the pool.\n   *\n   * @param connection - The connection to check in\n   */\n\n\n  checkIn(connection) {\n    const poolClosed = this.closed;\n    const stale = connectionIsStale(this, connection);\n    const willDestroy = !!(poolClosed || stale || connection.closed);\n\n    if (!willDestroy) {\n      connection.markAvailable();\n      this[kConnections].unshift(connection);\n    }\n\n    this[kCheckedOut] = this[kCheckedOut] - 1;\n    this.emit(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));\n\n    if (willDestroy) {\n      const reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';\n      destroyConnection(this, connection, reason);\n    }\n\n    process.nextTick(processWaitQueue, this);\n  }\n  /**\n   * Clear the pool\n   *\n   * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a\n   * previous generation will eventually be pruned during subsequent checkouts.\n   */\n\n\n  clear(serviceId) {\n    if (this.loadBalanced && serviceId) {\n      const sid = serviceId.toHexString();\n      const generation = this.serviceGenerations.get(sid); // Only need to worry if the generation exists, since it should\n      // always be there but typescript needs the check.\n\n      if (generation == null) {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('Service generations are required in load balancer mode.');\n      } else {\n        // Increment the generation for the service id.\n        this.serviceGenerations.set(sid, generation + 1);\n      }\n    } else {\n      this[kGeneration] += 1;\n    }\n\n    this.emit('connectionPoolCleared', new connection_pool_events_1.ConnectionPoolClearedEvent(this, serviceId));\n  }\n\n  close(_options, _cb) {\n    let options = _options;\n    const callback = _cb !== null && _cb !== void 0 ? _cb : _options;\n\n    if (typeof options === 'function') {\n      options = {};\n    }\n\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this.closed) {\n      return callback();\n    } // immediately cancel any in-flight connections\n\n\n    this[kCancellationToken].emit('cancel'); // drain the wait queue\n\n    while (this.waitQueueSize) {\n      const waitQueueMember = this[kWaitQueue].pop();\n\n      if (waitQueueMember) {\n        if (waitQueueMember.timer) {\n          clearTimeout(waitQueueMember.timer);\n        }\n\n        if (!waitQueueMember[kCancelled]) {\n          // TODO(NODE-3483): Replace with MongoConnectionPoolClosedError\n          waitQueueMember.callback(new error_1.MongoRuntimeError('Connection pool closed'));\n        }\n      }\n    } // clear the min pool size timer\n\n\n    const minPoolSizeTimer = this[kMinPoolSizeTimer];\n\n    if (minPoolSizeTimer) {\n      clearTimeout(minPoolSizeTimer);\n    } // end the connection counter\n\n\n    if (typeof this[kConnectionCounter].return === 'function') {\n      this[kConnectionCounter].return(undefined);\n    } // mark the pool as closed immediately\n\n\n    this.closed = true;\n    utils_1.eachAsync(this[kConnections].toArray(), (conn, cb) => {\n      this.emit(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, 'poolClosed'));\n      conn.destroy(options, cb);\n    }, err => {\n      this[kConnections].clear();\n      this.emit(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));\n      callback(err);\n    });\n  }\n  /**\n   * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda\n   * has completed by calling back.\n   *\n   * NOTE: please note the required signature of `fn`\n   *\n   * @remarks When in load balancer mode, connections can be pinned to cursors or transactions.\n   *   In these cases we pass the connection in to this method to ensure it is used and a new\n   *   connection is not checked out.\n   *\n   * @param conn - A pinned connection for use in load balancing mode.\n   * @param fn - A function which operates on a managed connection\n   * @param callback - The original callback\n   */\n\n\n  withConnection(conn, fn, callback) {\n    if (conn) {\n      // use the provided connection, and do _not_ check it in after execution\n      fn(undefined, conn, (fnErr, result) => {\n        if (typeof callback === 'function') {\n          if (fnErr) {\n            callback(fnErr);\n          } else {\n            callback(undefined, result);\n          }\n        }\n      });\n      return;\n    }\n\n    this.checkOut((err, conn) => {\n      // don't callback with `err` here, we might want to act upon it inside `fn`\n      fn(err, conn, (fnErr, result) => {\n        if (typeof callback === 'function') {\n          if (fnErr) {\n            callback(fnErr);\n          } else {\n            callback(undefined, result);\n          }\n        }\n\n        if (conn) {\n          this.checkIn(conn);\n        }\n      });\n    });\n  }\n\n}\n\nexports.ConnectionPool = ConnectionPool;\n/**\n * Emitted when the connection pool is created.\n * @event\n */\n\nConnectionPool.CONNECTION_POOL_CREATED = 'connectionPoolCreated';\n/**\n * Emitted once when the connection pool is closed\n * @event\n */\n\nConnectionPool.CONNECTION_POOL_CLOSED = 'connectionPoolClosed';\n/**\n * Emitted each time the connection pool is cleared and it's generation incremented\n * @event\n */\n\nConnectionPool.CONNECTION_POOL_CLEARED = 'connectionPoolCleared';\n/**\n * Emitted when a connection is created.\n * @event\n */\n\nConnectionPool.CONNECTION_CREATED = 'connectionCreated';\n/**\n * Emitted when a connection becomes established, and is ready to use\n * @event\n */\n\nConnectionPool.CONNECTION_READY = 'connectionReady';\n/**\n * Emitted when a connection is closed\n * @event\n */\n\nConnectionPool.CONNECTION_CLOSED = 'connectionClosed';\n/**\n * Emitted when an attempt to check out a connection begins\n * @event\n */\n\nConnectionPool.CONNECTION_CHECK_OUT_STARTED = 'connectionCheckOutStarted';\n/**\n * Emitted when an attempt to check out a connection fails\n * @event\n */\n\nConnectionPool.CONNECTION_CHECK_OUT_FAILED = 'connectionCheckOutFailed';\n/**\n * Emitted each time a connection is successfully checked out of the connection pool\n * @event\n */\n\nConnectionPool.CONNECTION_CHECKED_OUT = 'connectionCheckedOut';\n/**\n * Emitted each time a connection is successfully checked into the connection pool\n * @event\n */\n\nConnectionPool.CONNECTION_CHECKED_IN = 'connectionCheckedIn';\n\nfunction ensureMinPoolSize(pool) {\n  if (pool.closed || pool.options.minPoolSize === 0) {\n    return;\n  }\n\n  const minPoolSize = pool.options.minPoolSize;\n\n  for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {\n    createConnection(pool);\n  }\n\n  pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);\n}\n\nfunction connectionIsStale(pool, connection) {\n  const serviceId = connection.serviceId;\n\n  if (pool.loadBalanced && serviceId) {\n    const sid = serviceId.toHexString();\n    const generation = pool.serviceGenerations.get(sid);\n    return connection.generation !== generation;\n  }\n\n  return connection.generation !== pool[kGeneration];\n}\n\nfunction connectionIsIdle(pool, connection) {\n  return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);\n}\n\nfunction createConnection(pool, callback) {\n  const connectOptions = { ...pool.options,\n    id: pool[kConnectionCounter].next().value,\n    generation: pool[kGeneration],\n    cancellationToken: pool[kCancellationToken]\n  };\n  pool[kPermits]--;\n  connect_1.connect(connectOptions, (err, connection) => {\n    if (err || !connection) {\n      pool[kPermits]++;\n      pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n\n      if (typeof callback === 'function') {\n        callback(err);\n      }\n\n      return;\n    } // The pool might have closed since we started trying to create a connection\n\n\n    if (pool.closed) {\n      connection.destroy({\n        force: true\n      });\n      return;\n    } // forward all events from the connection to the pool\n\n\n    for (const event of [...connection_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {\n      connection.on(event, e => pool.emit(event, e));\n    }\n\n    pool.emit(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(pool, connection));\n\n    if (pool.loadBalanced) {\n      connection.on(connection_1.Connection.PINNED, pinType => pool[kMetrics].markPinned(pinType));\n      connection.on(connection_1.Connection.UNPINNED, pinType => pool[kMetrics].markUnpinned(pinType));\n      const serviceId = connection.serviceId;\n\n      if (serviceId) {\n        let generation;\n        const sid = serviceId.toHexString();\n\n        if (generation = pool.serviceGenerations.get(sid)) {\n          connection.generation = generation;\n        } else {\n          pool.serviceGenerations.set(sid, 0);\n          connection.generation = 0;\n        }\n      }\n    }\n\n    connection.markAvailable();\n    pool.emit(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(pool, connection)); // if a callback has been provided, check out the connection immediately\n\n    if (typeof callback === 'function') {\n      callback(undefined, connection);\n      return;\n    } // otherwise add it to the pool for later acquisition, and try to process the wait queue\n\n\n    pool[kConnections].push(connection);\n    process.nextTick(processWaitQueue, pool);\n  });\n}\n\nfunction destroyConnection(pool, connection, reason) {\n  pool.emit(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(pool, connection, reason)); // allow more connections to be created\n\n  pool[kPermits]++; // destroy the connection\n\n  process.nextTick(() => connection.destroy());\n}\n\nfunction processWaitQueue(pool) {\n  if (pool.closed || pool[kProcessingWaitQueue]) {\n    return;\n  }\n\n  pool[kProcessingWaitQueue] = true;\n\n  while (pool.waitQueueSize) {\n    const waitQueueMember = pool[kWaitQueue].peekFront();\n\n    if (!waitQueueMember) {\n      pool[kWaitQueue].shift();\n      continue;\n    }\n\n    if (waitQueueMember[kCancelled]) {\n      pool[kWaitQueue].shift();\n      continue;\n    }\n\n    if (!pool.availableConnectionCount) {\n      break;\n    }\n\n    const connection = pool[kConnections].shift();\n\n    if (!connection) {\n      break;\n    }\n\n    const isStale = connectionIsStale(pool, connection);\n    const isIdle = connectionIsIdle(pool, connection);\n\n    if (!isStale && !isIdle && !connection.closed) {\n      pool.emit(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(pool, connection));\n\n      if (waitQueueMember.timer) {\n        clearTimeout(waitQueueMember.timer);\n      }\n\n      pool[kWaitQueue].shift();\n      waitQueueMember.callback(undefined, connection);\n    } else {\n      const reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';\n      destroyConnection(pool, connection, reason);\n    }\n  }\n\n  const maxPoolSize = pool.options.maxPoolSize;\n\n  if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {\n    createConnection(pool, (err, connection) => {\n      const waitQueueMember = pool[kWaitQueue].shift();\n\n      if (!waitQueueMember || waitQueueMember[kCancelled]) {\n        if (!err && connection) {\n          pool[kConnections].push(connection);\n        }\n\n        pool[kProcessingWaitQueue] = false;\n        return;\n      }\n\n      if (err) {\n        pool.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(pool, err));\n      } else if (connection) {\n        pool.emit(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(pool, connection));\n      }\n\n      if (waitQueueMember.timer) {\n        clearTimeout(waitQueueMember.timer);\n      }\n\n      waitQueueMember.callback(err, connection);\n      pool[kProcessingWaitQueue] = false;\n      process.nextTick(() => processWaitQueue(pool));\n    });\n  } else {\n    pool[kProcessingWaitQueue] = false;\n  }\n}\n\nexports.CMAP_EVENTS = [ConnectionPool.CONNECTION_POOL_CREATED, ConnectionPool.CONNECTION_POOL_CLOSED, ConnectionPool.CONNECTION_CREATED, ConnectionPool.CONNECTION_READY, ConnectionPool.CONNECTION_CLOSED, ConnectionPool.CONNECTION_CHECK_OUT_STARTED, ConnectionPool.CONNECTION_CHECK_OUT_FAILED, ConnectionPool.CONNECTION_CHECKED_OUT, ConnectionPool.CONNECTION_CHECKED_IN, ConnectionPool.CONNECTION_POOL_CLEARED];","map":{"version":3,"names":["Object","defineProperty","exports","value","CMAP_EVENTS","ConnectionPool","Denque","require","connection_1","logger_1","metrics_1","connect_1","utils_1","error_1","errors_1","connection_pool_events_1","mongo_types_1","kLogger","Symbol","kConnections","kPermits","kMinPoolSizeTimer","kGeneration","kServiceGenerations","kConnectionCounter","kCancellationToken","kWaitQueue","kCancelled","kMetrics","kCheckedOut","kProcessingWaitQueue","TypedEventEmitter","constructor","options","_a","_b","_c","_d","closed","freeze","connectionType","Connection","maxPoolSize","minPoolSize","maxIdleTimeMS","waitQueueTimeoutMS","autoEncrypter","metadata","MongoInvalidArgumentError","Logger","undefined","Map","makeCounter","CancellationToken","setMaxListeners","Infinity","ConnectionPoolMetrics","process","nextTick","emit","CONNECTION_POOL_CREATED","ConnectionPoolCreatedEvent","ensureMinPoolSize","address","hostAddress","toString","generation","totalConnectionCount","length","availableConnectionCount","waitQueueSize","loadBalanced","serviceGenerations","currentCheckedOutCount","waitQueueErrorMetrics","info","checkOut","callback","CONNECTION_CHECK_OUT_STARTED","ConnectionCheckOutStartedEvent","CONNECTION_CHECK_OUT_FAILED","ConnectionCheckOutFailedEvent","PoolClosedError","waitQueueMember","timer","setTimeout","WaitQueueTimeoutError","push","processWaitQueue","checkIn","connection","poolClosed","stale","connectionIsStale","willDestroy","markAvailable","unshift","CONNECTION_CHECKED_IN","ConnectionCheckedInEvent","reason","destroyConnection","clear","serviceId","sid","toHexString","get","MongoRuntimeError","set","ConnectionPoolClearedEvent","close","_options","_cb","assign","force","pop","clearTimeout","minPoolSizeTimer","return","eachAsync","toArray","conn","cb","CONNECTION_CLOSED","ConnectionClosedEvent","destroy","err","CONNECTION_POOL_CLOSED","ConnectionPoolClosedEvent","withConnection","fn","fnErr","result","CONNECTION_POOL_CLEARED","CONNECTION_CREATED","CONNECTION_READY","CONNECTION_CHECKED_OUT","pool","i","createConnection","connectionIsIdle","idleTime","connectOptions","id","next","cancellationToken","connect","debug","JSON","stringify","event","APM_EVENTS","CLUSTER_TIME_RECEIVED","on","e","ConnectionCreatedEvent","PINNED","pinType","markPinned","UNPINNED","markUnpinned","ConnectionReadyEvent","peekFront","shift","isStale","isIdle","ConnectionCheckedOutEvent"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/cmap/connection_pool.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CMAP_EVENTS = exports.ConnectionPool = void 0;\nconst Denque = require(\"denque\");\nconst connection_1 = require(\"./connection\");\nconst logger_1 = require(\"../logger\");\nconst metrics_1 = require(\"./metrics\");\nconst connect_1 = require(\"./connect\");\nconst utils_1 = require(\"../utils\");\nconst error_1 = require(\"../error\");\nconst errors_1 = require(\"./errors\");\nconst connection_pool_events_1 = require(\"./connection_pool_events\");\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\nconst kLogger = Symbol('logger');\n/** @internal */\nconst kConnections = Symbol('connections');\n/** @internal */\nconst kPermits = Symbol('permits');\n/** @internal */\nconst kMinPoolSizeTimer = Symbol('minPoolSizeTimer');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kServiceGenerations = Symbol('serviceGenerations');\n/** @internal */\nconst kConnectionCounter = Symbol('connectionCounter');\n/** @internal */\nconst kCancellationToken = Symbol('cancellationToken');\n/** @internal */\nconst kWaitQueue = Symbol('waitQueue');\n/** @internal */\nconst kCancelled = Symbol('cancelled');\n/** @internal */\nconst kMetrics = Symbol('metrics');\n/** @internal */\nconst kCheckedOut = Symbol('checkedOut');\n/** @internal */\nconst kProcessingWaitQueue = Symbol('processingWaitQueue');\n/**\n * A pool of connections which dynamically resizes, and emit events related to pool activity\n * @internal\n */\nclass ConnectionPool extends mongo_types_1.TypedEventEmitter {\n    /** @internal */\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        this.closed = false;\n        this.options = Object.freeze({\n            ...options,\n            connectionType: connection_1.Connection,\n            maxPoolSize: (_a = options.maxPoolSize) !== null && _a !== void 0 ? _a : 100,\n            minPoolSize: (_b = options.minPoolSize) !== null && _b !== void 0 ? _b : 0,\n            maxIdleTimeMS: (_c = options.maxIdleTimeMS) !== null && _c !== void 0 ? _c : 0,\n            waitQueueTimeoutMS: (_d = options.waitQueueTimeoutMS) !== null && _d !== void 0 ? _d : 0,\n            autoEncrypter: options.autoEncrypter,\n            metadata: options.metadata\n        });\n        if (this.options.minPoolSize > this.options.maxPoolSize) {\n            throw new error_1.MongoInvalidArgumentError('Connection pool minimum size must not be greater than maximum pool size');\n        }\n        this[kLogger] = new logger_1.Logger('ConnectionPool');\n        this[kConnections] = new Denque();\n        this[kPermits] = this.options.maxPoolSize;\n        this[kMinPoolSizeTimer] = undefined;\n        this[kGeneration] = 0;\n        this[kServiceGenerations] = new Map();\n        this[kConnectionCounter] = utils_1.makeCounter(1);\n        this[kCancellationToken] = new mongo_types_1.CancellationToken();\n        this[kCancellationToken].setMaxListeners(Infinity);\n        this[kWaitQueue] = new Denque();\n        this[kMetrics] = new metrics_1.ConnectionPoolMetrics();\n        this[kCheckedOut] = 0;\n        this[kProcessingWaitQueue] = false;\n        process.nextTick(() => {\n            this.emit(ConnectionPool.CONNECTION_POOL_CREATED, new connection_pool_events_1.ConnectionPoolCreatedEvent(this));\n            ensureMinPoolSize(this);\n        });\n    }\n    /** The address of the endpoint the pool is connected to */\n    get address() {\n        return this.options.hostAddress.toString();\n    }\n    /** An integer representing the SDAM generation of the pool */\n    get generation() {\n        return this[kGeneration];\n    }\n    /** An integer expressing how many total connections (active + in use) the pool currently has */\n    get totalConnectionCount() {\n        return this[kConnections].length + (this.options.maxPoolSize - this[kPermits]);\n    }\n    /** An integer expressing how many connections are currently available in the pool. */\n    get availableConnectionCount() {\n        return this[kConnections].length;\n    }\n    get waitQueueSize() {\n        return this[kWaitQueue].length;\n    }\n    get loadBalanced() {\n        return this.options.loadBalanced;\n    }\n    get serviceGenerations() {\n        return this[kServiceGenerations];\n    }\n    get currentCheckedOutCount() {\n        return this[kCheckedOut];\n    }\n    /**\n     * Get the metrics information for the pool when a wait queue timeout occurs.\n     */\n    waitQueueErrorMetrics() {\n        return this[kMetrics].info(this.options.maxPoolSize);\n    }\n    /**\n     * Check a connection out of this pool. The connection will continue to be tracked, but no reference to it\n     * will be held by the pool. This means that if a connection is checked out it MUST be checked back in or\n     * explicitly destroyed by the new owner.\n     */\n    checkOut(callback) {\n        this.emit(ConnectionPool.CONNECTION_CHECK_OUT_STARTED, new connection_pool_events_1.ConnectionCheckOutStartedEvent(this));\n        if (this.closed) {\n            this.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'poolClosed'));\n            callback(new errors_1.PoolClosedError(this));\n            return;\n        }\n        const waitQueueMember = { callback };\n        const waitQueueTimeoutMS = this.options.waitQueueTimeoutMS;\n        if (waitQueueTimeoutMS) {\n            waitQueueMember.timer = setTimeout(() => {\n                waitQueueMember[kCancelled] = true;\n                waitQueueMember.timer = undefined;\n                this.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(this, 'timeout'));\n                waitQueueMember.callback(new errors_1.WaitQueueTimeoutError(this.loadBalanced\n                    ? this.waitQueueErrorMetrics()\n                    : 'Timed out while checking out a connection from connection pool', this.address));\n            }, waitQueueTimeoutMS);\n        }\n        this[kCheckedOut] = this[kCheckedOut] + 1;\n        this[kWaitQueue].push(waitQueueMember);\n        process.nextTick(processWaitQueue, this);\n    }\n    /**\n     * Check a connection into the pool.\n     *\n     * @param connection - The connection to check in\n     */\n    checkIn(connection) {\n        const poolClosed = this.closed;\n        const stale = connectionIsStale(this, connection);\n        const willDestroy = !!(poolClosed || stale || connection.closed);\n        if (!willDestroy) {\n            connection.markAvailable();\n            this[kConnections].unshift(connection);\n        }\n        this[kCheckedOut] = this[kCheckedOut] - 1;\n        this.emit(ConnectionPool.CONNECTION_CHECKED_IN, new connection_pool_events_1.ConnectionCheckedInEvent(this, connection));\n        if (willDestroy) {\n            const reason = connection.closed ? 'error' : poolClosed ? 'poolClosed' : 'stale';\n            destroyConnection(this, connection, reason);\n        }\n        process.nextTick(processWaitQueue, this);\n    }\n    /**\n     * Clear the pool\n     *\n     * Pool reset is handled by incrementing the pool's generation count. Any existing connection of a\n     * previous generation will eventually be pruned during subsequent checkouts.\n     */\n    clear(serviceId) {\n        if (this.loadBalanced && serviceId) {\n            const sid = serviceId.toHexString();\n            const generation = this.serviceGenerations.get(sid);\n            // Only need to worry if the generation exists, since it should\n            // always be there but typescript needs the check.\n            if (generation == null) {\n                // TODO(NODE-3483)\n                throw new error_1.MongoRuntimeError('Service generations are required in load balancer mode.');\n            }\n            else {\n                // Increment the generation for the service id.\n                this.serviceGenerations.set(sid, generation + 1);\n            }\n        }\n        else {\n            this[kGeneration] += 1;\n        }\n        this.emit('connectionPoolCleared', new connection_pool_events_1.ConnectionPoolClearedEvent(this, serviceId));\n    }\n    close(_options, _cb) {\n        let options = _options;\n        const callback = (_cb !== null && _cb !== void 0 ? _cb : _options);\n        if (typeof options === 'function') {\n            options = {};\n        }\n        options = Object.assign({ force: false }, options);\n        if (this.closed) {\n            return callback();\n        }\n        // immediately cancel any in-flight connections\n        this[kCancellationToken].emit('cancel');\n        // drain the wait queue\n        while (this.waitQueueSize) {\n            const waitQueueMember = this[kWaitQueue].pop();\n            if (waitQueueMember) {\n                if (waitQueueMember.timer) {\n                    clearTimeout(waitQueueMember.timer);\n                }\n                if (!waitQueueMember[kCancelled]) {\n                    // TODO(NODE-3483): Replace with MongoConnectionPoolClosedError\n                    waitQueueMember.callback(new error_1.MongoRuntimeError('Connection pool closed'));\n                }\n            }\n        }\n        // clear the min pool size timer\n        const minPoolSizeTimer = this[kMinPoolSizeTimer];\n        if (minPoolSizeTimer) {\n            clearTimeout(minPoolSizeTimer);\n        }\n        // end the connection counter\n        if (typeof this[kConnectionCounter].return === 'function') {\n            this[kConnectionCounter].return(undefined);\n        }\n        // mark the pool as closed immediately\n        this.closed = true;\n        utils_1.eachAsync(this[kConnections].toArray(), (conn, cb) => {\n            this.emit(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(this, conn, 'poolClosed'));\n            conn.destroy(options, cb);\n        }, err => {\n            this[kConnections].clear();\n            this.emit(ConnectionPool.CONNECTION_POOL_CLOSED, new connection_pool_events_1.ConnectionPoolClosedEvent(this));\n            callback(err);\n        });\n    }\n    /**\n     * Runs a lambda with an implicitly checked out connection, checking that connection back in when the lambda\n     * has completed by calling back.\n     *\n     * NOTE: please note the required signature of `fn`\n     *\n     * @remarks When in load balancer mode, connections can be pinned to cursors or transactions.\n     *   In these cases we pass the connection in to this method to ensure it is used and a new\n     *   connection is not checked out.\n     *\n     * @param conn - A pinned connection for use in load balancing mode.\n     * @param fn - A function which operates on a managed connection\n     * @param callback - The original callback\n     */\n    withConnection(conn, fn, callback) {\n        if (conn) {\n            // use the provided connection, and do _not_ check it in after execution\n            fn(undefined, conn, (fnErr, result) => {\n                if (typeof callback === 'function') {\n                    if (fnErr) {\n                        callback(fnErr);\n                    }\n                    else {\n                        callback(undefined, result);\n                    }\n                }\n            });\n            return;\n        }\n        this.checkOut((err, conn) => {\n            // don't callback with `err` here, we might want to act upon it inside `fn`\n            fn(err, conn, (fnErr, result) => {\n                if (typeof callback === 'function') {\n                    if (fnErr) {\n                        callback(fnErr);\n                    }\n                    else {\n                        callback(undefined, result);\n                    }\n                }\n                if (conn) {\n                    this.checkIn(conn);\n                }\n            });\n        });\n    }\n}\nexports.ConnectionPool = ConnectionPool;\n/**\n * Emitted when the connection pool is created.\n * @event\n */\nConnectionPool.CONNECTION_POOL_CREATED = 'connectionPoolCreated';\n/**\n * Emitted once when the connection pool is closed\n * @event\n */\nConnectionPool.CONNECTION_POOL_CLOSED = 'connectionPoolClosed';\n/**\n * Emitted each time the connection pool is cleared and it's generation incremented\n * @event\n */\nConnectionPool.CONNECTION_POOL_CLEARED = 'connectionPoolCleared';\n/**\n * Emitted when a connection is created.\n * @event\n */\nConnectionPool.CONNECTION_CREATED = 'connectionCreated';\n/**\n * Emitted when a connection becomes established, and is ready to use\n * @event\n */\nConnectionPool.CONNECTION_READY = 'connectionReady';\n/**\n * Emitted when a connection is closed\n * @event\n */\nConnectionPool.CONNECTION_CLOSED = 'connectionClosed';\n/**\n * Emitted when an attempt to check out a connection begins\n * @event\n */\nConnectionPool.CONNECTION_CHECK_OUT_STARTED = 'connectionCheckOutStarted';\n/**\n * Emitted when an attempt to check out a connection fails\n * @event\n */\nConnectionPool.CONNECTION_CHECK_OUT_FAILED = 'connectionCheckOutFailed';\n/**\n * Emitted each time a connection is successfully checked out of the connection pool\n * @event\n */\nConnectionPool.CONNECTION_CHECKED_OUT = 'connectionCheckedOut';\n/**\n * Emitted each time a connection is successfully checked into the connection pool\n * @event\n */\nConnectionPool.CONNECTION_CHECKED_IN = 'connectionCheckedIn';\nfunction ensureMinPoolSize(pool) {\n    if (pool.closed || pool.options.minPoolSize === 0) {\n        return;\n    }\n    const minPoolSize = pool.options.minPoolSize;\n    for (let i = pool.totalConnectionCount; i < minPoolSize; ++i) {\n        createConnection(pool);\n    }\n    pool[kMinPoolSizeTimer] = setTimeout(() => ensureMinPoolSize(pool), 10);\n}\nfunction connectionIsStale(pool, connection) {\n    const serviceId = connection.serviceId;\n    if (pool.loadBalanced && serviceId) {\n        const sid = serviceId.toHexString();\n        const generation = pool.serviceGenerations.get(sid);\n        return connection.generation !== generation;\n    }\n    return connection.generation !== pool[kGeneration];\n}\nfunction connectionIsIdle(pool, connection) {\n    return !!(pool.options.maxIdleTimeMS && connection.idleTime > pool.options.maxIdleTimeMS);\n}\nfunction createConnection(pool, callback) {\n    const connectOptions = {\n        ...pool.options,\n        id: pool[kConnectionCounter].next().value,\n        generation: pool[kGeneration],\n        cancellationToken: pool[kCancellationToken]\n    };\n    pool[kPermits]--;\n    connect_1.connect(connectOptions, (err, connection) => {\n        if (err || !connection) {\n            pool[kPermits]++;\n            pool[kLogger].debug(`connection attempt failed with error [${JSON.stringify(err)}]`);\n            if (typeof callback === 'function') {\n                callback(err);\n            }\n            return;\n        }\n        // The pool might have closed since we started trying to create a connection\n        if (pool.closed) {\n            connection.destroy({ force: true });\n            return;\n        }\n        // forward all events from the connection to the pool\n        for (const event of [...connection_1.APM_EVENTS, connection_1.Connection.CLUSTER_TIME_RECEIVED]) {\n            connection.on(event, (e) => pool.emit(event, e));\n        }\n        pool.emit(ConnectionPool.CONNECTION_CREATED, new connection_pool_events_1.ConnectionCreatedEvent(pool, connection));\n        if (pool.loadBalanced) {\n            connection.on(connection_1.Connection.PINNED, pinType => pool[kMetrics].markPinned(pinType));\n            connection.on(connection_1.Connection.UNPINNED, pinType => pool[kMetrics].markUnpinned(pinType));\n            const serviceId = connection.serviceId;\n            if (serviceId) {\n                let generation;\n                const sid = serviceId.toHexString();\n                if ((generation = pool.serviceGenerations.get(sid))) {\n                    connection.generation = generation;\n                }\n                else {\n                    pool.serviceGenerations.set(sid, 0);\n                    connection.generation = 0;\n                }\n            }\n        }\n        connection.markAvailable();\n        pool.emit(ConnectionPool.CONNECTION_READY, new connection_pool_events_1.ConnectionReadyEvent(pool, connection));\n        // if a callback has been provided, check out the connection immediately\n        if (typeof callback === 'function') {\n            callback(undefined, connection);\n            return;\n        }\n        // otherwise add it to the pool for later acquisition, and try to process the wait queue\n        pool[kConnections].push(connection);\n        process.nextTick(processWaitQueue, pool);\n    });\n}\nfunction destroyConnection(pool, connection, reason) {\n    pool.emit(ConnectionPool.CONNECTION_CLOSED, new connection_pool_events_1.ConnectionClosedEvent(pool, connection, reason));\n    // allow more connections to be created\n    pool[kPermits]++;\n    // destroy the connection\n    process.nextTick(() => connection.destroy());\n}\nfunction processWaitQueue(pool) {\n    if (pool.closed || pool[kProcessingWaitQueue]) {\n        return;\n    }\n    pool[kProcessingWaitQueue] = true;\n    while (pool.waitQueueSize) {\n        const waitQueueMember = pool[kWaitQueue].peekFront();\n        if (!waitQueueMember) {\n            pool[kWaitQueue].shift();\n            continue;\n        }\n        if (waitQueueMember[kCancelled]) {\n            pool[kWaitQueue].shift();\n            continue;\n        }\n        if (!pool.availableConnectionCount) {\n            break;\n        }\n        const connection = pool[kConnections].shift();\n        if (!connection) {\n            break;\n        }\n        const isStale = connectionIsStale(pool, connection);\n        const isIdle = connectionIsIdle(pool, connection);\n        if (!isStale && !isIdle && !connection.closed) {\n            pool.emit(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(pool, connection));\n            if (waitQueueMember.timer) {\n                clearTimeout(waitQueueMember.timer);\n            }\n            pool[kWaitQueue].shift();\n            waitQueueMember.callback(undefined, connection);\n        }\n        else {\n            const reason = connection.closed ? 'error' : isStale ? 'stale' : 'idle';\n            destroyConnection(pool, connection, reason);\n        }\n    }\n    const maxPoolSize = pool.options.maxPoolSize;\n    if (pool.waitQueueSize && (maxPoolSize <= 0 || pool.totalConnectionCount < maxPoolSize)) {\n        createConnection(pool, (err, connection) => {\n            const waitQueueMember = pool[kWaitQueue].shift();\n            if (!waitQueueMember || waitQueueMember[kCancelled]) {\n                if (!err && connection) {\n                    pool[kConnections].push(connection);\n                }\n                pool[kProcessingWaitQueue] = false;\n                return;\n            }\n            if (err) {\n                pool.emit(ConnectionPool.CONNECTION_CHECK_OUT_FAILED, new connection_pool_events_1.ConnectionCheckOutFailedEvent(pool, err));\n            }\n            else if (connection) {\n                pool.emit(ConnectionPool.CONNECTION_CHECKED_OUT, new connection_pool_events_1.ConnectionCheckedOutEvent(pool, connection));\n            }\n            if (waitQueueMember.timer) {\n                clearTimeout(waitQueueMember.timer);\n            }\n            waitQueueMember.callback(err, connection);\n            pool[kProcessingWaitQueue] = false;\n            process.nextTick(() => processWaitQueue(pool));\n        });\n    }\n    else {\n        pool[kProcessingWaitQueue] = false;\n    }\n}\nexports.CMAP_EVENTS = [\n    ConnectionPool.CONNECTION_POOL_CREATED,\n    ConnectionPool.CONNECTION_POOL_CLOSED,\n    ConnectionPool.CONNECTION_CREATED,\n    ConnectionPool.CONNECTION_READY,\n    ConnectionPool.CONNECTION_CLOSED,\n    ConnectionPool.CONNECTION_CHECK_OUT_STARTED,\n    ConnectionPool.CONNECTION_CHECK_OUT_FAILED,\n    ConnectionPool.CONNECTION_CHECKED_OUT,\n    ConnectionPool.CONNECTION_CHECKED_IN,\n    ConnectionPool.CONNECTION_POOL_CLEARED\n];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}