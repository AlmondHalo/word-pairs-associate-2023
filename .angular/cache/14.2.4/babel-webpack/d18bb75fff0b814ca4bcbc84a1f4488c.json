{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\n\nconst db_1 = require(\"./db\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst error_1 = require(\"./error\");\n\nconst utils_1 = require(\"./utils\");\n\nconst connect_1 = require(\"./operations/connect\");\n\nconst promise_provider_1 = require(\"./promise_provider\");\n\nconst bson_1 = require(\"./bson\");\n\nconst connection_string_1 = require(\"./connection_string\");\n\nconst mongo_types_1 = require(\"./mongo_types\");\n/** @public */\n\n\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\n\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedent over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\n\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n  constructor(url, options) {\n    super();\n    this[kOptions] = connection_string_1.parseOptions(url, this, options); // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n    const client = this; // The internal state\n\n    this.s = {\n      url,\n      sessions: new Set(),\n      bsonOptions: bson_1.resolveBSONOptions(this[kOptions]),\n      namespace: utils_1.ns('admin'),\n\n      get options() {\n        return client[kOptions];\n      },\n\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n\n      get logger() {\n        return client[kOptions].logger;\n      }\n\n    };\n  }\n\n  get options() {\n    return Object.freeze({ ...this[kOptions]\n    });\n  }\n\n  get serverApi() {\n    return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi\n    });\n  }\n  /**\n   * Intended for APM use only\n   * @internal\n   */\n\n\n  get monitorCommands() {\n    return this[kOptions].monitorCommands;\n  }\n\n  set monitorCommands(value) {\n    this[kOptions].monitorCommands = value;\n  }\n\n  get autoEncrypter() {\n    return this[kOptions].autoEncrypter;\n  }\n\n  get readConcern() {\n    return this.s.readConcern;\n  }\n\n  get writeConcern() {\n    return this.s.writeConcern;\n  }\n\n  get readPreference() {\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n\n  get logger() {\n    return this.s.logger;\n  }\n\n  connect(callback) {\n    if (callback && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n    }\n\n    return utils_1.maybePromise(callback, cb => {\n      connect_1.connect(this, this[kOptions], err => {\n        if (err) return cb(err);\n        cb(undefined, this);\n      });\n    });\n  }\n\n  close(forceOrCallback, callback) {\n    if (typeof forceOrCallback === 'function') {\n      callback = forceOrCallback;\n    }\n\n    const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n    return utils_1.maybePromise(callback, callback => {\n      if (this.topology == null) {\n        return callback();\n      } // clear out references to old topology\n\n\n      const topology = this.topology;\n      this.topology = undefined;\n      topology.close({\n        force\n      }, error => {\n        if (error) return callback(error);\n        const {\n          encrypter\n        } = this[kOptions];\n\n        if (encrypter) {\n          return encrypter.close(this, force, error => {\n            callback(error);\n          });\n        }\n\n        callback();\n      });\n    });\n  }\n  /**\n   * Create a new Db instance sharing the current socket connections.\n   *\n   * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n   * @param options - Optional settings for Db construction\n   */\n\n\n  db(dbName, options) {\n    options = options !== null && options !== void 0 ? options : {}; // Default to db from connection string if not provided\n\n    if (!dbName) {\n      dbName = this.options.dbName;\n    } // Copy the options and add out internal override of the not shared flag\n\n\n    const finalOptions = Object.assign({}, this[kOptions], options); // Return the db object\n\n    const db = new db_1.Db(this, dbName, finalOptions); // Return the database\n\n    return db;\n  }\n\n  static connect(url, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n\n    try {\n      // Create client\n      const mongoClient = new MongoClient(url, options); // Execute the connect method\n\n      if (callback) {\n        return mongoClient.connect(callback);\n      } else {\n        return mongoClient.connect();\n      }\n    } catch (error) {\n      if (callback) return callback(error);else return promise_provider_1.PromiseProvider.get().reject(error);\n    }\n  }\n\n  startSession(options) {\n    options = Object.assign({\n      explicit: true\n    }, options);\n\n    if (!this.topology) {\n      throw new error_1.MongoNotConnectedError('MongoClient must be connected to start a session');\n    }\n\n    return this.topology.startSession(options, this.s.options);\n  }\n\n  withSession(optionsOrOperation, callback) {\n    let options = optionsOrOperation;\n\n    if (typeof optionsOrOperation === 'function') {\n      callback = optionsOrOperation;\n      options = {\n        owner: Symbol()\n      };\n    }\n\n    if (callback == null) {\n      throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n    }\n\n    const session = this.startSession(options);\n    const Promise = promise_provider_1.PromiseProvider.get();\n\n    let cleanupHandler = (err, result, opts) => {\n      // prevent multiple calls to cleanupHandler\n      cleanupHandler = () => {\n        // TODO(NODE-3483)\n        throw new error_1.MongoRuntimeError('cleanupHandler was called too many times');\n      };\n\n      opts = Object.assign({\n        throw: true\n      }, opts);\n      session.endSession();\n\n      if (err) {\n        if (opts.throw) throw err;\n        return Promise.reject(err);\n      }\n    };\n\n    try {\n      const result = callback(session);\n      return Promise.resolve(result).then(result => cleanupHandler(undefined, result, undefined), err => cleanupHandler(err, null, {\n        throw: true\n      }));\n    } catch (err) {\n      return cleanupHandler(err, null, {\n        throw: false\n      });\n    }\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates,\n   * replacements, deletions, and invalidations) in this cluster. Will ignore all\n   * changes to system collections, as well as the local, admin, and config databases.\n   *\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n\n\n  watch(pipeline = [], options = {}) {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n  }\n  /** Return the mongo client logger */\n\n\n  getLogger() {\n    return this.s.logger;\n  }\n\n}\n\nexports.MongoClient = MongoClient;","map":{"version":3,"names":["Object","defineProperty","exports","value","MongoClient","ServerApiVersion","db_1","require","change_stream_1","error_1","utils_1","connect_1","promise_provider_1","bson_1","connection_string_1","mongo_types_1","freeze","v1","kOptions","Symbol","TypedEventEmitter","constructor","url","options","parseOptions","client","s","sessions","Set","bsonOptions","resolveBSONOptions","namespace","ns","readConcern","writeConcern","readPreference","logger","serverApi","monitorCommands","autoEncrypter","connect","callback","MongoInvalidArgumentError","maybePromise","cb","err","undefined","close","forceOrCallback","force","topology","error","encrypter","db","dbName","finalOptions","assign","Db","mongoClient","PromiseProvider","get","reject","startSession","explicit","MongoNotConnectedError","withSession","optionsOrOperation","owner","session","Promise","cleanupHandler","result","opts","MongoRuntimeError","throw","endSession","resolve","then","watch","pipeline","Array","isArray","ChangeStream","resolveOptions","getLogger"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/mongo_client.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MongoClient = exports.ServerApiVersion = void 0;\nconst db_1 = require(\"./db\");\nconst change_stream_1 = require(\"./change_stream\");\nconst error_1 = require(\"./error\");\nconst utils_1 = require(\"./utils\");\nconst connect_1 = require(\"./operations/connect\");\nconst promise_provider_1 = require(\"./promise_provider\");\nconst bson_1 = require(\"./bson\");\nconst connection_string_1 = require(\"./connection_string\");\nconst mongo_types_1 = require(\"./mongo_types\");\n/** @public */\nexports.ServerApiVersion = Object.freeze({\n    v1: '1'\n});\n/** @internal */\nconst kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedent over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\nclass MongoClient extends mongo_types_1.TypedEventEmitter {\n    constructor(url, options) {\n        super();\n        this[kOptions] = connection_string_1.parseOptions(url, this, options);\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const client = this;\n        // The internal state\n        this.s = {\n            url,\n            sessions: new Set(),\n            bsonOptions: bson_1.resolveBSONOptions(this[kOptions]),\n            namespace: utils_1.ns('admin'),\n            get options() {\n                return client[kOptions];\n            },\n            get readConcern() {\n                return client[kOptions].readConcern;\n            },\n            get writeConcern() {\n                return client[kOptions].writeConcern;\n            },\n            get readPreference() {\n                return client[kOptions].readPreference;\n            },\n            get logger() {\n                return client[kOptions].logger;\n            }\n        };\n    }\n    get options() {\n        return Object.freeze({ ...this[kOptions] });\n    }\n    get serverApi() {\n        return this[kOptions].serverApi && Object.freeze({ ...this[kOptions].serverApi });\n    }\n    /**\n     * Intended for APM use only\n     * @internal\n     */\n    get monitorCommands() {\n        return this[kOptions].monitorCommands;\n    }\n    set monitorCommands(value) {\n        this[kOptions].monitorCommands = value;\n    }\n    get autoEncrypter() {\n        return this[kOptions].autoEncrypter;\n    }\n    get readConcern() {\n        return this.s.readConcern;\n    }\n    get writeConcern() {\n        return this.s.writeConcern;\n    }\n    get readPreference() {\n        return this.s.readPreference;\n    }\n    get bsonOptions() {\n        return this.s.bsonOptions;\n    }\n    get logger() {\n        return this.s.logger;\n    }\n    connect(callback) {\n        if (callback && typeof callback !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n        }\n        return utils_1.maybePromise(callback, cb => {\n            connect_1.connect(this, this[kOptions], err => {\n                if (err)\n                    return cb(err);\n                cb(undefined, this);\n            });\n        });\n    }\n    close(forceOrCallback, callback) {\n        if (typeof forceOrCallback === 'function') {\n            callback = forceOrCallback;\n        }\n        const force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n        return utils_1.maybePromise(callback, callback => {\n            if (this.topology == null) {\n                return callback();\n            }\n            // clear out references to old topology\n            const topology = this.topology;\n            this.topology = undefined;\n            topology.close({ force }, error => {\n                if (error)\n                    return callback(error);\n                const { encrypter } = this[kOptions];\n                if (encrypter) {\n                    return encrypter.close(this, force, error => {\n                        callback(error);\n                    });\n                }\n                callback();\n            });\n        });\n    }\n    /**\n     * Create a new Db instance sharing the current socket connections.\n     *\n     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n     * @param options - Optional settings for Db construction\n     */\n    db(dbName, options) {\n        options = options !== null && options !== void 0 ? options : {};\n        // Default to db from connection string if not provided\n        if (!dbName) {\n            dbName = this.options.dbName;\n        }\n        // Copy the options and add out internal override of the not shared flag\n        const finalOptions = Object.assign({}, this[kOptions], options);\n        // Return the db object\n        const db = new db_1.Db(this, dbName, finalOptions);\n        // Return the database\n        return db;\n    }\n    static connect(url, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        try {\n            // Create client\n            const mongoClient = new MongoClient(url, options);\n            // Execute the connect method\n            if (callback) {\n                return mongoClient.connect(callback);\n            }\n            else {\n                return mongoClient.connect();\n            }\n        }\n        catch (error) {\n            if (callback)\n                return callback(error);\n            else\n                return promise_provider_1.PromiseProvider.get().reject(error);\n        }\n    }\n    startSession(options) {\n        options = Object.assign({ explicit: true }, options);\n        if (!this.topology) {\n            throw new error_1.MongoNotConnectedError('MongoClient must be connected to start a session');\n        }\n        return this.topology.startSession(options, this.s.options);\n    }\n    withSession(optionsOrOperation, callback) {\n        let options = optionsOrOperation;\n        if (typeof optionsOrOperation === 'function') {\n            callback = optionsOrOperation;\n            options = { owner: Symbol() };\n        }\n        if (callback == null) {\n            throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n        }\n        const session = this.startSession(options);\n        const Promise = promise_provider_1.PromiseProvider.get();\n        let cleanupHandler = ((err, result, opts) => {\n            // prevent multiple calls to cleanupHandler\n            cleanupHandler = () => {\n                // TODO(NODE-3483)\n                throw new error_1.MongoRuntimeError('cleanupHandler was called too many times');\n            };\n            opts = Object.assign({ throw: true }, opts);\n            session.endSession();\n            if (err) {\n                if (opts.throw)\n                    throw err;\n                return Promise.reject(err);\n            }\n        });\n        try {\n            const result = callback(session);\n            return Promise.resolve(result).then(result => cleanupHandler(undefined, result, undefined), err => cleanupHandler(err, null, { throw: true }));\n        }\n        catch (err) {\n            return cleanupHandler(err, null, { throw: false });\n        }\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates,\n     * replacements, deletions, and invalidations) in this cluster. Will ignore all\n     * changes to system collections, as well as the local, admin, and config databases.\n     *\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     */\n    watch(pipeline = [], options = {}) {\n        // Allow optionally not specifying a pipeline\n        if (!Array.isArray(pipeline)) {\n            options = pipeline;\n            pipeline = [];\n        }\n        return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n    }\n    /** Return the mongo client logger */\n    getLogger() {\n        return this.s.logger;\n    }\n}\nexports.MongoClient = MongoClient;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}