{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;\n\nconst command_1 = require(\"./command\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst error_1 = require(\"../error\");\n\nconst utils_1 = require(\"../utils\");\n\nconst operation_1 = require(\"./operation\");\n/** @internal */\n\n\nexports.DB_AGGREGATE_COLLECTION = 1;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;\n/** @internal */\n\nclass AggregateOperation extends command_1.CommandOperation {\n  constructor(ns, pipeline, options) {\n    super(undefined, { ...options,\n      dbName: ns.db\n    });\n    this.options = options !== null && options !== void 0 ? options : {}; // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n\n    this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;\n    this.pipeline = pipeline; // determine if we have a write stage, override read preference if so\n\n    this.hasWriteStage = false;\n\n    if (typeof (options === null || options === void 0 ? void 0 : options.out) === 'string') {\n      this.pipeline = this.pipeline.concat({\n        $out: options.out\n      });\n      this.hasWriteStage = true;\n    } else if (pipeline.length > 0) {\n      const finalStage = pipeline[pipeline.length - 1];\n\n      if (finalStage.$out || finalStage.$merge) {\n        this.hasWriteStage = true;\n      }\n    }\n\n    if (this.hasWriteStage) {\n      this.readPreference = read_preference_1.ReadPreference.primary;\n    }\n\n    if (this.explain && this.writeConcern) {\n      throw new error_1.MongoInvalidArgumentError('Option \"explain\" cannot be used on an aggregate call with writeConcern');\n    }\n\n    if ((options === null || options === void 0 ? void 0 : options.cursor) != null && typeof options.cursor !== 'object') {\n      throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');\n    }\n  }\n\n  get canRetryRead() {\n    return !this.hasWriteStage;\n  }\n\n  addToPipeline(stage) {\n    this.pipeline.push(stage);\n  }\n\n  execute(server, session, callback) {\n    const options = this.options;\n    const serverWireVersion = utils_1.maxWireVersion(server);\n    const command = {\n      aggregate: this.target,\n      pipeline: this.pipeline\n    };\n\n    if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n      this.readConcern = undefined;\n    }\n\n    if (serverWireVersion >= 5) {\n      if (this.hasWriteStage && this.writeConcern) {\n        Object.assign(command, {\n          writeConcern: this.writeConcern\n        });\n      }\n    }\n\n    if (options.bypassDocumentValidation === true) {\n      command.bypassDocumentValidation = options.bypassDocumentValidation;\n    }\n\n    if (typeof options.allowDiskUse === 'boolean') {\n      command.allowDiskUse = options.allowDiskUse;\n    }\n\n    if (options.hint) {\n      command.hint = options.hint;\n    }\n\n    if (options.let) {\n      command.let = options.let;\n    }\n\n    command.cursor = options.cursor || {};\n\n    if (options.batchSize && !this.hasWriteStage) {\n      command.cursor.batchSize = options.batchSize;\n    }\n\n    super.executeCommand(server, session, command, callback);\n  }\n\n}\n\nexports.AggregateOperation = AggregateOperation;\noperation_1.defineAspects(AggregateOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.CURSOR_CREATING]);","map":{"version":3,"names":["Object","defineProperty","exports","value","AggregateOperation","DB_AGGREGATE_COLLECTION","command_1","require","read_preference_1","error_1","utils_1","operation_1","MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT","CommandOperation","constructor","ns","pipeline","options","undefined","dbName","db","target","collection","hasWriteStage","out","concat","$out","length","finalStage","$merge","readPreference","ReadPreference","primary","explain","writeConcern","MongoInvalidArgumentError","cursor","canRetryRead","addToPipeline","stage","push","execute","server","session","callback","serverWireVersion","maxWireVersion","command","aggregate","readConcern","assign","bypassDocumentValidation","allowDiskUse","hint","let","batchSize","executeCommand","defineAspects","Aspect","READ_OPERATION","RETRYABLE","EXPLAINABLE","CURSOR_CREATING"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/operations/aggregate.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AggregateOperation = exports.DB_AGGREGATE_COLLECTION = void 0;\nconst command_1 = require(\"./command\");\nconst read_preference_1 = require(\"../read_preference\");\nconst error_1 = require(\"../error\");\nconst utils_1 = require(\"../utils\");\nconst operation_1 = require(\"./operation\");\n/** @internal */\nexports.DB_AGGREGATE_COLLECTION = 1;\nconst MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT = 8;\n/** @internal */\nclass AggregateOperation extends command_1.CommandOperation {\n    constructor(ns, pipeline, options) {\n        super(undefined, { ...options, dbName: ns.db });\n        this.options = options !== null && options !== void 0 ? options : {};\n        // Covers when ns.collection is null, undefined or the empty string, use DB_AGGREGATE_COLLECTION\n        this.target = ns.collection || exports.DB_AGGREGATE_COLLECTION;\n        this.pipeline = pipeline;\n        // determine if we have a write stage, override read preference if so\n        this.hasWriteStage = false;\n        if (typeof (options === null || options === void 0 ? void 0 : options.out) === 'string') {\n            this.pipeline = this.pipeline.concat({ $out: options.out });\n            this.hasWriteStage = true;\n        }\n        else if (pipeline.length > 0) {\n            const finalStage = pipeline[pipeline.length - 1];\n            if (finalStage.$out || finalStage.$merge) {\n                this.hasWriteStage = true;\n            }\n        }\n        if (this.hasWriteStage) {\n            this.readPreference = read_preference_1.ReadPreference.primary;\n        }\n        if (this.explain && this.writeConcern) {\n            throw new error_1.MongoInvalidArgumentError('Option \"explain\" cannot be used on an aggregate call with writeConcern');\n        }\n        if ((options === null || options === void 0 ? void 0 : options.cursor) != null && typeof options.cursor !== 'object') {\n            throw new error_1.MongoInvalidArgumentError('Cursor options must be an object');\n        }\n    }\n    get canRetryRead() {\n        return !this.hasWriteStage;\n    }\n    addToPipeline(stage) {\n        this.pipeline.push(stage);\n    }\n    execute(server, session, callback) {\n        const options = this.options;\n        const serverWireVersion = utils_1.maxWireVersion(server);\n        const command = { aggregate: this.target, pipeline: this.pipeline };\n        if (this.hasWriteStage && serverWireVersion < MIN_WIRE_VERSION_$OUT_READ_CONCERN_SUPPORT) {\n            this.readConcern = undefined;\n        }\n        if (serverWireVersion >= 5) {\n            if (this.hasWriteStage && this.writeConcern) {\n                Object.assign(command, { writeConcern: this.writeConcern });\n            }\n        }\n        if (options.bypassDocumentValidation === true) {\n            command.bypassDocumentValidation = options.bypassDocumentValidation;\n        }\n        if (typeof options.allowDiskUse === 'boolean') {\n            command.allowDiskUse = options.allowDiskUse;\n        }\n        if (options.hint) {\n            command.hint = options.hint;\n        }\n        if (options.let) {\n            command.let = options.let;\n        }\n        command.cursor = options.cursor || {};\n        if (options.batchSize && !this.hasWriteStage) {\n            command.cursor.batchSize = options.batchSize;\n        }\n        super.executeCommand(server, session, command, callback);\n    }\n}\nexports.AggregateOperation = AggregateOperation;\noperation_1.defineAspects(AggregateOperation, [\n    operation_1.Aspect.READ_OPERATION,\n    operation_1.Aspect.RETRYABLE,\n    operation_1.Aspect.EXPLAINABLE,\n    operation_1.Aspect.CURSOR_CREATING\n]);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}