{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.APM_EVENTS = exports.Connection = void 0;\n\nconst message_stream_1 = require(\"./message_stream\");\n\nconst stream_description_1 = require(\"./stream_description\");\n\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\n\nconst sessions_1 = require(\"../sessions\");\n\nconst utils_1 = require(\"../utils\");\n\nconst error_1 = require(\"../error\");\n\nconst commands_1 = require(\"./commands\");\n\nconst bson_1 = require(\"../bson\");\n\nconst shared_1 = require(\"./wire_protocol/shared\");\n\nconst read_preference_1 = require(\"../read_preference\");\n\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\n\n\nconst kStream = Symbol('stream');\n/** @internal */\n\nconst kQueue = Symbol('queue');\n/** @internal */\n\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\n\nconst kGeneration = Symbol('generation');\n/** @internal */\n\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\n\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\n\nconst kDescription = Symbol('description');\n/** @internal */\n\nconst kIsMaster = Symbol('ismaster');\n/** @internal */\n\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\n\nconst kFullResult = Symbol('fullResult');\n/** @internal */\n\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    var _a, _b;\n\n    super();\n    this.id = options.id;\n    this.address = streamIdentifier(stream);\n    this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this.destroyed = false;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = utils_1.now(); // setup parser stream and message handling\n\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({ ...options,\n      maxBsonMessageSize: (_b = this.ismaster) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    });\n    this[kMessageStream].on('message', messageHandler(this));\n    this[kStream] = stream;\n    stream.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    this[kMessageStream].on('error', error => this.handleIssue({\n      destroy: error\n    }));\n    stream.on('close', () => this.handleIssue({\n      isClose: true\n    }));\n    stream.on('timeout', () => this.handleIssue({\n      isTimeout: true,\n      destroy: true\n    })); // hook the message stream up to the passed in stream\n\n    stream.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(stream);\n  }\n\n  get description() {\n    return this[kDescription];\n  }\n\n  get ismaster() {\n    return this[kIsMaster];\n  } // the `connect` method stores the result of the handshake ismaster on the connection\n\n\n  set ismaster(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]); // TODO: remove this, and only use the `StreamDescription` in the future\n\n    this[kIsMaster] = response;\n  }\n\n  get serviceId() {\n    var _a;\n\n    return (_a = this.ismaster) === null || _a === void 0 ? void 0 : _a.serviceId;\n  }\n\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime() {\n    return utils_1.calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n\n  get stream() {\n    return this[kStream];\n  }\n\n  markAvailable() {\n    this[kLastUseTime] = utils_1.now();\n  }\n\n  handleIssue(issue) {\n    if (this.closed) {\n      return;\n    }\n\n    if (issue.destroy) {\n      this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n    }\n\n    this.closed = true;\n\n    for (const [, op] of this[kQueue]) {\n      if (issue.isTimeout) {\n        op.cb(new error_1.MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n          beforeHandshake: this.ismaster == null\n        }));\n      } else if (issue.isClose) {\n        op.cb(new error_1.MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n      } else {\n        op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n      }\n    }\n\n    this[kQueue].clear();\n    this.emit(Connection.CLOSE);\n  }\n\n  destroy(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {\n        force: false\n      };\n    }\n\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    options = Object.assign({\n      force: false\n    }, options);\n\n    if (this[kStream] == null || this.destroyed) {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    if (options.force) {\n      this[kStream].destroy();\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n\n      return;\n    }\n\n    this[kStream].end(() => {\n      this.destroyed = true;\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n  /** @internal */\n\n\n  command(ns, cmd, options, callback) {\n    if (!(ns instanceof utils_1.MongoDBNamespace)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n    }\n\n    const readPreference = shared_1.getReadPreference(cmd, options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options === null || options === void 0 ? void 0 : options.session;\n    let clusterTime = this.clusterTime;\n    let finalCmd = Object.assign({}, cmd);\n\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      finalCmd.apiVersion = version;\n      if (strict != null) finalCmd.apiStrict = strict;\n      if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = sessions_1.applySession(session, finalCmd, options);\n\n      if (err) {\n        return callback(err);\n      }\n    } // if we have a known cluster time, gossip it\n\n\n    if (clusterTime) {\n      finalCmd.$clusterTime = clusterTime;\n    }\n\n    if (shared_1.isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      finalCmd = {\n        $query: finalCmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions = Object.assign({\n      command: true,\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      slaveOk: readPreference.slaveOk()\n    }, options);\n    const cmdNs = `${ns.db}.$cmd`;\n    const message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n  /** @internal */\n\n\n  query(ns, cmd, options, callback) {\n    var _a;\n\n    const isExplain = cmd.$explain != null;\n    const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n    const batchSize = options.batchSize || 0;\n    const limit = options.limit;\n    const numberToSkip = options.skip || 0;\n    let numberToReturn = 0;\n\n    if (limit && (limit < 0 || limit !== 0 && limit < batchSize || limit > 0 && batchSize === 0)) {\n      numberToReturn = limit;\n    } else {\n      numberToReturn = batchSize;\n    }\n\n    if (isExplain) {\n      // nToReturn must be 0 (match all) or negative (match N and close cursor)\n      // nToReturn > 0 will give explain results equivalent to limit(0)\n      numberToReturn = -Math.abs(limit || 0);\n    }\n\n    const queryOptions = {\n      numberToSkip,\n      numberToReturn,\n      pre32Limit: typeof limit === 'number' ? limit : undefined,\n      checkKeys: false,\n      slaveOk: readPreference.slaveOk()\n    };\n\n    if (options.projection) {\n      queryOptions.returnFieldSelector = options.projection;\n    }\n\n    const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n\n    if (typeof options.tailable === 'boolean') {\n      query.tailable = options.tailable;\n    }\n\n    if (typeof options.oplogReplay === 'boolean') {\n      query.oplogReplay = options.oplogReplay;\n    }\n\n    if (typeof options.timeout === 'boolean') {\n      query.noCursorTimeout = !options.timeout;\n    } else if (typeof options.noCursorTimeout === 'boolean') {\n      query.noCursorTimeout = options.noCursorTimeout;\n    }\n\n    if (typeof options.awaitData === 'boolean') {\n      query.awaitData = options.awaitData;\n    }\n\n    if (typeof options.partial === 'boolean') {\n      query.partial = options.partial;\n    }\n\n    write(this, query, {\n      [kFullResult]: true,\n      ...bson_1.pluckBSONSerializeOptions(options)\n    }, (err, result) => {\n      if (err || !result) return callback(err, result);\n\n      if (isExplain && result.documents && result.documents[0]) {\n        return callback(undefined, result.documents[0]);\n      }\n\n      callback(undefined, result);\n    });\n  }\n  /** @internal */\n\n\n  getMore(ns, cursorId, options, callback) {\n    const fullResult = !!options[kFullResult];\n    const wireVersion = utils_1.maxWireVersion(this);\n\n    if (!cursorId) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n      return;\n    }\n\n    if (wireVersion < 4) {\n      const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, {\n        numberToReturn: options.batchSize\n      });\n      const queryOptions = shared_1.applyCommonQueryOptions({}, Object.assign(options, { ...bson_1.pluckBSONSerializeOptions(options)\n      }));\n      queryOptions[kFullResult] = true;\n      queryOptions.command = true;\n      write(this, getMoreOp, queryOptions, (err, response) => {\n        if (fullResult) return callback(err, response);\n        if (err) return callback(err);\n        callback(undefined, {\n          cursor: {\n            id: response.cursorId,\n            nextBatch: response.documents\n          }\n        });\n      });\n      return;\n    }\n\n    const getMoreCmd = {\n      getMore: cursorId,\n      collection: ns.collection\n    };\n\n    if (typeof options.batchSize === 'number') {\n      getMoreCmd.batchSize = Math.abs(options.batchSize);\n    }\n\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n    }\n\n    const commandOptions = Object.assign({\n      returnFieldSelector: null,\n      documentsReturnedIn: 'nextBatch'\n    }, options);\n    this.command(ns, getMoreCmd, commandOptions, callback);\n  }\n  /** @internal */\n\n\n  killCursors(ns, cursorIds, options, callback) {\n    if (!cursorIds || !Array.isArray(cursorIds)) {\n      // TODO(NODE-3483): Replace this with a MongoCommandError\n      throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n    }\n\n    if (utils_1.maxWireVersion(this) < 4) {\n      try {\n        write(this, new commands_1.KillCursor(ns.toString(), cursorIds), {\n          noResponse: true,\n          ...options\n        }, callback);\n      } catch (err) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    this.command(ns, {\n      killCursors: ns.collection,\n      cursors: cursorIds\n    }, {\n      [kFullResult]: true,\n      ...options\n    }, (err, response) => {\n      if (err || !response) return callback(err);\n\n      if (response.cursorNotFound) {\n        return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n      }\n\n      if (!Array.isArray(response.documents) || response.documents.length === 0) {\n        return callback( // TODO(NODE-3483)\n        new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n      }\n\n      callback(undefined, response.documents[0]);\n    });\n  }\n\n}\n\nexports.Connection = Connection;\n/** @event */\n\nConnection.COMMAND_STARTED = 'commandStarted';\n/** @event */\n\nConnection.COMMAND_SUCCEEDED = 'commandSucceeded';\n/** @event */\n\nConnection.COMMAND_FAILED = 'commandFailed';\n/** @event */\n\nConnection.CLUSTER_TIME_RECEIVED = 'clusterTimeReceived';\n/** @event */\n\nConnection.CLOSE = 'close';\n/** @event */\n\nConnection.MESSAGE = 'message';\n/** @event */\n\nConnection.PINNED = 'pinned';\n/** @event */\n\nConnection.UNPINNED = 'unpinned';\n/** @public */\n\nexports.APM_EVENTS = [Connection.COMMAND_STARTED, Connection.COMMAND_SUCCEEDED, Connection.COMMAND_FAILED];\n/** @internal */\n\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n\n\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = utils_1.maxWireVersion(this);\n\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n      if (err || encrypted == null) {\n        callback(err, null);\n        return;\n      }\n\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n\n        autoEncrypter.decrypt(response, options, callback);\n      });\n    });\n  }\n\n}\n\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\n\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\n\nexports.hasSessionSupport = hasSessionSupport;\n\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n\n  if (description == null) {\n    return false;\n  }\n\n  return utils_1.maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction messageHandler(conn) {\n  return function messageHandler(message) {\n    // always emit the message, in case we are streaming\n    conn.emit('message', message);\n    const operationDescription = conn[kQueue].get(message.responseTo);\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb; // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n\n    conn[kQueue].delete(message.responseTo);\n\n    if ('moreToCome' in message && message.moreToCome) {\n      // requeue the callback for next synthetic request\n      conn[kQueue].set(message.requestId, operationDescription);\n    } else if (operationDescription.socketTimeoutOverride) {\n      conn[kStream].setTimeout(conn.socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n\n      if (session) {\n        sessions_1.updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        conn[kClusterTime] = document.$clusterTime;\n        conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (operationDescription.command) {\n        if (document.writeConcernError) {\n          callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n          return;\n        }\n\n        if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      } else {\n        // Pre 3.2 support\n        if (document.ok === 0 || document.$err || document.errmsg) {\n          callback(new error_1.MongoServerError(document));\n          return;\n        }\n      }\n    }\n\n    callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n  };\n}\n\nfunction streamIdentifier(stream) {\n  if (typeof stream.address === 'function') {\n    return `${stream.remoteAddress}:${stream.remotePort}`;\n  }\n\n  return utils_1.uuidV4().toString('hex');\n}\n\nfunction write(conn, command, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n  }\n\n  options = options !== null && options !== void 0 ? options : {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    fullResult: !!options[kFullResult],\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } // if command monitoring is enabled we need to modify the callback here\n\n\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = utils_1.now();\n\n    operationDescription.cb = (err, reply) => {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","hasSessionSupport","CryptoConnection","APM_EVENTS","Connection","message_stream_1","require","stream_description_1","command_monitoring_events_1","sessions_1","utils_1","error_1","commands_1","bson_1","shared_1","read_preference_1","mongo_types_1","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kIsMaster","kAutoEncrypter","kFullResult","TypedEventEmitter","constructor","stream","options","_a","_b","id","address","streamIdentifier","socketTimeoutMS","monitorCommands","serverApi","closed","destroyed","StreamDescription","generation","now","Map","MessageStream","maxBsonMessageSize","ismaster","on","messageHandler","error","handleIssue","destroy","isClose","isTimeout","pipe","description","response","receiveResponse","freeze","serviceId","loadBalanced","idleTime","calculateDurationInMs","clusterTime","markAvailable","issue","undefined","op","cb","MongoNetworkTimeoutError","beforeHandshake","MongoNetworkError","clear","emit","CLOSE","callback","force","removeAllListeners","PINNED","UNPINNED","assign","end","command","ns","cmd","MongoDBNamespace","MongoRuntimeError","readPreference","getReadPreference","shouldUseOpMsg","supportsOpMsg","session","finalCmd","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","greaterThan","err","applySession","$clusterTime","isSharded","mode","$query","$readPreference","toJSON","commandOptions","numberToSkip","numberToReturn","checkKeys","slaveOk","cmdNs","db","message","Msg","Query","write","query","isExplain","$explain","ReadPreference","primary","batchSize","limit","skip","Math","abs","queryOptions","pre32Limit","projection","returnFieldSelector","toString","tailable","oplogReplay","timeout","noCursorTimeout","awaitData","partial","pluckBSONSerializeOptions","result","documents","getMore","cursorId","fullResult","wireVersion","maxWireVersion","getMoreOp","GetMore","applyCommonQueryOptions","cursor","nextBatch","getMoreCmd","collection","maxAwaitTimeMS","maxTimeMS","documentsReturnedIn","killCursors","cursorIds","Array","isArray","KillCursor","noResponse","cursors","cursorNotFound","length","COMMAND_STARTED","COMMAND_SUCCEEDED","COMMAND_FAILED","CLUSTER_TIME_RECEIVED","MESSAGE","autoEncrypter","MongoMissingDependencyError","serverWireVersion","MongoCompatibilityError","encrypt","encrypted","decrypt","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","operationDescription","get","responseTo","delete","moreToCome","set","requestId","socketTimeoutOverride","setTimeout","parse","document","updateSessionFromResponse","writeConcernError","MongoWriteConcernError","ok","$err","errmsg","code","MongoServerError","remoteAddress","remotePort","uuidV4","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","raw","started","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","reply","CommandFailedEvent","CommandSucceededEvent","writeCommand","e"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/cmap/connection.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasSessionSupport = exports.CryptoConnection = exports.APM_EVENTS = exports.Connection = void 0;\nconst message_stream_1 = require(\"./message_stream\");\nconst stream_description_1 = require(\"./stream_description\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\nconst error_1 = require(\"../error\");\nconst commands_1 = require(\"./commands\");\nconst bson_1 = require(\"../bson\");\nconst shared_1 = require(\"./wire_protocol/shared\");\nconst read_preference_1 = require(\"../read_preference\");\nconst mongo_types_1 = require(\"../mongo_types\");\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kIsMaster = Symbol('ismaster');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kFullResult = Symbol('fullResult');\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n    constructor(stream, options) {\n        var _a, _b;\n        super();\n        this.id = options.id;\n        this.address = streamIdentifier(stream);\n        this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n        this.monitorCommands = options.monitorCommands;\n        this.serverApi = options.serverApi;\n        this.closed = false;\n        this.destroyed = false;\n        this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n        this[kGeneration] = options.generation;\n        this[kLastUseTime] = utils_1.now();\n        // setup parser stream and message handling\n        this[kQueue] = new Map();\n        this[kMessageStream] = new message_stream_1.MessageStream({\n            ...options,\n            maxBsonMessageSize: (_b = this.ismaster) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n        });\n        this[kMessageStream].on('message', messageHandler(this));\n        this[kStream] = stream;\n        stream.on('error', () => {\n            /* ignore errors, listen to `close` instead */\n        });\n        this[kMessageStream].on('error', error => this.handleIssue({ destroy: error }));\n        stream.on('close', () => this.handleIssue({ isClose: true }));\n        stream.on('timeout', () => this.handleIssue({ isTimeout: true, destroy: true }));\n        // hook the message stream up to the passed in stream\n        stream.pipe(this[kMessageStream]);\n        this[kMessageStream].pipe(stream);\n    }\n    get description() {\n        return this[kDescription];\n    }\n    get ismaster() {\n        return this[kIsMaster];\n    }\n    // the `connect` method stores the result of the handshake ismaster on the connection\n    set ismaster(response) {\n        this[kDescription].receiveResponse(response);\n        this[kDescription] = Object.freeze(this[kDescription]);\n        // TODO: remove this, and only use the `StreamDescription` in the future\n        this[kIsMaster] = response;\n    }\n    get serviceId() {\n        var _a;\n        return (_a = this.ismaster) === null || _a === void 0 ? void 0 : _a.serviceId;\n    }\n    get loadBalanced() {\n        return this.description.loadBalanced;\n    }\n    get generation() {\n        return this[kGeneration] || 0;\n    }\n    set generation(generation) {\n        this[kGeneration] = generation;\n    }\n    get idleTime() {\n        return utils_1.calculateDurationInMs(this[kLastUseTime]);\n    }\n    get clusterTime() {\n        return this[kClusterTime];\n    }\n    get stream() {\n        return this[kStream];\n    }\n    markAvailable() {\n        this[kLastUseTime] = utils_1.now();\n    }\n    handleIssue(issue) {\n        if (this.closed) {\n            return;\n        }\n        if (issue.destroy) {\n            this[kStream].destroy(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n        }\n        this.closed = true;\n        for (const [, op] of this[kQueue]) {\n            if (issue.isTimeout) {\n                op.cb(new error_1.MongoNetworkTimeoutError(`connection ${this.id} to ${this.address} timed out`, {\n                    beforeHandshake: this.ismaster == null\n                }));\n            }\n            else if (issue.isClose) {\n                op.cb(new error_1.MongoNetworkError(`connection ${this.id} to ${this.address} closed`));\n            }\n            else {\n                op.cb(typeof issue.destroy === 'boolean' ? undefined : issue.destroy);\n            }\n        }\n        this[kQueue].clear();\n        this.emit(Connection.CLOSE);\n    }\n    destroy(options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = { force: false };\n        }\n        this.removeAllListeners(Connection.PINNED);\n        this.removeAllListeners(Connection.UNPINNED);\n        options = Object.assign({ force: false }, options);\n        if (this[kStream] == null || this.destroyed) {\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n            return;\n        }\n        if (options.force) {\n            this[kStream].destroy();\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n            return;\n        }\n        this[kStream].end(() => {\n            this.destroyed = true;\n            if (typeof callback === 'function') {\n                callback();\n            }\n        });\n    }\n    /** @internal */\n    command(ns, cmd, options, callback) {\n        if (!(ns instanceof utils_1.MongoDBNamespace)) {\n            // TODO(NODE-3483): Replace this with a MongoCommandError\n            throw new error_1.MongoRuntimeError('Must provide a MongoDBNamespace instance');\n        }\n        const readPreference = shared_1.getReadPreference(cmd, options);\n        const shouldUseOpMsg = supportsOpMsg(this);\n        const session = options === null || options === void 0 ? void 0 : options.session;\n        let clusterTime = this.clusterTime;\n        let finalCmd = Object.assign({}, cmd);\n        if (this.serverApi) {\n            const { version, strict, deprecationErrors } = this.serverApi;\n            finalCmd.apiVersion = version;\n            if (strict != null)\n                finalCmd.apiStrict = strict;\n            if (deprecationErrors != null)\n                finalCmd.apiDeprecationErrors = deprecationErrors;\n        }\n        if (hasSessionSupport(this) && session) {\n            if (session.clusterTime &&\n                clusterTime &&\n                session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n                clusterTime = session.clusterTime;\n            }\n            const err = sessions_1.applySession(session, finalCmd, options);\n            if (err) {\n                return callback(err);\n            }\n        }\n        // if we have a known cluster time, gossip it\n        if (clusterTime) {\n            finalCmd.$clusterTime = clusterTime;\n        }\n        if (shared_1.isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n            finalCmd = {\n                $query: finalCmd,\n                $readPreference: readPreference.toJSON()\n            };\n        }\n        const commandOptions = Object.assign({\n            command: true,\n            numberToSkip: 0,\n            numberToReturn: -1,\n            checkKeys: false,\n            // This value is not overridable\n            slaveOk: readPreference.slaveOk()\n        }, options);\n        const cmdNs = `${ns.db}.$cmd`;\n        const message = shouldUseOpMsg\n            ? new commands_1.Msg(cmdNs, finalCmd, commandOptions)\n            : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n        try {\n            write(this, message, commandOptions, callback);\n        }\n        catch (err) {\n            callback(err);\n        }\n    }\n    /** @internal */\n    query(ns, cmd, options, callback) {\n        var _a;\n        const isExplain = cmd.$explain != null;\n        const readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n        const batchSize = options.batchSize || 0;\n        const limit = options.limit;\n        const numberToSkip = options.skip || 0;\n        let numberToReturn = 0;\n        if (limit &&\n            (limit < 0 || (limit !== 0 && limit < batchSize) || (limit > 0 && batchSize === 0))) {\n            numberToReturn = limit;\n        }\n        else {\n            numberToReturn = batchSize;\n        }\n        if (isExplain) {\n            // nToReturn must be 0 (match all) or negative (match N and close cursor)\n            // nToReturn > 0 will give explain results equivalent to limit(0)\n            numberToReturn = -Math.abs(limit || 0);\n        }\n        const queryOptions = {\n            numberToSkip,\n            numberToReturn,\n            pre32Limit: typeof limit === 'number' ? limit : undefined,\n            checkKeys: false,\n            slaveOk: readPreference.slaveOk()\n        };\n        if (options.projection) {\n            queryOptions.returnFieldSelector = options.projection;\n        }\n        const query = new commands_1.Query(ns.toString(), cmd, queryOptions);\n        if (typeof options.tailable === 'boolean') {\n            query.tailable = options.tailable;\n        }\n        if (typeof options.oplogReplay === 'boolean') {\n            query.oplogReplay = options.oplogReplay;\n        }\n        if (typeof options.timeout === 'boolean') {\n            query.noCursorTimeout = !options.timeout;\n        }\n        else if (typeof options.noCursorTimeout === 'boolean') {\n            query.noCursorTimeout = options.noCursorTimeout;\n        }\n        if (typeof options.awaitData === 'boolean') {\n            query.awaitData = options.awaitData;\n        }\n        if (typeof options.partial === 'boolean') {\n            query.partial = options.partial;\n        }\n        write(this, query, { [kFullResult]: true, ...bson_1.pluckBSONSerializeOptions(options) }, (err, result) => {\n            if (err || !result)\n                return callback(err, result);\n            if (isExplain && result.documents && result.documents[0]) {\n                return callback(undefined, result.documents[0]);\n            }\n            callback(undefined, result);\n        });\n    }\n    /** @internal */\n    getMore(ns, cursorId, options, callback) {\n        const fullResult = !!options[kFullResult];\n        const wireVersion = utils_1.maxWireVersion(this);\n        if (!cursorId) {\n            // TODO(NODE-3483): Replace this with a MongoCommandError\n            callback(new error_1.MongoRuntimeError('Invalid internal cursor state, no known cursor id'));\n            return;\n        }\n        if (wireVersion < 4) {\n            const getMoreOp = new commands_1.GetMore(ns.toString(), cursorId, { numberToReturn: options.batchSize });\n            const queryOptions = shared_1.applyCommonQueryOptions({}, Object.assign(options, { ...bson_1.pluckBSONSerializeOptions(options) }));\n            queryOptions[kFullResult] = true;\n            queryOptions.command = true;\n            write(this, getMoreOp, queryOptions, (err, response) => {\n                if (fullResult)\n                    return callback(err, response);\n                if (err)\n                    return callback(err);\n                callback(undefined, { cursor: { id: response.cursorId, nextBatch: response.documents } });\n            });\n            return;\n        }\n        const getMoreCmd = {\n            getMore: cursorId,\n            collection: ns.collection\n        };\n        if (typeof options.batchSize === 'number') {\n            getMoreCmd.batchSize = Math.abs(options.batchSize);\n        }\n        if (typeof options.maxAwaitTimeMS === 'number') {\n            getMoreCmd.maxTimeMS = options.maxAwaitTimeMS;\n        }\n        const commandOptions = Object.assign({\n            returnFieldSelector: null,\n            documentsReturnedIn: 'nextBatch'\n        }, options);\n        this.command(ns, getMoreCmd, commandOptions, callback);\n    }\n    /** @internal */\n    killCursors(ns, cursorIds, options, callback) {\n        if (!cursorIds || !Array.isArray(cursorIds)) {\n            // TODO(NODE-3483): Replace this with a MongoCommandError\n            throw new error_1.MongoRuntimeError(`Invalid list of cursor ids provided: ${cursorIds}`);\n        }\n        if (utils_1.maxWireVersion(this) < 4) {\n            try {\n                write(this, new commands_1.KillCursor(ns.toString(), cursorIds), { noResponse: true, ...options }, callback);\n            }\n            catch (err) {\n                callback(err);\n            }\n            return;\n        }\n        this.command(ns, { killCursors: ns.collection, cursors: cursorIds }, { [kFullResult]: true, ...options }, (err, response) => {\n            if (err || !response)\n                return callback(err);\n            if (response.cursorNotFound) {\n                return callback(new error_1.MongoNetworkError('cursor killed or timed out'), null);\n            }\n            if (!Array.isArray(response.documents) || response.documents.length === 0) {\n                return callback(\n                // TODO(NODE-3483)\n                new error_1.MongoRuntimeError(`invalid killCursors result returned for cursor id ${cursorIds[0]}`));\n            }\n            callback(undefined, response.documents[0]);\n        });\n    }\n}\nexports.Connection = Connection;\n/** @event */\nConnection.COMMAND_STARTED = 'commandStarted';\n/** @event */\nConnection.COMMAND_SUCCEEDED = 'commandSucceeded';\n/** @event */\nConnection.COMMAND_FAILED = 'commandFailed';\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = 'clusterTimeReceived';\n/** @event */\nConnection.CLOSE = 'close';\n/** @event */\nConnection.MESSAGE = 'message';\n/** @event */\nConnection.PINNED = 'pinned';\n/** @event */\nConnection.UNPINNED = 'unpinned';\n/** @public */\nexports.APM_EVENTS = [\n    Connection.COMMAND_STARTED,\n    Connection.COMMAND_SUCCEEDED,\n    Connection.COMMAND_FAILED\n];\n/** @internal */\nclass CryptoConnection extends Connection {\n    constructor(stream, options) {\n        super(stream, options);\n        this[kAutoEncrypter] = options.autoEncrypter;\n    }\n    /** @internal @override */\n    command(ns, cmd, options, callback) {\n        const autoEncrypter = this[kAutoEncrypter];\n        if (!autoEncrypter) {\n            return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n        }\n        const serverWireVersion = utils_1.maxWireVersion(this);\n        if (serverWireVersion === 0) {\n            // This means the initial handshake hasn't happened yet\n            return super.command(ns, cmd, options, callback);\n        }\n        if (serverWireVersion < 8) {\n            callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n            return;\n        }\n        autoEncrypter.encrypt(ns.toString(), cmd, options, (err, encrypted) => {\n            if (err || encrypted == null) {\n                callback(err, null);\n                return;\n            }\n            super.command(ns, encrypted, options, (err, response) => {\n                if (err || response == null) {\n                    callback(err, response);\n                    return;\n                }\n                autoEncrypter.decrypt(response, options, callback);\n            });\n        });\n    }\n}\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\nfunction hasSessionSupport(conn) {\n    const description = conn.description;\n    return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction supportsOpMsg(conn) {\n    const description = conn.description;\n    if (description == null) {\n        return false;\n    }\n    return utils_1.maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction messageHandler(conn) {\n    return function messageHandler(message) {\n        // always emit the message, in case we are streaming\n        conn.emit('message', message);\n        const operationDescription = conn[kQueue].get(message.responseTo);\n        if (!operationDescription) {\n            return;\n        }\n        const callback = operationDescription.cb;\n        // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n        // track response, however the server currently synthetically produces remote requests\n        // making the `responseTo` change on each response\n        conn[kQueue].delete(message.responseTo);\n        if ('moreToCome' in message && message.moreToCome) {\n            // requeue the callback for next synthetic request\n            conn[kQueue].set(message.requestId, operationDescription);\n        }\n        else if (operationDescription.socketTimeoutOverride) {\n            conn[kStream].setTimeout(conn.socketTimeoutMS);\n        }\n        try {\n            // Pass in the entire description because it has BSON parsing options\n            message.parse(operationDescription);\n        }\n        catch (err) {\n            // If this error is generated by our own code, it will already have the correct class applied\n            // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n            // in either case, it should not be wrapped\n            callback(err);\n            return;\n        }\n        if (message.documents[0]) {\n            const document = message.documents[0];\n            const session = operationDescription.session;\n            if (session) {\n                sessions_1.updateSessionFromResponse(session, document);\n            }\n            if (document.$clusterTime) {\n                conn[kClusterTime] = document.$clusterTime;\n                conn.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n            }\n            if (operationDescription.command) {\n                if (document.writeConcernError) {\n                    callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n                    return;\n                }\n                if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n                    callback(new error_1.MongoServerError(document));\n                    return;\n                }\n            }\n            else {\n                // Pre 3.2 support\n                if (document.ok === 0 || document.$err || document.errmsg) {\n                    callback(new error_1.MongoServerError(document));\n                    return;\n                }\n            }\n        }\n        callback(undefined, operationDescription.fullResult ? message : message.documents[0]);\n    };\n}\nfunction streamIdentifier(stream) {\n    if (typeof stream.address === 'function') {\n        return `${stream.remoteAddress}:${stream.remotePort}`;\n    }\n    return utils_1.uuidV4().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n    if (typeof options === 'function') {\n        callback = options;\n    }\n    options = options !== null && options !== void 0 ? options : {};\n    const operationDescription = {\n        requestId: command.requestId,\n        cb: callback,\n        session: options.session,\n        fullResult: !!options[kFullResult],\n        noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n        documentsReturnedIn: options.documentsReturnedIn,\n        command: !!options.command,\n        // for BSON parsing\n        promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n        promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n        promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n        bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n        raw: typeof options.raw === 'boolean' ? options.raw : false,\n        started: 0\n    };\n    if (conn[kDescription] && conn[kDescription].compressor) {\n        operationDescription.agreedCompressor = conn[kDescription].compressor;\n        if (conn[kDescription].zlibCompressionLevel) {\n            operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n        }\n    }\n    if (typeof options.socketTimeoutMS === 'number') {\n        operationDescription.socketTimeoutOverride = true;\n        conn[kStream].setTimeout(options.socketTimeoutMS);\n    }\n    // if command monitoring is enabled we need to modify the callback here\n    if (conn.monitorCommands) {\n        conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n        operationDescription.started = utils_1.now();\n        operationDescription.cb = (err, reply) => {\n            if (err) {\n                conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n            }\n            else {\n                if (reply && (reply.ok === 0 || reply.$err)) {\n                    conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n                }\n                else {\n                    conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n                }\n            }\n            if (typeof callback === 'function') {\n                callback(err, reply);\n            }\n        };\n    }\n    if (!operationDescription.noResponse) {\n        conn[kQueue].set(operationDescription.requestId, operationDescription);\n    }\n    try {\n        conn[kMessageStream].writeCommand(command, operationDescription);\n    }\n    catch (e) {\n        if (!operationDescription.noResponse) {\n            conn[kQueue].delete(operationDescription.requestId);\n            operationDescription.cb(e);\n            return;\n        }\n    }\n    if (operationDescription.noResponse) {\n        operationDescription.cb();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}