{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\n\nconst utils_1 = require(\"./utils\");\n\nconst read_preference_1 = require(\"./read_preference\");\n\nconst utils_2 = require(\"./utils\");\n\nconst bson_1 = require(\"./bson\");\n\nconst error_1 = require(\"./error\");\n\nconst unordered_1 = require(\"./bulk/unordered\");\n\nconst ordered_1 = require(\"./bulk/ordered\");\n\nconst change_stream_1 = require(\"./change_stream\");\n\nconst write_concern_1 = require(\"./write_concern\");\n\nconst read_concern_1 = require(\"./read_concern\");\n\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\n\nconst bulk_write_1 = require(\"./operations/bulk_write\");\n\nconst count_documents_1 = require(\"./operations/count_documents\");\n\nconst indexes_1 = require(\"./operations/indexes\");\n\nconst distinct_1 = require(\"./operations/distinct\");\n\nconst drop_1 = require(\"./operations/drop\");\n\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\n\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\n\nconst insert_1 = require(\"./operations/insert\");\n\nconst update_1 = require(\"./operations/update\");\n\nconst delete_1 = require(\"./operations/delete\");\n\nconst is_capped_1 = require(\"./operations/is_capped\");\n\nconst map_reduce_1 = require(\"./operations/map_reduce\");\n\nconst options_operation_1 = require(\"./operations/options_operation\");\n\nconst rename_1 = require(\"./operations/rename\");\n\nconst stats_1 = require(\"./operations/stats\");\n\nconst execute_operation_1 = require(\"./operations/execute_operation\");\n\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\n\n\nclass Collection {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  constructor(db, name, options) {\n    var _a, _b;\n\n    utils_2.checkCollectionName(name); // Internal state\n\n    this.s = {\n      db,\n      options,\n      namespace: new utils_2.MongoDBNamespace(db.databaseName, name),\n      pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: bson_1.resolveBSONOptions(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n      slaveOk: options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk\n    };\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n\n\n  get dbName() {\n    return this.s.namespace.db;\n  }\n  /**\n   * The name of this collection\n   */\n\n\n  get collectionName() {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.s.namespace.collection;\n  }\n  /**\n   * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n   */\n\n\n  get namespace() {\n    return this.s.namespace.toString();\n  }\n  /**\n   * The current readConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get readConcern() {\n    if (this.s.readConcern == null) {\n      return this.s.db.readConcern;\n    }\n\n    return this.s.readConcern;\n  }\n  /**\n   * The current readPreference of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get readPreference() {\n    if (this.s.readPreference == null) {\n      return this.s.db.readPreference;\n    }\n\n    return this.s.readPreference;\n  }\n\n  get bsonOptions() {\n    return this.s.bsonOptions;\n  }\n  /**\n   * The current writeConcern of the collection. If not explicitly defined for\n   * this collection, will be inherited from the parent DB\n   */\n\n\n  get writeConcern() {\n    if (this.s.writeConcern == null) {\n      return this.s.db.writeConcern;\n    }\n\n    return this.s.writeConcern;\n  }\n  /** The current index hint for the collection */\n\n\n  get hint() {\n    return this.s.collectionHint;\n  }\n\n  set hint(v) {\n    this.s.collectionHint = utils_2.normalizeHintField(v);\n  }\n\n  insertOne(doc, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n    // we support that option style here only\n\n\n    if (options && Reflect.get(options, 'w')) {\n      options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n    }\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertOneOperation(this, doc, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  insertMany(docs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {\n      ordered: true\n    };\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertManyOperation(this, docs, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  bulkWrite(operations, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: true\n    };\n\n    if (!Array.isArray(operations)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n    }\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new bulk_write_1.BulkWriteOperation(this, operations, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  updateOne(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateOneOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  replaceOne(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.ReplaceOneOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  updateMany(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateManyOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  deleteOne(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteOneOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  deleteMany(filter, options, callback) {\n    if (filter == null) {\n      filter = {};\n      options = {};\n      callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteManyOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  rename(newName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {}; // Intentionally, we do not inherit options from parent for this operation.\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new rename_1.RenameOperation(this, newName, { ...options,\n      readPreference: read_preference_1.ReadPreference.PRIMARY\n    }), callback);\n  }\n\n  drop(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n  }\n\n  findOne(filter, options, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');\n    }\n\n    if (typeof filter === 'function') {\n      callback = filter;\n      filter = {};\n      options = {};\n    }\n\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    const finalFilter = filter !== null && filter !== void 0 ? filter : {};\n    const finalOptions = options !== null && options !== void 0 ? options : {};\n    return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n  }\n\n  find(filter, options) {\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"collection.find()\" accepts at most two arguments');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new find_cursor_1.FindCursor(utils_2.getTopology(this), this.s.namespace, filter, utils_1.resolveOptions(this, options));\n  }\n\n  options(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new options_operation_1.OptionsOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  isCapped(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new is_capped_1.IsCappedOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  createIndex(indexSpec, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  createIndexes(indexSpecs, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options ? Object.assign({}, options) : {};\n    if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  dropIndex(indexName, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = utils_1.resolveOptions(this, options); // Run only against primary\n\n    options.readPreference = read_preference_1.ReadPreference.primary;\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexOperation(this, indexName, options), callback);\n  }\n\n  dropIndexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n  /**\n   * Get the list of all indexes information for the collection.\n   *\n   * @param options - Optional settings for the command\n   */\n\n\n  listIndexes(options) {\n    return new indexes_1.ListIndexesCursor(this, utils_1.resolveOptions(this, options));\n  }\n\n  indexExists(indexes, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexExistsOperation(this, indexes, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  indexInformation(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  estimatedDocumentCount(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new estimated_document_count_1.EstimatedDocumentCountOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  countDocuments(filter, options, callback) {\n    if (filter == null) {\n      filter = {}, options = {}, callback = undefined;\n    } else if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 2) {\n        if (typeof options === 'function') callback = options, options = {};\n      }\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  } // Implementation\n\n\n  distinct(key, filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (arguments.length === 3 && typeof options === 'function') {\n        callback = options, options = {};\n      }\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new distinct_1.DistinctOperation(this, key, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  indexes(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  stats(options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new stats_1.CollStatsOperation(this, options), callback);\n  }\n\n  findOneAndDelete(filter, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndDeleteOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  findOneAndReplace(filter, replacement, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n  }\n\n  findOneAndUpdate(filter, update, options, callback) {\n    if (typeof options === 'function') callback = options, options = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n  }\n  /**\n   * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n   *\n   * @param pipeline - An array of aggregation pipelines to execute\n   * @param options - Optional settings for the command\n   */\n\n\n  aggregate(pipeline = [], options) {\n    if (arguments.length > 2) {\n      throw new error_1.MongoInvalidArgumentError('Method \"collection.aggregate()\" accepts at most two arguments');\n    }\n\n    if (!Array.isArray(pipeline)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n    }\n\n    if (typeof options === 'function') {\n      throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n    }\n\n    return new aggregation_cursor_1.AggregationCursor(utils_2.getTopology(this), this.s.namespace, pipeline, utils_1.resolveOptions(this, options));\n  }\n  /**\n   * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n   *\n   * @since 3.0.0\n   * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n   * @param options - Optional settings for the command\n   */\n\n\n  watch(pipeline = [], options = {}) {\n    // Allow optionally not specifying a pipeline\n    if (!Array.isArray(pipeline)) {\n      options = pipeline;\n      pipeline = [];\n    }\n\n    return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n  }\n\n  mapReduce(map, reduce, options, callback) {\n    if ('function' === typeof options) callback = options, options = {}; // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n    // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n\n    if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n      throw new error_1.MongoInvalidArgumentError('Option \"out\" must be defined, see mongodb docs for possible values');\n    }\n\n    if ('function' === typeof map) {\n      map = map.toString();\n    }\n\n    if ('function' === typeof reduce) {\n      reduce = reduce.toString();\n    }\n\n    if ('function' === typeof options.finalize) {\n      options.finalize = options.finalize.toString();\n    }\n\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new map_reduce_1.MapReduceOperation(this, map, reduce, utils_1.resolveOptions(this, options)), callback);\n  }\n  /** Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order. */\n\n\n  initializeUnorderedBulkOp(options) {\n    return new unordered_1.UnorderedBulkOperation(this, utils_1.resolveOptions(this, options));\n  }\n  /** Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types. */\n\n\n  initializeOrderedBulkOp(options) {\n    return new ordered_1.OrderedBulkOperation(this, utils_1.resolveOptions(this, options));\n  }\n  /** Get the db scoped logger */\n\n\n  getLogger() {\n    return this.s.db.s.logger;\n  }\n\n  get logger() {\n    return this.s.db.s.logger;\n  }\n  /**\n   * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n   * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n   * can be overridden by setting the **forceServerObjectId** flag.\n   *\n   * @deprecated Use insertOne, insertMany or bulkWrite instead.\n   * @param docs - The documents to insert\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  insert(docs, options, callback) {\n    utils_1.emitWarningOnce('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options || {\n      ordered: false\n    };\n    docs = !Array.isArray(docs) ? [docs] : docs;\n\n    if (options.keepGoing === true) {\n      options.ordered = false;\n    }\n\n    return this.insertMany(docs, options, callback);\n  }\n  /**\n   * Updates documents.\n   *\n   * @deprecated use updateOne, updateMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param update - The update operations to be applied to the documents\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  update(selector, update, options, callback) {\n    utils_1.emitWarningOnce('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.updateMany(selector, update, options, callback);\n  }\n  /**\n   * Remove documents.\n   *\n   * @deprecated use deleteOne, deleteMany or bulkWrite\n   * @param selector - The selector for the update operation.\n   * @param options - Optional settings for the command\n   * @param callback - An optional callback, a Promise will be returned if none is provided\n   */\n\n\n  remove(selector, options, callback) {\n    utils_1.emitWarningOnce('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n    if (typeof options === 'function') callback = options, options = {};\n    options = options !== null && options !== void 0 ? options : {};\n    return this.deleteMany(selector, options, callback);\n  }\n\n  count(filter, options, callback) {\n    if (typeof filter === 'function') {\n      callback = filter, filter = {}, options = {};\n    } else {\n      if (typeof options === 'function') callback = options, options = {};\n    }\n\n    filter !== null && filter !== void 0 ? filter : filter = {};\n    return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n  }\n\n}\n\nexports.Collection = Collection;","map":{"version":3,"names":["Object","defineProperty","exports","value","Collection","utils_1","require","read_preference_1","utils_2","bson_1","error_1","unordered_1","ordered_1","change_stream_1","write_concern_1","read_concern_1","aggregation_cursor_1","bulk_write_1","count_documents_1","indexes_1","distinct_1","drop_1","estimated_document_count_1","find_and_modify_1","insert_1","update_1","delete_1","is_capped_1","map_reduce_1","options_operation_1","rename_1","stats_1","execute_operation_1","find_cursor_1","constructor","db","name","options","_a","_b","checkCollectionName","s","namespace","MongoDBNamespace","databaseName","pkFactory","DEFAULT_PK_FACTORY","readPreference","ReadPreference","fromOptions","bsonOptions","resolveBSONOptions","readConcern","ReadConcern","writeConcern","WriteConcern","slaveOk","dbName","collectionName","collection","toString","hint","collectionHint","v","normalizeHintField","insertOne","doc","callback","Reflect","get","executeOperation","getTopology","InsertOneOperation","resolveOptions","insertMany","docs","assign","ordered","InsertManyOperation","bulkWrite","operations","Array","isArray","MongoInvalidArgumentError","BulkWriteOperation","updateOne","filter","update","UpdateOneOperation","replaceOne","replacement","ReplaceOneOperation","updateMany","UpdateManyOperation","deleteOne","DeleteOneOperation","deleteMany","undefined","DeleteManyOperation","rename","newName","RenameOperation","PRIMARY","drop","DropCollectionOperation","findOne","finalFilter","finalOptions","find","limit","batchSize","next","arguments","length","FindCursor","OptionsOperation","isCapped","IsCappedOperation","createIndex","indexSpec","CreateIndexOperation","createIndexes","indexSpecs","maxTimeMS","CreateIndexesOperation","dropIndex","indexName","primary","DropIndexOperation","dropIndexes","DropIndexesOperation","listIndexes","ListIndexesCursor","indexExists","indexes","IndexExistsOperation","indexInformation","IndexInformationOperation","estimatedDocumentCount","EstimatedDocumentCountOperation","countDocuments","CountDocumentsOperation","distinct","key","DistinctOperation","IndexesOperation","stats","CollStatsOperation","findOneAndDelete","FindOneAndDeleteOperation","findOneAndReplace","FindOneAndReplaceOperation","findOneAndUpdate","FindOneAndUpdateOperation","aggregate","pipeline","AggregationCursor","watch","ChangeStream","mapReduce","map","reduce","out","finalize","MapReduceOperation","initializeUnorderedBulkOp","UnorderedBulkOperation","initializeOrderedBulkOp","OrderedBulkOperation","getLogger","logger","insert","emitWarningOnce","keepGoing","selector","remove","count"],"sources":["/Users/yoannesfigueiras/node_modules/mongodb/lib/collection.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Collection = void 0;\nconst utils_1 = require(\"./utils\");\nconst read_preference_1 = require(\"./read_preference\");\nconst utils_2 = require(\"./utils\");\nconst bson_1 = require(\"./bson\");\nconst error_1 = require(\"./error\");\nconst unordered_1 = require(\"./bulk/unordered\");\nconst ordered_1 = require(\"./bulk/ordered\");\nconst change_stream_1 = require(\"./change_stream\");\nconst write_concern_1 = require(\"./write_concern\");\nconst read_concern_1 = require(\"./read_concern\");\nconst aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nconst bulk_write_1 = require(\"./operations/bulk_write\");\nconst count_documents_1 = require(\"./operations/count_documents\");\nconst indexes_1 = require(\"./operations/indexes\");\nconst distinct_1 = require(\"./operations/distinct\");\nconst drop_1 = require(\"./operations/drop\");\nconst estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nconst find_and_modify_1 = require(\"./operations/find_and_modify\");\nconst insert_1 = require(\"./operations/insert\");\nconst update_1 = require(\"./operations/update\");\nconst delete_1 = require(\"./operations/delete\");\nconst is_capped_1 = require(\"./operations/is_capped\");\nconst map_reduce_1 = require(\"./operations/map_reduce\");\nconst options_operation_1 = require(\"./operations/options_operation\");\nconst rename_1 = require(\"./operations/rename\");\nconst stats_1 = require(\"./operations/stats\");\nconst execute_operation_1 = require(\"./operations/execute_operation\");\nconst find_cursor_1 = require(\"./cursor/find_cursor\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\nclass Collection {\n    /**\n     * Create a new Collection instance\n     * @internal\n     */\n    constructor(db, name, options) {\n        var _a, _b;\n        utils_2.checkCollectionName(name);\n        // Internal state\n        this.s = {\n            db,\n            options,\n            namespace: new utils_2.MongoDBNamespace(db.databaseName, name),\n            pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n            readPreference: read_preference_1.ReadPreference.fromOptions(options),\n            bsonOptions: bson_1.resolveBSONOptions(options, db),\n            readConcern: read_concern_1.ReadConcern.fromOptions(options),\n            writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n            slaveOk: options == null || options.slaveOk == null ? db.slaveOk : options.slaveOk\n        };\n    }\n    /**\n     * The name of the database this collection belongs to\n     */\n    get dbName() {\n        return this.s.namespace.db;\n    }\n    /**\n     * The name of this collection\n     */\n    get collectionName() {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this.s.namespace.collection;\n    }\n    /**\n     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n     */\n    get namespace() {\n        return this.s.namespace.toString();\n    }\n    /**\n     * The current readConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get readConcern() {\n        if (this.s.readConcern == null) {\n            return this.s.db.readConcern;\n        }\n        return this.s.readConcern;\n    }\n    /**\n     * The current readPreference of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get readPreference() {\n        if (this.s.readPreference == null) {\n            return this.s.db.readPreference;\n        }\n        return this.s.readPreference;\n    }\n    get bsonOptions() {\n        return this.s.bsonOptions;\n    }\n    /**\n     * The current writeConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n    get writeConcern() {\n        if (this.s.writeConcern == null) {\n            return this.s.db.writeConcern;\n        }\n        return this.s.writeConcern;\n    }\n    /** The current index hint for the collection */\n    get hint() {\n        return this.s.collectionHint;\n    }\n    set hint(v) {\n        this.s.collectionHint = utils_2.normalizeHintField(v);\n    }\n    insertOne(doc, options, callback) {\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n        // we support that option style here only\n        if (options && Reflect.get(options, 'w')) {\n            options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n        }\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertOneOperation(this, doc, utils_1.resolveOptions(this, options)), callback);\n    }\n    insertMany(docs, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options ? Object.assign({}, options) : { ordered: true };\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new insert_1.InsertManyOperation(this, docs, utils_1.resolveOptions(this, options)), callback);\n    }\n    bulkWrite(operations, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options || { ordered: true };\n        if (!Array.isArray(operations)) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n        }\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new bulk_write_1.BulkWriteOperation(this, operations, utils_1.resolveOptions(this, options)), callback);\n    }\n    updateOne(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateOneOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n    }\n    replaceOne(filter, replacement, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.ReplaceOneOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n    }\n    updateMany(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new update_1.UpdateManyOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n    }\n    deleteOne(filter, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteOneOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    deleteMany(filter, options, callback) {\n        if (filter == null) {\n            filter = {};\n            options = {};\n            callback = undefined;\n        }\n        else if (typeof filter === 'function') {\n            callback = filter;\n            filter = {};\n            options = {};\n        }\n        else if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new delete_1.DeleteManyOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    rename(newName, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        // Intentionally, we do not inherit options from parent for this operation.\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new rename_1.RenameOperation(this, newName, {\n            ...options,\n            readPreference: read_preference_1.ReadPreference.PRIMARY\n        }), callback);\n    }\n    drop(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n    }\n    findOne(filter, options, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');\n        }\n        if (typeof filter === 'function') {\n            callback = filter;\n            filter = {};\n            options = {};\n        }\n        if (typeof options === 'function') {\n            callback = options;\n            options = {};\n        }\n        const finalFilter = filter !== null && filter !== void 0 ? filter : {};\n        const finalOptions = options !== null && options !== void 0 ? options : {};\n        return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n    }\n    find(filter, options) {\n        if (arguments.length > 2) {\n            throw new error_1.MongoInvalidArgumentError('Method \"collection.find()\" accepts at most two arguments');\n        }\n        if (typeof options === 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n        }\n        return new find_cursor_1.FindCursor(utils_2.getTopology(this), this.s.namespace, filter, utils_1.resolveOptions(this, options));\n    }\n    options(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new options_operation_1.OptionsOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    isCapped(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new is_capped_1.IsCappedOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    createIndex(indexSpec, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, utils_1.resolveOptions(this, options)), callback);\n    }\n    createIndexes(indexSpecs, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options ? Object.assign({}, options) : {};\n        if (typeof options.maxTimeMS !== 'number')\n            delete options.maxTimeMS;\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, utils_1.resolveOptions(this, options)), callback);\n    }\n    dropIndex(indexName, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = utils_1.resolveOptions(this, options);\n        // Run only against primary\n        options.readPreference = read_preference_1.ReadPreference.primary;\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexOperation(this, indexName, options), callback);\n    }\n    dropIndexes(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.DropIndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    /**\n     * Get the list of all indexes information for the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n    listIndexes(options) {\n        return new indexes_1.ListIndexesCursor(this, utils_1.resolveOptions(this, options));\n    }\n    indexExists(indexes, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexExistsOperation(this, indexes, utils_1.resolveOptions(this, options)), callback);\n    }\n    indexInformation(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, utils_1.resolveOptions(this, options)), callback);\n    }\n    estimatedDocumentCount(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new estimated_document_count_1.EstimatedDocumentCountOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    countDocuments(filter, options, callback) {\n        if (filter == null) {\n            (filter = {}), (options = {}), (callback = undefined);\n        }\n        else if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (arguments.length === 2) {\n                if (typeof options === 'function')\n                    (callback = options), (options = {});\n            }\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    // Implementation\n    distinct(key, filter, options, callback) {\n        if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (arguments.length === 3 && typeof options === 'function') {\n                (callback = options), (options = {});\n            }\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new distinct_1.DistinctOperation(this, key, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    indexes(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new indexes_1.IndexesOperation(this, utils_1.resolveOptions(this, options)), callback);\n    }\n    stats(options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new stats_1.CollStatsOperation(this, options), callback);\n    }\n    findOneAndDelete(filter, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndDeleteOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n    findOneAndReplace(filter, replacement, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, utils_1.resolveOptions(this, options)), callback);\n    }\n    findOneAndUpdate(filter, update, options, callback) {\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, utils_1.resolveOptions(this, options)), callback);\n    }\n    /**\n     * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n     *\n     * @param pipeline - An array of aggregation pipelines to execute\n     * @param options - Optional settings for the command\n     */\n    aggregate(pipeline = [], options) {\n        if (arguments.length > 2) {\n            throw new error_1.MongoInvalidArgumentError('Method \"collection.aggregate()\" accepts at most two arguments');\n        }\n        if (!Array.isArray(pipeline)) {\n            throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n        }\n        if (typeof options === 'function') {\n            throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n        }\n        return new aggregation_cursor_1.AggregationCursor(utils_2.getTopology(this), this.s.namespace, pipeline, utils_1.resolveOptions(this, options));\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n     *\n     * @since 3.0.0\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     */\n    watch(pipeline = [], options = {}) {\n        // Allow optionally not specifying a pipeline\n        if (!Array.isArray(pipeline)) {\n            options = pipeline;\n            pipeline = [];\n        }\n        return new change_stream_1.ChangeStream(this, pipeline, utils_1.resolveOptions(this, options));\n    }\n    mapReduce(map, reduce, options, callback) {\n        if ('function' === typeof options)\n            (callback = options), (options = {});\n        // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n        // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n        if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n            throw new error_1.MongoInvalidArgumentError('Option \"out\" must be defined, see mongodb docs for possible values');\n        }\n        if ('function' === typeof map) {\n            map = map.toString();\n        }\n        if ('function' === typeof reduce) {\n            reduce = reduce.toString();\n        }\n        if ('function' === typeof options.finalize) {\n            options.finalize = options.finalize.toString();\n        }\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new map_reduce_1.MapReduceOperation(this, map, reduce, utils_1.resolveOptions(this, options)), callback);\n    }\n    /** Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order. */\n    initializeUnorderedBulkOp(options) {\n        return new unordered_1.UnorderedBulkOperation(this, utils_1.resolveOptions(this, options));\n    }\n    /** Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types. */\n    initializeOrderedBulkOp(options) {\n        return new ordered_1.OrderedBulkOperation(this, utils_1.resolveOptions(this, options));\n    }\n    /** Get the db scoped logger */\n    getLogger() {\n        return this.s.db.s.logger;\n    }\n    get logger() {\n        return this.s.db.s.logger;\n    }\n    /**\n     * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @deprecated Use insertOne, insertMany or bulkWrite instead.\n     * @param docs - The documents to insert\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    insert(docs, options, callback) {\n        utils_1.emitWarningOnce('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options || { ordered: false };\n        docs = !Array.isArray(docs) ? [docs] : docs;\n        if (options.keepGoing === true) {\n            options.ordered = false;\n        }\n        return this.insertMany(docs, options, callback);\n    }\n    /**\n     * Updates documents.\n     *\n     * @deprecated use updateOne, updateMany or bulkWrite\n     * @param selector - The selector for the update operation.\n     * @param update - The update operations to be applied to the documents\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    update(selector, update, options, callback) {\n        utils_1.emitWarningOnce('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return this.updateMany(selector, update, options, callback);\n    }\n    /**\n     * Remove documents.\n     *\n     * @deprecated use deleteOne, deleteMany or bulkWrite\n     * @param selector - The selector for the update operation.\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    remove(selector, options, callback) {\n        utils_1.emitWarningOnce('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n        if (typeof options === 'function')\n            (callback = options), (options = {});\n        options = options !== null && options !== void 0 ? options : {};\n        return this.deleteMany(selector, options, callback);\n    }\n    count(filter, options, callback) {\n        if (typeof filter === 'function') {\n            (callback = filter), (filter = {}), (options = {});\n        }\n        else {\n            if (typeof options === 'function')\n                (callback = options), (options = {});\n        }\n        filter !== null && filter !== void 0 ? filter : (filter = {});\n        return execute_operation_1.executeOperation(utils_2.getTopology(this), new count_documents_1.CountDocumentsOperation(this, filter, utils_1.resolveOptions(this, options)), callback);\n    }\n}\nexports.Collection = Collection;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}